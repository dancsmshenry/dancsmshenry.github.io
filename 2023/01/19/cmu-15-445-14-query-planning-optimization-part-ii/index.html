<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="CMU 15-445 14-Query Planning Optimization Part II, C++">
    <meta name="baidu-site-verification" content="fmlEuI34ir">
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48">
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7">
    <meta name="description" content="Backround上节课说的是基于规则的优化器，而本节课要说的就是基于代价模型的优化器
基于代价模型，估计每个计划的好坏
然后从众多执行计划中，选取一个性价比最高的执行计划






Cost model components代价估算的三">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>CMU 15-445 14-Query Planning Optimization Part II | dancsmshenry&#39;s blog</title>
    <link rel="icon" type="image/jpeg" href="/roses.jpg">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?ce84511d3df71640a9378a69f6293044";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/roses.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">dancsmshenry's blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/roses.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">dancsmshenry's blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/26.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        CMU 15-445 14-Query Planning Optimization Part II
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                        <a href="/tags/Database/" target="_blank">
                            <span class="chip bg-color">Database</span>
                        </a>
                        
                        <a href="/tags/CMU-15-445/" target="_blank">
                            <span class="chip bg-color">CMU 15-445</span>
                        </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-01-19
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    dancsmshenry
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    3.8k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    13 分
                </div>
                
                

                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Backround"><a href="#Backround" class="headerlink" title="Backround"></a>Backround</h1><p>上节课说的是基于规则的优化器，而本节课要说的就是<strong>基于代价模型的优化器</strong></p>
<p>基于代价模型，估计每个计划的好坏</p>
<p>然后从众多执行计划中，选取一个性价比最高的执行计划</p>
<br>

<br>

<br>

<h1 id="Cost-model-components"><a href="#Cost-model-components" class="headerlink" title="Cost model components"></a>Cost model components</h1><p>代价估算的三个方向：</p>
<br>

<h2 id="Choice-1：Physical-costs"><a href="#Choice-1：Physical-costs" class="headerlink" title="Choice 1：Physical costs"></a>Choice 1：Physical costs</h2><p>物理代价（例如：需要多少CPU的计算，多少次IO，多少次miss cache，读取内存的开销，预取数据的开销）</p>
<p>极度依赖于硬件的性能（更换硬件环境，估算的代价标准都会有变动）</p>
<p>这种估值方案经常出现在数据库一体机上（例如：Oracle，因为硬件是不变的）</p>
<p>或者SQL Server上，主要是Windows对硬件的性能有较深的把控</p>
<p>一般是商用的会做的比较细，开源的一般不会</p>
<br>

<br>

<h2 id="Choice-2：Logical-costs"><a href="#Choice-2：Logical-costs" class="headerlink" title="Choice 2：Logical costs"></a>Choice 2：Logical costs</h2><p>逻辑开销，估算每个算子的开销</p>
<p>开销的计算和每个算子之间是独立的</p>
<p>需要数据的统计信息（比如分布之类的），以便知道算子处理多少数据，从而估计开销</p>
<br>

<br>

<h2 id="Choice-3：Algorithmic-costs"><a href="#Choice-3：Algorithmic-costs" class="headerlink" title="Choice 3：Algorithmic costs"></a>Choice 3：Algorithmic costs</h2><p>比较细的估计算子的开销，从算法的层次去估计开销</p>
<p>例如：join，具体分为几个步骤、每个步骤的时间复杂度是多少</p>
<br>

<br>

<br>

<h1 id="Statistics"><a href="#Statistics" class="headerlink" title="Statistics"></a>Statistics</h1><p>而上述的三个方面，则非常依赖于DBMS中数据的<strong>统计信息</strong></p>
<p>因为针对不同的算子，只有知道该算子需要处理多少条数据，才能够准确的算出它的开销是多少</p>
<br>

<p>不同数据库更新其统计信息的方法，是不同的：</p>
<img src="statistics.png" style="zoom:150%;">

<br>

<br>

<h2 id="NR，V（A-R），SC（A-R）"><a href="#NR，V（A-R），SC（A-R）" class="headerlink" title="NR，V（A,R），SC（A,R）"></a>NR，V（A,R），SC（A,R）</h2><p>R：数据表的表名</p>
<p>A：数据表的某一列的列名</p>
<p>NR：当前的数据表中有多少条数据</p>
<p>V（A,R）：在当前数据表R的某一列A中，有多少个不同类型的值（比如性别一列，就只有男或女，这两种值）</p>
<p>SC（A,R）（全称：selection cardinality）：对于当前的选取方式，选取的基数是多少</p>
<ul>
<li><p>计算公式：NR/V（A,R）（计算的前提：是数据为平均、均匀分布的）</p>
</li>
<li><p>在当前的选取方法中，平均每次选取能够得到多少个值</p>
</li>
<li><p>对于这一列每一个单独的值，如果选取这个值，平均每次能获取到多少个值</p>
</li>
<li><p>比如在性别一列中，总共有50个男性和50个女性，那么此时选取出男性的基数就是50个</p>
</li>
</ul>
<br>

<br>

<h2 id="Logical-costs"><a href="#Logical-costs" class="headerlink" title="Logical costs"></a>Logical costs</h2><p>基于以下几种不同的情况，来分析SC（A,R）</p>
<br>

<p><strong>情况一</strong></p>
<p>针对数据表中的某一主键列，列上的数据都是唯一的</p>
<p>在这种情况下，选取基数（SC（A,R））要么是1（存在且只存在一个），要么是0（不存在）</p>
<img src="logical costs_01.png" style="zoom:150%;">

<br>

<br>

<p><strong>情况二</strong></p>
<p>但如果是范围的选取，比如说要选取某一列中&lt;1000的数据，或是多谓词选取，那么这个时候就无法用SC（A,R）进行衡量</p>
<p>由此需要引入<strong>选择率</strong>的新概念</p>
<img src="logical costs_02.png" style="zoom:150%;">

<br>

<br>

<br>

<h1 id="Complex-predicates"><a href="#Complex-predicates" class="headerlink" title="Complex predicates"></a>Complex predicates</h1><p>针对复合谓词的选择，提出新的概念：选择率</p>
<p><strong>选择率</strong>，对于当前的谓词，在总数据中能够选取出多少个数据，这个概率就是选择率</p>
<p>然后可以根据每个谓词的选择率，计算当前这种方案下总体的选择率</p>
<br>

<p>以下的例子都假设总共有五个数据，分别是0、1、2、3、4</p>
<p>并且，都假设数据是均匀分布的</p>
<br>

<br>

<h2 id="Equality-predicates"><a href="#Equality-predicates" class="headerlink" title="Equality predicates"></a>Equality predicates</h2><p>针对相等谓词，此时的计算公式是SC（P）/NR</p>
<ul>
<li>针对当前给定的谓词组合P，在当前数据表中平均能够找到SC（P）个</li>
<li>而总共有NR个数据，因此相等谓词的选择率便是SC（P）/NR</li>
</ul>
<img src="equality predicate.png" style="zoom:150%;">

<br>

<br>

<h2 id="Range-predicates"><a href="#Range-predicates" class="headerlink" title="Range predicates"></a>Range predicates</h2><p>范围谓词的查找</p>
<p>PS：下图中Amax是指当前列数据中的最大值，Amin是当前列数据中的最小值</p>
<img src="range predicate.png" style="zoom:150%;">

<br>

<br>

<h2 id="Negation-query"><a href="#Negation-query" class="headerlink" title="Negation query"></a>Negation query</h2><p>不等于谓词的查询</p>
<img src="negation query.png" style="zoom:150%;">

<br>

<br>

<h2 id="Conjunction"><a href="#Conjunction" class="headerlink" title="Conjunction"></a>Conjunction</h2><p>这里，可以将数据的选择率和概率作为替换</p>
<p>因此。针对多谓词并联（<strong>求并集</strong>）的复合查询，就可以用概率的相乘获得选择率（因为二者的概率是互不干扰，独立的）</p>
<p>PS：使用这种计算方法的前提：两个查询谓词之间，是互不干扰，相互独立的</p>
<img src="conjunction.png" style="zoom:150%;">

<br>

<br>

<h2 id="Disjunction"><a href="#Disjunction" class="headerlink" title="Disjunction"></a>Disjunction</h2><p>而如果是要求谓词筛选后的并集，可以参考离散数学的做法</p>
<p>PS：使用这种计算方法的前提：两个查询谓词之间，是互不干扰，相互独立的</p>
<img src="disjunction.png" style="zoom:150%;">

<br>

<br>

<br>

<h1 id="Result-size-estimation-for-joins"><a href="#Result-size-estimation-for-joins" class="headerlink" title="Result size estimation for joins"></a>Result size estimation for joins</h1><p>前面说的主要是基于谓词的查询，而如果涉及到两个表的join，情况会更加麻烦</p>
<p>比如说，我们很难知道两个表join后得到的数据有多大</p>
<ul>
<li>因为可能没有（join后发现数据都不匹配）、可能很小、也可能很大、无法估计大小</li>
</ul>
<br>

<p>因此，为了研究这个问题，假设内表中所有的数据都能够和外表进行匹配</p>
<p>为了两个表join后得到的数据量是多少，给出以下的计算模型：</p>
<p>NR是指R表的数据量</p>
<p>NS/V（A,S）其实就是SC（A,S），即针对每个取值，平均能够给出多少个数据</p>
<p>二者相乘，就代表对于NR来说，每个数据都能在S表中匹配上，而每个匹配上的数据，在S表中有SC（A,S）条</p>
<p>二者相乘之后，得到的结果就是两表join后的总结果的数量</p>
<br>

<p>而，因为join是符合交换律的，所以可以交换两边表的位置，因此在选取最终在选取结果的时候</p>
<p>往往是选择总开销较小的那个，也就是被除数较大的那个</p>
<img src="result size estimation for joins.png" style="zoom:150%;">

<br>

<br>

<br>

<h1 id="Selection-cardinality"><a href="#Selection-cardinality" class="headerlink" title="Selection cardinality"></a>Selection cardinality</h1><p>此前的推断过程，都是基于以下假设进行推断的：</p>
<br>

<h2 id="Assumption-01-uniform-data"><a href="#Assumption-01-uniform-data" class="headerlink" title="Assumption 01:uniform data"></a>Assumption 01:uniform data</h2><p>假设数据的分布都是<strong>均匀</strong>的</p>
<br>

<br>

<h2 id="Assumption-02-independent-predicates"><a href="#Assumption-02-independent-predicates" class="headerlink" title="Assumption 02:independent predicates"></a>Assumption 02:independent predicates</h2><p>假设在查询的过程中，每个谓词的查询之间，是<strong>相互独立</strong>的</p>
<ul>
<li>因此此前在并联谓词查询的时候，可以简单的用概率相乘得到结果</li>
</ul>
<br>

<br>

<h2 id="Assumption-03-inclusion-principle"><a href="#Assumption-03-inclusion-principle" class="headerlink" title="Assumption 03:inclusion principle"></a>Assumption 03:inclusion principle</h2><p>此前在join中的假设，假设A表中的每个数据都能够在B表中找到</p>
<br>

<br>

<br>

<h1 id="Correlated-attributes"><a href="#Correlated-attributes" class="headerlink" title="Correlated attributes"></a>Correlated attributes</h1><p>实际上，此前做出的很多分析都是基于上述三个假设</p>
<p>而如果没有三个假设，在估算代价上，就会有很多出入</p>
<br>

<img src="correlated attributes.png" style="zoom:150%;">

<p>比如这里，针对makes和models两条列，希望找到make=“honda”和model=“accord”的数据</p>
<p>如果基于此前的三个假设，那么1/10 * 1/100 = 0.001即答案</p>
<p>而只要稍微对数据加以了解，就会发现，model=“accord”的，就只能是make=“honda”的</p>
<p>也就是说这二者，是一一对应的关系</p>
<p>那么实际上的概率应该就是1/100 = 0.01</p>
<p>也就是此时的推断出现了问题（问题出在，两个谓词的查询之间，从数据的角度来说是不独立的）</p>
<br>

<br>

<p>因此，需要一些其他的方式，在不遵守上述三个假设的情况下，对数据进行预估</p>
<br>

<br>

<h2 id="Cost-estimations"><a href="#Cost-estimations" class="headerlink" title="Cost estimations"></a>Cost estimations</h2><p>基于数据不均衡的情况，需要新的方法或是指标，来衡量当数据不均衡的情况</p>
<br>

<p>最开始的思路，最简单粗暴的想法，在统计信息中，对于一列的数据，记录不同种类的数据的具体情况</p>
<img src="non-uniform approximation.png" style="zoom:150%;">

<br>

<p>但是，这种方法的问题是，可能会花费大量的空间来存储数据</p>
<p>因此需要对统计信息的存储进行优化，即用<strong>直方图</strong>来存储数据信息</p>
<br>

<br>

<h3 id="Equi-width-histogram"><a href="#Equi-width-histogram" class="headerlink" title="Equi-width histogram"></a>Equi-width histogram</h3><p><strong>等宽直方图</strong>，把相等宽度的值域打包成一块（比如说每三个坐标列打包在一起）</p>
<p>这样记录的就不是每一块的数据量，而是以bucket为单位的记录一个范围内的数据量</p>
<br>

<p>但是，这种等宽直方图的缺点就是，信息丢失率比较高</p>
<ul>
<li>比如说10、11、12这一块，当数据进行打包处理以后，可能总值很高，但11的位置其实只有少量的数据</li>
<li>而当使用这种方法的时候，很可能会误判在11的位置上有大量的数据</li>
<li>也就是说，在块内的数据范围会因此被掩盖，从而造成误差</li>
<li>因此需要引入<strong>等高直方图</strong></li>
</ul>
<img src="equi-width histogram.png" style="zoom:150%;">

<br>

<img src="equi-width histogram_01.png" style="zoom:150%;">

<br>

<br>

<h3 id="Equi-depth-histogram"><a href="#Equi-depth-histogram" class="headerlink" title="Equi-depth histogram"></a>Equi-depth histogram</h3><p>要求每个bucket里面的数据总量是相同的</p>
<ul>
<li>比如说要求每个bucket里面要有15个数据，那么第一个bucket可能包含1-5的数据，第二个bucket包含6-8的数据</li>
</ul>
<img src="equi-depth histogram.png" style="zoom: 150%;">

<br>

<p>一方面，可以节约内存；另一方面，可以解决数据缺失、数据误差的问题，从而提高精确度</p>
<img src="equi-depth histogram_01.png" style="zoom:150%;">



<br>

<br>

<h2 id="Sketches"><a href="#Sketches" class="headerlink" title="Sketches"></a>Sketches</h2><p>并不记录该数据是否存在，而是从概率的角度来估计该数据是否出现以及出现的数量</p>
<ul>
<li>即，从概率的角度来分析数据出现的数量以及概率</li>
</ul>
<p>主要有以下两个方法：</p>
<img src="sketches.png" style="zoom:150%;">

<p>PS：Redis使用的是hyperloglog（记录当前数据的hash值中第一个1的位置，通过这种方式来记录数据在数据表中有多少个）</p>
<br>

<br>

<h2 id="Sampling"><a href="#Sampling" class="headerlink" title="Sampling"></a>Sampling</h2><p>另一种思路：<strong>采样</strong></p>
<p>主要思路就是，先从原有的数据表中采样一部分数据出来（简称为小标），然后将选出来的执行计划在这个小表里面执行一遍</p>
<p>从而推断该执行计划，在原有的大表里面可能会执行多久</p>
<p>优点：是基于真实的数据进行估计的，不会有太大偏差</p>
<img src="sampling.png" style="zoom:150%;">

<br>

<p>缺点：</p>
<ul>
<li>不光要维护原有的数据表，还要额外的空间来维护小表</li>
<li>如果采样得到的数据被删除了，那么小表还需要维护数据</li>
<li>同一条SQL需要在大表和小表上同时执行，浪费资源</li>
</ul>
<br>

<br>

<h2 id="Observation"><a href="#Observation" class="headerlink" title="Observation"></a>Observation</h2><p>有了直方图，概率统计以及采样估算等方法，便可以轻松的估计数据的分布，从而了解谓词的实际代价消耗</p>
<p>而在了解了执行计划的具体代价之后，那么就需要列举不同的执行计划，估算不同执行计划的消耗，从而选出最优的方案</p>
<br>

<br>

<br>

<h1 id="Query-optimization"><a href="#Query-optimization" class="headerlink" title="Query optimization"></a>Query optimization</h1><p>对于一些只涉及一个表的查询，只需要基于规则的启发手段便可以实现</p>
<p>而针对多表查询，涉及查询循环的嵌套，是基于规则的优化器无法实现的</p>
<br>

<br>

<h2 id="Single-relation-query-planning"><a href="#Single-relation-query-planning" class="headerlink" title="Single-relation query planning"></a>Single-relation query planning</h2><p>针对单表的查询，可以直接根据基于规则的去选取最优的方案</p>
<p>比如说数据表的扫描，是选择顺序的读取数据页，还是二分查找，还是走索引（可以直接写一些规则，有索引走索引，没索引就二分）</p>
<p>这种简单的启发式的方案，对于大多数的OLTP的业务，都是比较适用的</p>
<ul>
<li>在单表的查询中，可以无视基于代价开销的优化，有索引就走索引就行了</li>
</ul>
<br>

<br>

<h2 id="OLTP-query-planning"><a href="#OLTP-query-planning" class="headerlink" title="OLTP query planning"></a>OLTP query planning</h2><p>在OLTP的查询优化中：</p>
<ul>
<li>使用启发式的手段，选择一个最佳的索引就好了</li>
<li>在join的操作过程中，往往只需要从A表中获取少量数据，然后把数据连接到B表中就可以了</li>
</ul>
<img src="OLTP query planning.png" style="zoom:150%;">

<br>

<br>

<h2 id="Multi-relation-query-planning"><a href="#Multi-relation-query-planning" class="headerlink" title="Multi-relation query planning"></a>Multi-relation query planning</h2><p>多表连表查询</p>
<ul>
<li>join是符合交换律和结合律的，因此如果有多个表进行join，那么就会有很多种不同的执行计划</li>
<li>也就是有很多的计划排列组合，那么就需要对其进行剪枝</li>
</ul>
<br>

<p>此前的System R只研究left-deep tree，即只研究左深树</p>
<ul>
<li>join的左子树可以是表，也可以是join</li>
<li>但，join的右子树必须是一个表</li>
</ul>
<p>并且，这种左深树还有优点，能够很好的适应执行模型中的火山模型</p>
<ul>
<li>A表和B表join完了以后，可以向上吐出一条数据，这条数据再和C表进行join，又可以向上吐出一条数据（而其他不是左深树的情况，则需要用额外的空间存储中间结果）</li>
<li>也就是可以将模型做成流式模型，极大的降低结果集的大小</li>
</ul>
<img src="left-deepth tree.png" style="zoom:150%;">

<br>

<br>

<p>然后，需要做一些计划列举的方式：</p>
<p>比如说通过排列组合，比较不同的左深树的方案</p>
<p>或者说，比较不同的算子实现方式（hash join，nested loop join等）</p>
<p>再或者说读取数据的方式，比如说是全表扫描，还是索引扫描</p>
<p>而，如何列举出这些方案的优劣，一般使用的是动态规划的算法来实现的</p>
<img src="multi-relation query planning.png" style="zoom:150%;">

<br>

<br>

<h3 id="Dynamic-programming"><a href="#Dynamic-programming" class="headerlink" title="Dynamic programming"></a>Dynamic programming</h3><p>在join中，不同的join方案，对应的开销是不一样的</p>
<p>如果需要找到最佳的方案，常用的方法便是动态规划算法</p>
<br>

<p>比如这里有两种不同的join方案，而每个方案，又分为hash join和sortmerge join两种方法</p>
<p>如果使用动态规划算法，那么就需要两种方法都走一遍，最后得到的结果进行比较</p>
<p>而在每种方法内部，每次都是“贪心算法”，取最小开销的那个方法</p>
<img src="dynamic programming_01.png" style="zoom:150%;">

<img src="dynamic programming_02.png" style="zoom:150%;">

<img src="dynamic programming_03.png" style="zoom:150%;">

<br>

<br>

<br>

<h2 id="Candidate-plan-example"><a href="#Candidate-plan-example" class="headerlink" title="Candidate plan example"></a>Candidate plan example</h2><p>举例说明如何对不同的执行计划进行剪枝比较</p>
<h3 id="Step-1-Enumerate-relation-orderings"><a href="#Step-1-Enumerate-relation-orderings" class="headerlink" title="Step 1: Enumerate relation orderings"></a>Step 1: Enumerate relation orderings</h3><p>排列组合出多个不同的左深树</p>
<img src="candidate plans_01.png" style="zoom:150%;">

<br>

<h3 id="Step-2-Enumerate-join-algorithm-choices"><a href="#Step-2-Enumerate-join-algorithm-choices" class="headerlink" title="Step 2: Enumerate join algorithm choices"></a>Step 2: Enumerate join algorithm choices</h3><p>列举算子join不同的实现方案</p>
<img src="candidate plans_02.png" style="zoom:150%;">

<br>

<h3 id="Step-3-Enumerate-access-method-choices"><a href="#Step-3-Enumerate-access-method-choices" class="headerlink" title="Step 3: Enumerate access method choices"></a>Step 3: Enumerate access method choices</h3><p>再列举不同的读表方式（顺序读表还是索引读表）</p>
<img src="candidate plans_03.png" style="zoom:150%;">

<br>

<p>最后，再列举所有方案的开销，选出开销最小的方案</p>
<br>

<br>

<h2 id="Postgres-optimizer"><a href="#Postgres-optimizer" class="headerlink" title="Postgres optimizer"></a>Postgres optimizer</h2><p>在PG里面的优化是如何实现的：</p>
<ul>
<li>不仅有左深树，还有右深树，以及二者混合的类型</li>
<li>在评估方案的好坏上有两种实现方法：动态规划（如果连表的数量小于12就用DP）和基因遗传算法（如果连表的数量大于12就用GEQO）</li>
</ul>
<br>

<br>

<p>PG中的遗传算法的主要思路：</p>
<ul>
<li><p>先预设几个组合方案</p>
</li>
<li><p>删除此时效果最差的方案</p>
</li>
<li><p>然后将当前最好的方案分裂（变异）出一个新的方案（繁衍）</p>
</li>
<li><p>接着不断地轮询上面的两个步骤，直到轮询次数达到上限</p>
</li>
</ul>
<img src="postgres genetic optimizer.png" style="zoom:150%;">

<br>

<br>

<br>

<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>在看了那么多的基于开销的优化模型，一个非常重要的思路便是：尽早的将数据过滤</p>
<ul>
<li>数据过滤的越早，后续在算子之间传输的数据就越少，开销也就越少</li>
</ul>
<br>

<p>一些选择率的估计指标</p>
<ul>
<li>数据在均匀的情况下</li>
<li>每个查询谓词相互独立的情况下</li>
<li>join存在结果的情况下</li>
<li>如果数据不均匀，就需要直方图来解决</li>
<li>有两个表在数据内容上是高度相关的，那么就有一些数据库可以将这两个表关联起来，在计算它们的统计信息</li>
</ul>
<br>

<p>动态规划依然是，在做join操作中比较不同join花费时，选取最优策略的最佳手段</p>

            </div>
            <hr />

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<!-- <div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div> -->
<!-- 注释了上面的代码，就可以关闭文章下面的分享功能 -->

<script src="/libs/share/js/social-share.min.js"></script>

            


        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/02/12/cmu-15-445-08-index-concurrency/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/3.jpg" class="responsive-img" alt="CMU 15-445 08-Index Concurrency">
                        
                        <span class="card-title">CMU 15-445 08-Index Concurrency</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Observation前面的操作中，都假设只有一个线程去操作数据结构，但实际操作中是有多个线程同时操作数据库的
因此需要研究多线程如何安全的执行查询
并且在实现线程安全的同时，也要注意如何优化磁盘IO


存在一些只支持单线程的数据库（比如
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2023-02-12
                        </span>
                        <span class="publish-author">
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Database/" target="_blank">
                        <span class="chip bg-color">Database</span>
                    </a>
                    
                    <a href="/tags/CMU-15-445/" target="_blank">
                        <span class="chip bg-color">CMU 15-445</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/01/19/cmu-15-445-13-query-planning-optimization-part-i/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="CMU 15-445 13-Query Planning Optimization Part I">
                        
                        <span class="card-title">CMU 15-445 13-Query Planning Optimization Part I</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Query optimization为什么会有优化器的存在？

SQL是声明式的，它只说明了需要的数据（答案）是什么，但没有说明要以什么方式去获取数据

因此DBMS可以对语句进行优化，从而以最小的成本获取相同的数据

因此有了众多SQL优
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2023-01-19
                            </span>
                        <span class="publish-author">
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Database/" target="_blank">
                        <span class="chip bg-color">Database</span>
                    </a>
                    
                    <a href="/tags/CMU-15-445/" target="_blank">
                        <span class="chip bg-color">CMU 15-445</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; 2022-2025 dancsmshenry. 版权所有

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">120.3k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/dancsmshenry" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:dancsmshenry@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="https://zhihu.com/people/ai-ni-de-dian-zhen-shi-tai-hao-la" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-inverse">知</i>
    </a>


<!-- 




    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
 --></div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 80000;
        var uvcountOffset = 20000;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据
                clearInterval(int);
            }
        }
    });
</script>

<!-- <script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2017, 09, 11, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script> -->

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->



    

    

    <!-- 雪花特效 -->
    

</body>

</html>