<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CMU 15-445 14-Query Planning Optimization Part II</title>
      <link href="/2023/01/19/cmu-15-445-14-query-planning-optimization-part-ii/"/>
      <url>/2023/01/19/cmu-15-445-14-query-planning-optimization-part-ii/</url>
      
        <content type="html"><![CDATA[<h1 id="Backround"><a href="#Backround" class="headerlink" title="Backround"></a>Backround</h1><p>上节课说的是基于规则的优化器，而本节课要说的就是<strong>基于代价模型的优化器</strong></p><p>基于代价模型，估计每个计划的好坏</p><p>然后从众多执行计划中，选取一个性价比最高的执行计划</p><br><br><br><h1 id="Cost-model-components"><a href="#Cost-model-components" class="headerlink" title="Cost model components"></a>Cost model components</h1><p>代价估算的三个方向：</p><br><h2 id="Choice-1：Physical-costs"><a href="#Choice-1：Physical-costs" class="headerlink" title="Choice 1：Physical costs"></a>Choice 1：Physical costs</h2><p>物理代价（例如：需要多少CPU的计算，多少次IO，多少次miss cache，读取内存的开销，预取数据的开销）</p><p>极度依赖于硬件的性能（更换硬件环境，估算的代价标准都会有变动）</p><p>这种估值方案经常出现在数据库一体机上（例如：Oracle，因为硬件是不变的）</p><p>或者SQL Server上，主要是Windows对硬件的性能有较深的把控</p><p>一般是商用的会做的比较细，开源的一般不会</p><br><br><h2 id="Choice-2：Logical-costs"><a href="#Choice-2：Logical-costs" class="headerlink" title="Choice 2：Logical costs"></a>Choice 2：Logical costs</h2><p>逻辑开销，估算每个算子的开销</p><p>开销的计算和每个算子之间是独立的</p><p>需要数据的统计信息（比如分布之类的），以便知道算子处理多少数据，从而估计开销</p><br><br><h2 id="Choice-3：Algorithmic-costs"><a href="#Choice-3：Algorithmic-costs" class="headerlink" title="Choice 3：Algorithmic costs"></a>Choice 3：Algorithmic costs</h2><p>比较细的估计算子的开销，从算法的层次去估计开销</p><p>例如：join，具体分为几个步骤、每个步骤的时间复杂度是多少</p><br><br><br><h1 id="Statistics"><a href="#Statistics" class="headerlink" title="Statistics"></a>Statistics</h1><p>而上述的三个方面，则非常依赖于DBMS中数据的<strong>统计信息</strong></p><p>因为针对不同的算子，只有知道该算子需要处理多少条数据，才能够准确的算出它的开销是多少</p><br><p>不同数据库更新其统计信息的方法，是不同的：</p><img src="\medias\14-Query-Planning-Optimization-Part-II\statistics.png" style="zoom:150%;"><br><br><h2 id="NR，V（A-R），SC（A-R）"><a href="#NR，V（A-R），SC（A-R）" class="headerlink" title="NR，V（A,R），SC（A,R）"></a>N<sub>R</sub>，V（A,R），SC（A,R）</h2><p>R：数据表的表名</p><p>A：数据表的某一列的列名</p><p>N<sub>R</sub>：当前的数据表中有多少条数据</p><p>V（A,R）：在当前数据表R的某一列A中，有多少个不同类型的值（比如性别一列，就只有男或女，这两种值）</p><p>SC（A,R）（全称：selection cardinality）：对于当前的选取方式，选取的基数是多少</p><ul><li><p>计算公式：N<sub>R</sub>&#x2F;V（A,R）（计算的前提：是数据为平均、均匀分布的）</p></li><li><p>在当前的选取方法中，平均每次选取能够得到多少个值</p></li><li><p>对于这一列每一个单独的值，如果选取这个值，平均每次能获取到多少个值</p></li><li><p>比如在性别一列中，总共有50个男性和50个女性，那么此时选取出男性的基数就是50个</p></li></ul><br><br><h2 id="Logical-costs"><a href="#Logical-costs" class="headerlink" title="Logical costs"></a>Logical costs</h2><p>基于以下几种不同的情况，来分析SC（A,R）</p><br><p><strong>情况一</strong></p><p>针对数据表中的某一主键列，列上的数据都是唯一的</p><p>在这种情况下，选取基数（SC（A,R））要么是1（存在且只存在一个），要么是0（不存在）</p><img src="\medias\14-Query-Planning-Optimization-Part-II\logical costs_01.png" style="zoom:150%;"><br><br><p><strong>情况二</strong></p><p>但如果是范围的选取，比如说要选取某一列中&lt;1000的数据，或是多谓词选取，那么这个时候就无法用SC（A,R）进行衡量</p><p>由此需要引入<strong>选择率</strong>的新概念</p><img src="\medias\14-Query-Planning-Optimization-Part-II\logical costs_02.png" style="zoom:150%;"><br><br><br><h1 id="Complex-predicates"><a href="#Complex-predicates" class="headerlink" title="Complex predicates"></a>Complex predicates</h1><p>针对复合谓词的选择，提出新的概念：选择率</p><p><strong>选择率</strong>，对于当前的谓词，在总数据中能够选取出多少个数据，这个概率就是选择率</p><p>然后可以根据每个谓词的选择率，计算当前这种方案下总体的选择率</p><br><p>以下的例子都假设总共有五个数据，分别是0、1、2、3、4</p><p>并且，都假设数据是均匀分布的</p><br><br><h2 id="Equality-predicates"><a href="#Equality-predicates" class="headerlink" title="Equality predicates"></a>Equality predicates</h2><p>针对相等谓词，此时的计算公式是SC（P）&#x2F;N<sub>R</sub></p><ul><li>针对当前给定的谓词组合P，在当前数据表中平均能够找到SC（P）个</li><li>而总共有N<sub>R</sub>个数据，因此相等谓词的选择率便是SC（P）&#x2F;N<sub>R</sub></li></ul><img src="\medias\14-Query-Planning-Optimization-Part-II\equality predicate.png" style="zoom:150%;"><br><br><h2 id="Range-predicates"><a href="#Range-predicates" class="headerlink" title="Range predicates"></a>Range predicates</h2><p>范围谓词的查找</p><p>PS：下图中A<sub>max</sub>是指当前列数据中的最大值，A<sub>min</sub>是当前列数据中的最小值</p><img src="\medias\14-Query-Planning-Optimization-Part-II\range predicate.png" style="zoom:150%;"><br><br><h2 id="Negation-query"><a href="#Negation-query" class="headerlink" title="Negation query"></a>Negation query</h2><p>不等于谓词的查询</p><img src="\medias\14-Query-Planning-Optimization-Part-II\negation query.png" style="zoom:150%;"><br><br><h2 id="Conjunction"><a href="#Conjunction" class="headerlink" title="Conjunction"></a>Conjunction</h2><p>这里，可以将数据的选择率和概率作为替换</p><p>因此。针对多谓词并联（<strong>求并集</strong>）的复合查询，就可以用概率的相乘获得选择率（因为二者的概率是互不干扰，独立的）</p><p>PS：使用这种计算方法的前提：两个查询谓词之间，是互不干扰，相互独立的</p><img src="\medias\14-Query-Planning-Optimization-Part-II\conjunction.png" style="zoom:150%;"><br><br><h2 id="Disjunction"><a href="#Disjunction" class="headerlink" title="Disjunction"></a>Disjunction</h2><p>而如果是要求谓词筛选后的并集，可以参考离散数学的做法</p><p>PS：使用这种计算方法的前提：两个查询谓词之间，是互不干扰，相互独立的</p><img src="\medias\14-Query-Planning-Optimization-Part-II\disjunction.png" style="zoom:150%;"><br><br><br><h1 id="Result-size-estimation-for-joins"><a href="#Result-size-estimation-for-joins" class="headerlink" title="Result size estimation for joins"></a>Result size estimation for joins</h1><p>前面说的主要是基于谓词的查询，而如果涉及到两个表的join，情况会更加麻烦</p><p>比如说，我们很难知道两个表join后得到的数据有多大</p><ul><li>因为可能没有（join后发现数据都不匹配）、可能很小、也可能很大、无法估计大小</li></ul><br><p>因此，为了研究这个问题，假设内表中所有的数据都能够和外表进行匹配</p><p>为了两个表join后得到的数据量是多少，给出以下的计算模型：</p><p>N<sub>R</sub>是指R表的数据量</p><p>N<sub>S</sub>&#x2F;V（A,S）其实就是SC（A,S），即针对每个取值，平均能够给出多少个数据</p><p>二者相乘，就代表对于N<sub>R</sub>来说，每个数据都能在S表中匹配上，而每个匹配上的数据，在S表中有SC（A,S）条</p><p>二者相乘之后，得到的结果就是两表join后的总结果的数量</p><br><p>而，因为join是符合交换律的，所以可以交换两边表的位置，因此在选取最终在选取结果的时候</p><p>往往是选择总开销较小的那个，也就是被除数较大的那个</p><img src="\medias\14-Query-Planning-Optimization-Part-II\result size estimation for joins.png" style="zoom:150%;"><br><br><br><h1 id="Selection-cardinality"><a href="#Selection-cardinality" class="headerlink" title="Selection cardinality"></a>Selection cardinality</h1><p>此前的推断过程，都是基于以下假设进行推断的：</p><br><h2 id="Assumption-01-uniform-data"><a href="#Assumption-01-uniform-data" class="headerlink" title="Assumption 01:uniform data"></a>Assumption 01:uniform data</h2><p>假设数据的分布都是<strong>均匀</strong>的</p><br><br><h2 id="Assumption-02-independent-predicates"><a href="#Assumption-02-independent-predicates" class="headerlink" title="Assumption 02:independent predicates"></a>Assumption 02:independent predicates</h2><p>假设在查询的过程中，每个谓词的查询之间，是<strong>相互独立</strong>的</p><ul><li>因此此前在并联谓词查询的时候，可以简单的用概率相乘得到结果</li></ul><br><br><h2 id="Assumption-03-inclusion-principle"><a href="#Assumption-03-inclusion-principle" class="headerlink" title="Assumption 03:inclusion principle"></a>Assumption 03:inclusion principle</h2><p>此前在join中的假设，假设A表中的每个数据都能够在B表中找到</p><br><br><br><h1 id="Correlated-attributes"><a href="#Correlated-attributes" class="headerlink" title="Correlated attributes"></a>Correlated attributes</h1><p>实际上，此前做出的很多分析都是基于上述三个假设</p><p>而如果没有三个假设，在估算代价上，就会有很多出入</p><br><img src="\medias\14-Query-Planning-Optimization-Part-II\correlated attributes.png" style="zoom:150%;"><p>比如这里，针对makes和models两条列，希望找到make&#x3D;“honda”和model&#x3D;“accord”的数据</p><p>如果基于此前的三个假设，那么1&#x2F;10 * 1&#x2F;100 &#x3D; 0.001即答案</p><p>而只要稍微对数据加以了解，就会发现，model&#x3D;“accord”的，就只能是make&#x3D;“honda”的</p><p>也就是说这二者，是一一对应的关系</p><p>那么实际上的概率应该就是1&#x2F;100 &#x3D; 0.01</p><p>也就是此时的推断出现了问题（问题出在，两个谓词的查询之间，从数据的角度来说是不独立的）</p><br><br><p>因此，需要一些其他的方式，在不遵守上述三个假设的情况下，对数据进行预估</p><br><br><h2 id="Cost-estimations"><a href="#Cost-estimations" class="headerlink" title="Cost estimations"></a>Cost estimations</h2><p>基于数据不均衡的情况，需要新的方法或是指标，来衡量当数据不均衡的情况</p><br><p>最开始的思路，最简单粗暴的想法，在统计信息中，对于一列的数据，记录不同种类的数据的具体情况</p><img src="\medias\14-Query-Planning-Optimization-Part-II\non-uniform approximation.png" style="zoom:150%;"><br><p>但是，这种方法的问题是，可能会花费大量的空间来存储数据</p><p>因此需要对统计信息的存储进行优化，即用<strong>直方图</strong>来存储数据信息</p><br><br><h3 id="Equi-width-histogram"><a href="#Equi-width-histogram" class="headerlink" title="Equi-width histogram"></a>Equi-width histogram</h3><p><strong>等宽直方图</strong>，把相等宽度的值域打包成一块（比如说每三个坐标列打包在一起）</p><p>这样记录的就不是每一块的数据量，而是以bucket为单位的记录一个范围内的数据量</p><br><p>但是，这种等宽直方图的缺点就是，信息丢失率比较高</p><ul><li>比如说10、11、12这一块，当数据进行打包处理以后，可能总值很高，但11的位置其实只有少量的数据</li><li>而当使用这种方法的时候，很可能会误判在11的位置上有大量的数据</li><li>也就是说，在块内的数据范围会因此被掩盖，从而造成误差</li><li>因此需要引入<strong>等高直方图</strong></li></ul><img src="\medias\14-Query-Planning-Optimization-Part-II\equi-width histogram.png" style="zoom:150%;"><br><img src="\medias\14-Query-Planning-Optimization-Part-II\equi-width histogram_01.png" style="zoom:150%;"><br><br><h3 id="Equi-depth-histogram"><a href="#Equi-depth-histogram" class="headerlink" title="Equi-depth histogram"></a>Equi-depth histogram</h3><p>要求每个bucket里面的数据总量是相同的</p><ul><li>比如说要求每个bucket里面要有15个数据，那么第一个bucket可能包含1-5的数据，第二个bucket包含6-8的数据</li></ul><img src="\medias\14-Query-Planning-Optimization-Part-II\equi-depth histogram.png" style="zoom: 150%;"><br><p>一方面，可以节约内存；另一方面，可以解决数据缺失、数据误差的问题，从而提高精确度</p><img src="\medias\14-Query-Planning-Optimization-Part-II\equi-depth histogram_01.png" style="zoom:150%;"><br><br><h2 id="Sketches"><a href="#Sketches" class="headerlink" title="Sketches"></a>Sketches</h2><p>并不记录该数据是否存在，而是从概率的角度来估计该数据是否出现以及出现的数量</p><ul><li>即，从概率的角度来分析数据出现的数量以及概率</li></ul><p>主要有以下两个方法：</p><img src="\medias\14-Query-Planning-Optimization-Part-II\sketches.png" style="zoom:150%;"><p>PS：Redis使用的是hyperloglog（记录当前数据的hash值中第一个1的位置，通过这种方式来记录数据在数据表中有多少个）</p><br><br><h2 id="Sampling"><a href="#Sampling" class="headerlink" title="Sampling"></a>Sampling</h2><p>另一种思路：<strong>采样</strong></p><p>主要思路就是，先从原有的数据表中采样一部分数据出来（简称为小标），然后将选出来的执行计划在这个小表里面执行一遍</p><p>从而推断该执行计划，在原有的大表里面可能会执行多久</p><p>优点：是基于真实的数据进行估计的，不会有太大偏差</p><img src="\medias\14-Query-Planning-Optimization-Part-II\sampling.png" style="zoom:150%;"><br><p>缺点：</p><ul><li>不光要维护原有的数据表，还要额外的空间来维护小表</li><li>如果采样得到的数据被删除了，那么小表还需要维护数据</li><li>同一条SQL需要在大表和小表上同时执行，浪费资源</li></ul><br><br><h2 id="Observation"><a href="#Observation" class="headerlink" title="Observation"></a>Observation</h2><p>有了直方图，概率统计以及采样估算等方法，便可以轻松的估计数据的分布，从而了解谓词的实际代价消耗</p><p>而在了解了执行计划的具体代价之后，那么就需要列举不同的执行计划，估算不同执行计划的消耗，从而选出最优的方案</p><br><br><br><h1 id="Query-optimization"><a href="#Query-optimization" class="headerlink" title="Query optimization"></a>Query optimization</h1><p>对于一些只涉及一个表的查询，只需要基于规则的启发手段便可以实现</p><p>而针对多表查询，涉及查询循环的嵌套，是基于规则的优化器无法实现的</p><br><br><h2 id="Single-relation-query-planning"><a href="#Single-relation-query-planning" class="headerlink" title="Single-relation query planning"></a>Single-relation query planning</h2><p>针对单表的查询，可以直接根据基于规则的去选取最优的方案</p><p>比如说数据表的扫描，是选择顺序的读取数据页，还是二分查找，还是走索引（可以直接写一些规则，有索引走索引，没索引就二分）</p><p>这种简单的启发式的方案，对于大多数的OLTP的业务，都是比较适用的</p><ul><li>在单表的查询中，可以无视基于代价开销的优化，有索引就走索引就行了</li></ul><br><br><h2 id="OLTP-query-planning"><a href="#OLTP-query-planning" class="headerlink" title="OLTP query planning"></a>OLTP query planning</h2><p>在OLTP的查询优化中：</p><ul><li>使用启发式的手段，选择一个最佳的索引就好了</li><li>在join的操作过程中，往往只需要从A表中获取少量数据，然后把数据连接到B表中就可以了</li></ul><img src="\medias\14-Query-Planning-Optimization-Part-II\OLTP query planning.png" style="zoom:150%;"><br><br><h2 id="Multi-relation-query-planning"><a href="#Multi-relation-query-planning" class="headerlink" title="Multi-relation query planning"></a>Multi-relation query planning</h2><p>多表连表查询</p><ul><li>join是符合交换律和结合律的，因此如果有多个表进行join，那么就会有很多种不同的执行计划</li><li>也就是有很多的计划排列组合，那么就需要对其进行剪枝</li></ul><br><p>此前的System R只研究left-deep tree，即只研究左深树</p><ul><li>join的左子树可以是表，也可以是join</li><li>但，join的右子树必须是一个表</li></ul><p>并且，这种左深树还有优点，能够很好的适应执行模型中的火山模型</p><ul><li>A表和B表join完了以后，可以向上吐出一条数据，这条数据再和C表进行join，又可以向上吐出一条数据（而其他不是左深树的情况，则需要用额外的空间存储中间结果）</li><li>也就是可以将模型做成流式模型，极大的降低结果集的大小</li></ul><img src="\medias\14-Query-Planning-Optimization-Part-II\left-deepth tree.png" style="zoom:150%;"><br><br><p>然后，需要做一些计划列举的方式：</p><p>比如说通过排列组合，比较不同的左深树的方案</p><p>或者说，比较不同的算子实现方式（hash join，nested loop join等）</p><p>再或者说读取数据的方式，比如说是全表扫描，还是索引扫描</p><p>而，如何列举出这些方案的优劣，一般使用的是动态规划的算法来实现的</p><img src="\medias\14-Query-Planning-Optimization-Part-II\multi-relation query planning.png" style="zoom:150%;"><br><br><h3 id="Dynamic-programming"><a href="#Dynamic-programming" class="headerlink" title="Dynamic programming"></a>Dynamic programming</h3><p>在join中，不同的join方案，对应的开销是不一样的</p><p>如果需要找到最佳的方案，常用的方法便是动态规划算法</p><br><p>比如这里有两种不同的join方案，而每个方案，又分为hash join和sortmerge join两种方法</p><p>如果使用动态规划算法，那么就需要两种方法都走一遍，最后得到的结果进行比较</p><p>而在每种方法内部，每次都是“贪心算法”，取最小开销的那个方法</p><img src="\medias\14-Query-Planning-Optimization-Part-II\dynamic programming_01.png" style="zoom:150%;"><img src="\medias\14-Query-Planning-Optimization-Part-II\dynamic programming_02.png" style="zoom:150%;"><img src="\medias\14-Query-Planning-Optimization-Part-II\dynamic programming_03.png" style="zoom:150%;"><br><br><br><h2 id="Candidate-plan-example"><a href="#Candidate-plan-example" class="headerlink" title="Candidate plan example"></a>Candidate plan example</h2><p>举例说明如何对不同的执行计划进行剪枝比较</p><h3 id="Step-1-Enumerate-relation-orderings"><a href="#Step-1-Enumerate-relation-orderings" class="headerlink" title="Step 1: Enumerate relation orderings"></a>Step 1: Enumerate relation orderings</h3><p>排列组合出多个不同的左深树</p><img src="\medias\14-Query-Planning-Optimization-Part-II\candidate plans_01.png" style="zoom:150%;"><br><h3 id="Step-2-Enumerate-join-algorithm-choices"><a href="#Step-2-Enumerate-join-algorithm-choices" class="headerlink" title="Step 2: Enumerate join algorithm choices"></a>Step 2: Enumerate join algorithm choices</h3><p>列举算子join不同的实现方案</p><img src="\medias\14-Query-Planning-Optimization-Part-II\candidate plans_02.png" style="zoom:150%;"><br><h3 id="Step-3-Enumerate-access-method-choices"><a href="#Step-3-Enumerate-access-method-choices" class="headerlink" title="Step 3: Enumerate access method choices"></a>Step 3: Enumerate access method choices</h3><p>再列举不同的读表方式（顺序读表还是索引读表）</p><img src="\medias\14-Query-Planning-Optimization-Part-II\candidate plans_03.png" style="zoom:150%;"><br><p>最后，再列举所有方案的开销，选出开销最小的方案</p><br><br><h2 id="Postgres-optimizer"><a href="#Postgres-optimizer" class="headerlink" title="Postgres optimizer"></a>Postgres optimizer</h2><p>在PG里面的优化是如何实现的：</p><ul><li>不仅有左深树，还有右深树，以及二者混合的类型</li><li>在评估方案的好坏上有两种实现方法：动态规划（如果连表的数量小于12就用DP）和基因遗传算法（如果连表的数量大于12就用GEQO）</li></ul><br><br><p>PG中的遗传算法的主要思路：</p><ul><li><p>先预设几个组合方案</p></li><li><p>删除此时效果最差的方案</p></li><li><p>然后将当前最好的方案分裂（变异）出一个新的方案（繁衍）</p></li><li><p>接着不断地轮询上面的两个步骤，直到轮询次数达到上限</p></li></ul><img src="\medias\14-Query-Planning-Optimization-Part-II\postgres genetic optimizer.png" style="zoom:150%;"><br><br><br><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>在看了那么多的基于开销的优化模型，一个非常重要的思路便是：尽早的将数据过滤</p><ul><li>数据过滤的越早，后续在算子之间传输的数据就越少，开销也就越少</li></ul><br><p>一些选择率的估计指标</p><ul><li>数据在均匀的情况下</li><li>每个查询谓词相互独立的情况下</li><li>join存在结果的情况下</li><li>如果数据不均匀，就需要直方图来解决</li><li>有两个表在数据内容上是高度相关的，那么就有一些数据库可以将这两个表关联起来，在计算它们的统计信息</li></ul><br><p>动态规划依然是，在做join操作中比较不同join花费时，选取最优策略的最佳手段</p>]]></content>
      
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> CMU 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 13-Query Planning Optimization Part I</title>
      <link href="/2023/01/19/cmu-15-445-13-query-planning-optimization-part-i/"/>
      <url>/2023/01/19/cmu-15-445-13-query-planning-optimization-part-i/</url>
      
        <content type="html"><![CDATA[<h1 id="Query-optimization"><a href="#Query-optimization" class="headerlink" title="Query optimization"></a>Query optimization</h1><p>为什么会有优化器的存在？</p><ul><li><p>SQL是声明式的，它只说明了需要的数据（答案）是什么，但没有说明要以什么方式去获取数据</p></li><li><p>因此DBMS可以对语句进行优化，从而以最小的成本获取相同的数据</p></li><li><p>因此有了众多SQL优化器</p></li></ul><br><br><h2 id="IBM-System-R"><a href="#IBM-System-R" class="headerlink" title="IBM System R"></a>IBM System R</h2><p>从IBM SYSTEM R，就开始了优化器的历程</p><br><p>一个争论：人为制定的执行计划和机器做出的执行计划，哪个效率会高？</p><p>因此DBMS在<strong>执行</strong>上，有以下两个流派：</p><ul><li>一个是SQL为代表的，机器对语句进行优化</li><li>另一个是类似flink（虽然有插件，可以直接写SQL），但是flink是要用户直接写具体语句的执行计划，流式处理系统</li></ul><br><p>而DBMS对SQL进行优化，又有以下两个方向：</p><br><br><h2 id="Heuristice-x2F-rules"><a href="#Heuristice-x2F-rules" class="headerlink" title="Heuristice&#x2F;rules"></a>Heuristice&#x2F;rules</h2><p>基于规则（启发式）的查询模型</p><p>基于一些规则或者变化的手段，用来优化用户SQL中比较低效的部分</p><ul><li>规定一些查询优化的trick，将语句等效的替换或变换，然后获取高效的性能</li></ul><p>重写SQL查询，去掉一些stupid或inefficient的查询</p><p>需要查询catalog（元数据），需要看一下数据库表行列的情况</p><ul><li>但是不需要数据的具体情况，即发现数据库有索引就直接走索引，不用关心数据的分布以及直方图等信息</li></ul><br><br><h2 id="Cost-based-search"><a href="#Cost-based-search" class="headerlink" title="Cost-based search"></a>Cost-based search</h2><p>基于代价的查询模型</p><p>需要构建代价模型，再判断不同的执行计划的开销是多少，从而选出最优的执行计划</p><p>因此，需要知道具体数据的分布（需要知道算子要处理多少数据，才能够知道代价是多少）</p><br><br><p>本节主要研究的是<strong>基于规则的查询模型</strong></p><br><br><br><h1 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h1><img src="\medias\13-Query-Planning-Optimization-Part-I\architecture overview.png" style="zoom:150%;"><br><br><h2 id="SQL-rewriter"><a href="#SQL-rewriter" class="headerlink" title="SQL rewriter"></a>SQL rewriter</h2><p>对SQL语句进行一些预处理，在SQL的文本级别上做一些简单的优化</p><br><br><h2 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h2><p>将SQL语句转化为抽象语法树（abstract syntax tree）</p><br><br><h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>语法树会涉及表的名称，列的名称；而这些数据和DBMS里面的名称一般是不一样的</p><ul><li>所以需要将SQL中数据表的id、列id，绑定（bind）到system catalog中数据表的id、列id</li><li>如果表或列不存在，就会报错</li></ul><br><br><h2 id="Tree-rewriter"><a href="#Tree-rewriter" class="headerlink" title="Tree rewriter"></a>Tree rewriter</h2><p>把上面的抽象语法树转化成一个优化器可以工作的最原始的逻辑结构（又名<strong>正则化</strong>）</p><p>生成一个最原始的查询逻辑计划（logical plan）</p><br><br><h2 id="Optimizer"><a href="#Optimizer" class="headerlink" title="Optimizer"></a>Optimizer</h2><p>接着生成optimizer（这是一个未优化的查询逻辑）</p><ul><li>如果是启发式优化的，ruled based search，也叫做基于规则的查询，会查询一些系统的源数据，对查询进行优化</li><li>如果是代价式优化的，cost model，不光会查询系统的原数据，还是查询代价模型（比如说DBMS规定的一些代价模型）</li></ul><br><p>最后会生成一个物理的查询计划physical plan，里面都是真正需要执行的算子</p><br><br><br><h1 id="Logical-vs-physical-phans"><a href="#Logical-vs-physical-phans" class="headerlink" title="Logical vs physical phans"></a>Logical vs physical phans</h1><p>逻辑计划：关系代数级别的（join）</p><p>物理计划：怎么执行这个join（比如说怎么执行join，是用hash join，还是nested loop join）</p><br><p>在优化器中，逻辑计划和物理计划的算子都是由对应关系的</p><p>物理计划会制定一个具体的执行方式，是走索引还是走扫描</p><ul><li>会根据具体的物理情况，决定使用哪些物理算子</li><li>物理算子和逻辑算子不一定是一对一的关系，一个逻辑算子可能会对应多个物理算子</li></ul><br><br><br><h1 id="Query-optimization-is-NP-hard"><a href="#Query-optimization-is-NP-hard" class="headerlink" title="Query optimization is NP-hard"></a>Query optimization is NP-hard</h1><p>优化器对查询的优化是一个很难的问题，以至于不知道是否有一个最优的结果存在，也就是NP问题</p><br><p>一种思路是，用Machine Learning对优化器进行优化，比如DB2就用了人工智能优化器</p><p>但是缺点是类似黑盒，即查询器的输出很难make sense，就人工智能也不知道为什么要选择这个方式</p><p>PS：近年又开始研究<del>火</del>起来了</p><br><p>而另一种思路是，辅助优化器对语句进行优化，即对于优化器给出的执行计划，提出建议</p><p>最后优化器自己综合做出决定</p><br><br><br><h1 id="Relational-algebra-equivalences"><a href="#Relational-algebra-equivalences" class="headerlink" title="Relational algebra equivalences"></a>Relational algebra equivalences</h1><p>关系代数的等价</p><ul><li>如果两个关系表达式是等价的话，就表明二者输出的结果集是一样的；反之也是一样的</li></ul><p>DBMS可以利用关系代数，从逻辑上判断两个执行计划是否是等价的，而不需要代价模型</p><p>同时，利用关系代数也可以实现SQL的重写</p><br><br><p>通过逻辑谓词的下推，实现了两个关系表达式的等效</p><img src="\medias\13-Query-Planning-Optimization-Part-I\predicate pushdown.png" style="zoom:150%;"><br><br><p>将谓词进行分割</p><img src="\medias\13-Query-Planning-Optimization-Part-I\relational algebra equivalences.png" style="zoom:150%;"><br><br><p>join的交换律</p><p>如果有n个表进行join，那么就有4^n种执行方法</p><img src="\medias\13-Query-Planning-Optimization-Part-I\join的交换律.png" style="zoom:150%;"><br><br><p>早晚物化的问题</p><ul><li><p>一方面，可以将不需要的数据舍弃掉，减少传输的数据量</p></li><li><p>另一方面，可以选择在join的时候就物化数据，或者最后再回表一次得到数据</p></li></ul><p>但是这对于一个列存的数据库来说是无用的，因为它始终是最后才物化的</p><br><br><br><h1 id="Logical-query-optimization"><a href="#Logical-query-optimization" class="headerlink" title="Logical query optimization"></a>Logical query optimization</h1><p>逻辑计划上的优化，需要先写一些规则，再让数据库去匹配（类似模式匹配）</p><br><p>缺点：无法比较计划和计划之间的好坏</p><ul><li><p>这种方法不能自适应的评价计划和计划之间的好坏</p></li><li><p>选择方法一而不选择方法二的原因只能是因为你给的规则是这样写的，因为它没有代价模型，不能自己去判断</p></li></ul><br><br><h2 id="Split-conjunctive-predicates"><a href="#Split-conjunctive-predicates" class="headerlink" title="Split conjunctive predicates"></a>Split conjunctive predicates</h2><p>将语句中的连接谓词分开</p><p>比如下图，将语句中用and连接的一串谓词分开</p><img src="\medias\13-Query-Planning-Optimization-Part-I\split conjunctive predicates.png" style="zoom:150%;"><br><br><h2 id="Predicate-pushdown"><a href="#Predicate-pushdown" class="headerlink" title="Predicate pushdown"></a>Predicate pushdown</h2><p>谓词下推，谓词的执行越接近读表越好（可以提前过滤掉大量的无用数据）</p><img src="\medias\13-Query-Planning-Optimization-Part-I\predicate pushdown_01.png" style="zoom:150%;"><br><br><h2 id="Replace-cartesian-products"><a href="#Replace-cartesian-products" class="headerlink" title="Replace cartesian products"></a>Replace cartesian products</h2><p>把笛卡尔积转换为join</p><p>两个表连表后（即笛卡尔积）再用条件判断，就相当于一个join了，所以就可以把笛卡尔积变为join</p><img src="\medias\13-Query-Planning-Optimization-Part-I\replace cartesian products with joins.png" style="zoom:150%;"><br><br><h2 id="Projection-pushdown"><a href="#Projection-pushdown" class="headerlink" title="Projection pushdown"></a>Projection pushdown</h2><p>投影下推，发现很多时候我们只需要部分列的数据，整行的记录没必要全部往上传，所以就只传递部分数据即可</p><img src="\medias\13-Query-Planning-Optimization-Part-I\projection pushdown.png" style="zoom:150%;"><br><br><br><h1 id="Nested-sub-queries"><a href="#Nested-sub-queries" class="headerlink" title="Nested sub-queries"></a>Nested sub-queries</h1><p>针对嵌套的子查询，有两个优化的方向：</p><ul><li>重写（Rewrite）：将里面和外面的查询重写成一个新的查询</li><li>解耦查询（Decompose）：不要让子查询一直阻塞在主查询里面（把它单独拿出来，提前执行）</li></ul><br><br><h2 id="Rewrite"><a href="#Rewrite" class="headerlink" title="Rewrite"></a>Rewrite</h2><p>发现可以用连表的方式来重写嵌套查询</p><p>比如下图，将两条查询SQL，优化为一条查询SQL</p><img src="\medias\13-Query-Planning-Optimization-Part-I\rewrite.png" style="zoom:150%;"><br><br><h2 id="Decompose"><a href="#Decompose" class="headerlink" title="Decompose"></a>Decompose</h2><p>可以预先执行一些查询语句，使得主查询不必一直阻塞在子查询上</p><ul><li>如果不预先处理这个子查询的话，每拿一条记录都要再执行一遍这个子查询（浪费资源）</li></ul><br><p>即，可以先把子查询做了，然后把结果放到单独的一个表里面（作为子查询的结果）</p><p>需要子查询语句的结果时，直接去里面读取即可</p><br><img src="\medias\13-Query-Planning-Optimization-Part-I\decompose.png" style="zoom:150%;"><p>比如上面的SQL，发现<code>SELECT MAX(S2.rating) FROM sailors S2</code>的结果是一个不变的量</p><p>因此可以先执行该子查询，得到并储存结果，方便后续读取</p><p>而不是每次读取到这条语句的时候，都重复执行</p><img src="\medias\13-Query-Planning-Optimization-Part-I\decomposing queries.png" style="zoom:150%;"><br><br><br><h1 id="Expression-rewriting"><a href="#Expression-rewriting" class="headerlink" title="Expression rewriting"></a>Expression rewriting</h1><p>对谓词表达式进行重写 ，让谓词本身变得更高效</p><p>可以给DBMS写入一些规则，然后让DBMS去SQL中查找符合规则的部分进行rewrite（类似模式匹配）</p><br><br><h2 id="Impossible-x2F-unnecessary-predicates"><a href="#Impossible-x2F-unnecessary-predicates" class="headerlink" title="Impossible&#x2F;unnecessary predicates"></a>Impossible&#x2F;unnecessary predicates</h2><p>对于一些比较绝对的逻辑，可以直接优化</p><p>比如下图，1必然是不等于0的，所以这里可以直接优化为false，输出空结果即可</p><img src="\medias\13-Query-Planning-Optimization-Part-I\impossible predicates.png" style="zoom:150%;"><br><br><h2 id="Join-elimination"><a href="#Join-elimination" class="headerlink" title="Join elimination"></a>Join elimination</h2><p>对于一些语句可以直接得到结果的，可以直接优化</p><p>比如下图，相当于自己和自己连表，然后查询的又是自己的全部数据</p><p>因此可以修改为为<code>SELECT * FROM A;</code></p><img src="\medias\13-Query-Planning-Optimization-Part-I\join elimination.png" style="zoom:150%;"><br><br><h2 id="Join-elimination-with-sub-query"><a href="#Join-elimination-with-sub-query" class="headerlink" title="Join elimination with sub-query"></a>Join elimination with sub-query</h2><p>发现当前查询以及子查询在联表查询时，连接的都是同一张表</p><img src="\medias\13-Query-Planning-Optimization-Part-I\join elimination with sub-query_01.png" style="zoom:150%;"><br><p>那么就可以改写为以下SQL</p><img src="\medias\13-Query-Planning-Optimization-Part-I\join elimination with sub-query_02.png" style="zoom:150%;"><br><br><h2 id="Merge-predicates"><a href="#Merge-predicates" class="headerlink" title="Merge predicates"></a>Merge predicates</h2><p>将谓词进行合并</p><img src="\medias\13-Query-Planning-Optimization-Part-I\merge predicate_01.png" style="zoom:150%;"><p>可以将谓词里面的数据范围进行合并</p><img src="\medias\13-Query-Planning-Optimization-Part-I\merge predicate_02.png" style="zoom:150%;"><br><br><br><h1 id="Cost-model"><a href="#Cost-model" class="headerlink" title="Cost model"></a>Cost model</h1><br><h2 id="Cost-based-query-planning"><a href="#Cost-based-query-planning" class="headerlink" title="Cost-based query planning"></a>Cost-based query planning</h2><p>此前讨论的都是基于规则的优化（启发式），而后续则需要讨论基于开销的优化</p><p>基于开销的优化，需要根据数据库数据的具体分布等情况</p><p>对执行计划的花费开销进行比对，从而选出一个当前最优的方案</p><br><p>但是，这里对执行计划开销的估计，换一个数据库（或是机器硬件）就不适用了</p><ul><li>比如说某个SQL的查询，在MySQL中执行是2W，在PG中执行是20W，这二者是没有任何比较性的</li><li>因为每个数据库对于查询复杂度的衡量，都是基于本身的体系衡量出来的，二者不能在不同的标准上进行比较</li></ul><br><p>PS：估算SQL执行的开销，和计划列举的步骤是分开的</p><img src="\medias\13-Query-Planning-Optimization-Part-I\query optimization.png" style="zoom: 150%;"><br><br><h2 id="Cost-model-components"><a href="#Cost-model-components" class="headerlink" title="Cost model components"></a>Cost model components</h2><p>代价估算的三个方向：</p><br><p><strong>Choice 1：Physical costs</strong></p><p>物理代价（例如：需要多少CPU的计算，多少次IO，多少次miss cache，读取内存的开销，预取数据的开销）</p><p>极度依赖于硬件的性能（换一个硬件环境，估算的代价都会有变动）</p><p>这种估值方案经常出现在数据库一体机上（例如：Oracle，因为硬件是不变的）</p><p>或者SQL Server上，主要是Windows对硬件的性能有较深的把控</p><p>一般是商用的会做的比较细，开源的一般不会</p><br><p><strong>Choice 2：Logical costs</strong></p><p>逻辑开销，估算每个算子的开销</p><p>开销的计算和每个算子之间是独立的</p><p>需要数据的统计信息（比如分布之类的），以便知道算子处理多少数据，从而估计开销</p><br><p><strong>Choice 3：Algorithmic costs</strong></p><p>比较细的估计算子的开销，从算法的层次去估计开销</p><p>例如：join，具体分为几个步骤、每个步骤的时间复杂度是多少</p><br><br><h2 id="Disk-based-dbms-cost-model"><a href="#Disk-based-dbms-cost-model" class="headerlink" title="Disk-based dbms cost model"></a>Disk-based dbms cost model</h2><p>因为目前主要研究的是基于磁盘的DBMS，所以相比CPU的开销，磁盘IO的开销更大，更值得关注</p><ul><li>CPU的开销几乎可以忽略</li><li>必须考虑随机IO和顺序IO（尽量将随机IO改为顺序IO）</li></ul><p>同时，DBMS是完全控制了磁盘文件页的读取，所以可以在更细的粒度上管理磁盘页</p><br><br><h2 id="Postgres-costs-model"><a href="#Postgres-costs-model" class="headerlink" title="Postgres costs model"></a>Postgres costs model</h2><p>PostgreSQL的代价估算模型</p><p>用<strong>魔法数</strong>将磁盘IO的开销和CPU计算的开销联系在一起</p><p>魔法数：用数个系数和某种算法，建立数据之间的关系（一般是写死的；根据经验得出来的）</p><p>比如说从硬盘中取数据，比从内存中取数据慢了400倍；顺序IO比随机IO快4倍</p><p>并且，DBMS中很多算法都是基于这个魔法数的，不能随意修改</p><br><br><h2 id="IBM-db2-cost-model"><a href="#IBM-db2-cost-model" class="headerlink" title="IBM db2 cost model"></a>IBM db2 cost model</h2><p>与开销有关的几个因素：</p><ul><li>系统本身的数据</li><li>硬件配置</li><li>存储器类型</li><li>通信的带宽（是单机还是分布式部署）</li><li>内存（缓存池）</li><li>并发环境（并发数量、隔离级别、锁的情况）</li></ul><br><br><br><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>基于规则（启发式）的优化器，基于给定的规则去优化一个执行计划</p><ul><li>数据的分布以及其他情况，是不需要了解的</li><li>只需要根据规则进行替换</li></ul><br><p>而基于代价的优化器，需要知道数据的统计信息，比前者更加先进，更容易得到最优的执行计划</p>]]></content>
      
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> CMU 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 12-Query Execution Part II</title>
      <link href="/2022/12/29/cmu-15-445-12-query-execution-part-ii/"/>
      <url>/2022/12/29/cmu-15-445-12-query-execution-part-ii/</url>
      
        <content type="html"><![CDATA[<h1 id="Why-care-about-parallel-execution"><a href="#Why-care-about-parallel-execution" class="headerlink" title="Why care about parallel execution"></a>Why care about parallel execution</h1><p>上节课讨论的都是单个SQL语句是如何执行的，但是实际上我们很多时候都是多线程执行SQL语句</p><br><p>为什么要多线程并发执行</p><ul><li><p>从单条语句看，能够提高响应时间（单独运行的情况下需要运行5s，而多线程的情况下只需要运行0.5s）</p></li><li><p>从多条语句看，能够提高吞吐量（单位时间能够处理多少条语句）</p></li><li><p>能够提高应用的响应性和可用性（底层运行的越快，越能提高上层的可用性）</p></li><li><p>降低开销（提高效率，能够使用更少的时间、更少的电费去实现功能）</p></li></ul><br><br><br><h1 id="Parallel-vs-Distributed"><a href="#Parallel-vs-Distributed" class="headerlink" title="Parallel vs Distributed"></a>Parallel vs Distributed</h1><p>并行数据库</p><ul><li>所有的资源、线程都是在同一个机器上</li><li>并行数据库资源之间的通信是高速的（比如说通过共享内存）</li><li>并行数据库之间线程的通信都是简易和可靠的</li></ul><br><p>分布式数据库</p><ul><li>节点之间的物理距离可能非常遥远</li><li>分布式数据库的通信是非常慢的（需要互联网）</li><li>分布式数据库之间的通信以及相关问题是无法被忽略的</li></ul><br><br><br><h1 id="Process-models"><a href="#Process-models" class="headerlink" title="Process models"></a>Process models</h1><p>研究多个用户的SQL是如何并发执行的，即研究线程模型</p><p>可以将SQL中的操作拆解为不同的算子，每个算子则可以抽象为worker，分配给不同的对象执行</p><br><br><h2 id="Process-per-DBMS-Worker"><a href="#Process-per-DBMS-Worker" class="headerlink" title="Process per DBMS Worker"></a>Process per DBMS Worker</h2><p>每一个worker分配一个进程去做（进程的调度是依赖于操作系统的）</p><br><p>进程间使用shared memory通信</p><br><p>优点：一个进程的崩溃不会影响其他的进程</p><p>缺点：如果并发量非常大的话，创建过多的进程会极度的浪费资源</p><p>应用：DB2，Oracle，Postgresql</p><br><p>当SQL语句到来的时候，会被dispatcher分配worker去执行语句，worker执行完后就将数据返还给DBMS</p><img src="\medias\12-Query-Execution-Part-II\process per DBMS Worker.png" style="zoom:150%;"><br><br><h2 id="Process-pool"><a href="#Process-pool" class="headerlink" title="Process pool"></a>Process pool</h2><p>背景：因为多进程会浪费资源，所以想到了复用进程，进而提出进程池</p><p>其中dispatcher不再是直接创造出进程，而是从进程池里面找到可用的进程给SQL去执行，用完后再返回进程池</p><p>应用：DB2，postgresql</p><img src="\medias\12-Query-Execution-Part-II\process pool.png" style="zoom:150%;"><br><br><h2 id="Thread-per-DBMS-Worker"><a href="#Thread-per-DBMS-Worker" class="headerlink" title="Thread per DBMS Worker"></a>Thread per DBMS Worker</h2><p>背景：由于进程的切换代价高，进程本身占用过多资源，因此引入pthread线程（并且pthread天生就能够相互通信）</p><p>每个worker都分配一个线程</p><p>线程之间的调度是由DBMS调度（有点类似用户态线程）</p><p>dispatcher的数量不定，一个或者多个</p><br><p>优点：线程的切换代价上是小于进程的切换的；线程天生支持共享内存通信</p><p>缺点：一个线程的崩溃会导致整个进程崩溃（稳定性差）</p><p>应用：DB2，Oracle，SQL Server，MySQL</p><img src="\medias\12-Query-Execution-Part-II\thread per worker.png" style="zoom:150%;"><br><p>很多DBMS都用了多线程的技术</p><ul><li>这里的多线程其实是指一个SQL语句由一个worker去跑，多线程是指可以同时跑多个SQL语句</li><li>而将一条SQL开多线程跑是另一种技术</li></ul><br><br><br><h1 id="Execution-parallelism"><a href="#Execution-parallelism" class="headerlink" title="Execution parallelism"></a>Execution parallelism</h1><p>SQL执行间的并发机制</p><p>针对每一个执行计划，DBMS都要决定在哪儿执行，什么时候执行以及如何去执行</p><ul><li>比如说将执行计划切分为多少个任务（如何将每条SQL语句分为多个worker去执行）</li><li>每个任务需要占有多少的CPU资源</li><li>哪些CPU资源需要执行哪些任务</li><li>单个小任务的数据应该如何汇集在一起</li></ul><br><p>尽量让DBMS本身来控制这些行为，而不是OS</p><br><br><h2 id="Inter-query-parallelism"><a href="#Inter-query-parallelism" class="headerlink" title="Inter query parallelism"></a>Inter query parallelism</h2><p><strong>查询之间</strong>如何并发的执行</p><p>优点：不同的查询并发的去执行，可以降低延迟，提高吞吐量</p><br><p>如果查询是只读的话，那么多个查询之间的冲突就会很小，就没有并发问题</p><p>但是如果查询有读有写，那么就会有并发问题（需要后续的并发控制协议）</p><br><br><h2 id="Intra-query-parallelism"><a href="#Intra-query-parallelism" class="headerlink" title="Intra query parallelism"></a>Intra query parallelism</h2><p><strong>查询内部</strong>的算子进行并发处理，即将一个一个执行计划切分为不同的线程去做，可以减少延迟（减少等待）</p><p>优点：将一个查询计划拆分为不同的算子，并分给好几个线程同时执行，从而提高单个查询的性能和效率</p><br><p>思想上有点像生产者消费者的模型（前面的算子生产出了数据，后续的算子消费数据）</p><br><p>成熟DBMS的每一个算子都有并发的版本</p><p>例子：比如说之前的grace hash join</p><ul><li>可以并发的多个线程去处理每个桶之间的数据，即对每个桶进行并发的join</li><li>也可以用单个线程实现hash join</li></ul><img src="\medias\12-Query-Execution-Part-II\hash join.png" style="zoom:150%;"><br><p>并发算子实现的两大思路</p><ul><li>多个线程都去操作集中的总数据</li><li>或者将数据分隔开，让多个线程在本地就能处理不同部分的数据</li></ul><br><br><h3 id="Intra-operator-horizontal"><a href="#Intra-operator-horizontal" class="headerlink" title="Intra-operator(horizontal)"></a>Intra-operator(horizontal)</h3><p>水平切分；将需要处理的数据切分为多份，然后分发给多个线程执行</p><p>即每个线程执行的逻辑是相同的，但是负责的数据部分不同</p><p>最后插入exchange算子（用于数据的拆分聚集的）</p><br><p>下面的算子调用一次exchange算子</p><p>然后exchange算子并发的开启多个线程A1A2A3去执行</p><p>最后把得到的结果汇总给上面的算子</p><img src="\medias\12-Query-Execution-Part-II\intra-operator parallelism_01.png" style="zoom:150%;"><br><br><h4 id="Exchange-operator"><a href="#Exchange-operator" class="headerlink" title="Exchange operator"></a>Exchange operator</h4><p>有三种类型的exchange算子：</p><ul><li>gather：将下面并发执行的结果收集好分配给上面</li><li>distribute：将数据分发给不同的算子去执行，分配的算子</li><li>repartition：重分配的算子，即把三个算子的结果分配给两个算子去执行</li></ul><img src="\medias\12-Query-Execution-Part-II\exchange operator.png" style="zoom:150%;"><br><br><h3 id="Inter-operator-vertical"><a href="#Inter-operator-vertical" class="headerlink" title="Inter-operator(vertical)"></a>Inter-operator(vertical)</h3><p>垂直切分；一个SQL语句是由很多个算子组成的</p><p>那么就可以分配多个线程，分别取执行不同阶段的算子，以此实现并发</p><br><p>比如说线程1在下面执行hash join，而线程2在执行上面的算子</p><p>每个算子都由一个线程负责，数据就在线程之间进行传递</p><img src="\medias\12-Query-Execution-Part-II\inter-operator parallelism_01.png" style="zoom:150%;"><br><p>缺点：参考流式模型的缺点（如果某个算子的执行效率过低，那么就会影响后续算子的运行）</p><br><br><h3 id="Bushy-parallelism"><a href="#Bushy-parallelism" class="headerlink" title="Bushy parallelism"></a>Bushy parallelism</h3><p>是上述两种执行方法的融合版本，既有水平切分，也有垂直切分</p><img src="\medias\12-Query-Execution-Part-II\bushy parallelism.png" style="zoom:150%;"><br><br><h2 id="Observation"><a href="#Observation" class="headerlink" title="Observation"></a>Observation</h2><p>其实DBMS真正的瓶颈是数据的IO，上面无论做再多的优化，如果磁盘的IO还是很慢的话，这些优化都不值一提</p><p>磁盘是瓶颈，但是我们还让不同的线程去读磁盘不同的部分，即随机IO</p><p>那么就会加剧这种瓶颈，所以要想到如何优化硬盘IO的性能</p><br><br><br><h1 id="I-x2F-O-parallelism"><a href="#I-x2F-O-parallelism" class="headerlink" title="I&#x2F;O parallelism"></a>I&#x2F;O parallelism</h1><p>磁盘IO的并发优化</p><p>最简单的思路：希望将数据库分为不同的部分，存储到不同的磁盘上，提高并发的性能</p><ul><li>比如说将A库存在一块磁盘上，将B库存在另一块磁盘上，这样在读取两个数据库的数据时是可以做到并发的</li></ul><p>常见的操作有：</p><ul><li><p>将同一个数据库存储在不同的硬盘上</p></li><li><p>一个数据库存放在一个硬盘上</p></li><li><p>一个数据表存放到一个硬盘上</p></li><li><p>把同一个数据表分割为不同的部分，存储在硬盘上</p></li></ul><br><p>这种做法还是在数据库层面，需要修改数据库的元数据配置</p><br><br><br><h1 id="Multi-disk-parallelism"><a href="#Multi-disk-parallelism" class="headerlink" title="Multi-disk parallelism"></a>Multi-disk parallelism</h1><p>从物理硬件（操作系统）层面，提高IO并发的效率（在数据库层面是无感知的，即DBMS像往常一样存取数据即可）</p><br><p>磁盘阵列（RAID），有多个磁盘，但是通过一些配置，使得看起来只有一个磁盘一样（使得DBMS感觉只有一个磁盘一样）</p><p>并且这种底层的磁盘配置对于DBMS来说是透明的（DBMS会认为此时只有一个磁盘，而实际上数据是存储在多个磁盘）</p><br><p><strong>RAID 0</strong></p><p>把page1和page4放到第一个盘，page2和page5放到第二个盘，page3和page6放到第三个盘</p><p>主要是操作系统和硬件共同控制；从文件系统上看就只有一个盘，但是底层是将数据切分为不同的部分存储到不同的硬盘的</p><img src="\medias\12-Query-Execution-Part-II\RAID 0.png" style="zoom:150%;"><br><p>优点：</p><ul><li>能够提高并行的读写（可以同时读写page1和page2）</li><li>拓展性高，可以横向添加多个硬盘</li></ul><p>缺点：</p><ul><li>如果一块硬盘坏了，其他盘中的文件碎片也会失效（因为这种方法是将文件的多个页面进行拆分的，如果一个文件其中某一页出现了问题，那么整个文件页就会失效）</li><li>因此需要备份的手段</li></ul><br><br><p><strong>RAID 1</strong></p><p>同一个数据页存到不同的磁盘中，相当于数据备份在不同的磁盘上</p><img src="\medias\12-Query-Execution-Part-II\RAID 1.png" style="zoom:150%;"><p>优点：可靠性高，多备份（其中一个数据盘坏了也不受影响）；可以并行读（并发写的话需要同步机制）</p><p>缺点：利用率低（3个1T的硬盘只能存1T的数据）</p><br><br><p><strong>RAID 5</strong></p><p>拿RAID 0举例：</p><p>把page1和page4放到第一个盘，page2和page5放到第二个盘</p><p>而第三个盘存储的是第一个盘和第二个盘中的数据，<strong>异或</strong>以后的结果</p><p>如果第三个盘挂了，那么重新将第一个盘和第二个盘异或即可</p><p>如果第二&#x2F;一个盘挂了，那么可以利用第三个盘将挂了的盘进行恢复</p><p>当然还可以备份异或得到的结果，由此衍生不同的变种</p><img src="\medias\12-Query-Execution-Part-II\RAID 0.png" style="zoom:150%;"><br><br><br><h1 id="Database-partitioning"><a href="#Database-partitioning" class="headerlink" title="Database partitioning"></a>Database partitioning</h1><p>从数据库的表本身将数据切分开</p><br><p>对于数据分库，大部分的DBMS都支持将数据切分到不同的磁盘上</p><ul><li>主要因为DBMS是保存在不同的文件系统的不同的文件夹上</li><li>PS：DBMS用于recovery的log就需要在多个库之间共享</li></ul><br><p>而对于数据分区，可以在物理上将一个数据表分为多个不同的数据表</p><p>但是客户端（使用者）对此是无感知的，全部由DBMS控制数据的分表</p><p>表数据分区的两种思路：垂直分表、水平分表</p><br><h2 id="Vertical-partitioning"><a href="#Vertical-partitioning" class="headerlink" title="Vertical partitioning"></a>Vertical partitioning</h2><p>垂直分表，将不同列的数据存放到不同的磁盘（目录或者文件系统）中（使用的时候配置一下DBMS即可）</p><p>比如下图就是将attr1、attr2、attr3和attr4进行了分区处理</p><img src="\medias\12-Query-Execution-Part-II\vertical partitioning.png" style="zoom:150%;"><br><p>优点：</p><ul><li>针对同一条数据的IO，可以实现并发的读写数据</li><li>将冷热数据分离，提高读写效率（将一些不常用的数据和热点数据分表存储）</li></ul><br><br><h2 id="Horizontal-partitioning"><a href="#Horizontal-partitioning" class="headerlink" title="Horizontal partitioning"></a>Horizontal partitioning</h2><p>水平分表，按照某一列的值将一个数据表分割为多个数据表</p><p>对于数据分割的方法有很多，比如常见的hash分区、范围分区、再或者谓词分区</p><img src="\medias\12-Query-Execution-Part-II\horizontal partitioning_01.png" style="zoom:150%;"><p>一些分库分表的中间件也可以做水平分区</p><p>就像是一个网关，将客户端的数据分成不同的部分，然后再存储到不同的数据库（节点）上</p><br><br><br><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>并发执行、并行是非常重要的（能够降本增效），因此几乎所有的DBMS都实现了并发执行</p><ul><li>主要指的是SQL语句之间的并发</li></ul><br><p>模型看着简单，但是coding却非常的麻烦</p><ul><li>worker的调度、协调</li><li>worker的并发（数据的加锁解锁）</li><li>worker资源上的冲突（比如说多个worker都需要相同的资源，那么磁盘的资源如何协调）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> CMU 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 11-Query Execution Part I</title>
      <link href="/2022/12/29/cmu-15-445-11-query-execution-part-i/"/>
      <url>/2022/12/29/cmu-15-445-11-query-execution-part-i/</url>
      
        <content type="html"><![CDATA[<h1 id="Processing-model"><a href="#Processing-model" class="headerlink" title="Processing model"></a>Processing model</h1><p>执行模型有哪些，执行计划是如何运作的</p><p>DBMS的执行模型规定了系统是如何执行查询计划的</p><p>根据不同的工作负载（TP or AP），在执行计划上有不同的权衡</p><br><br><h2 id="Approach-1-iterator-model"><a href="#Approach-1-iterator-model" class="headerlink" title="Approach 1 iterator model"></a>Approach 1 iterator model</h2><p>迭代器模型，也叫火山模型（Volcano Model），或者流式模型（Pipeline Model）</p><p>每个算子都要实现一个<code>next()</code>方法</p><p>当父算子调用当前算子的<code>next()</code>方法的时候，当前算子就会向父算子返回一条数据（或者是返回NULL，表示当前算子运行结束）</p><p>如果当前算子有子算子的话，就需要循环的调用子算子的<code>next()</code>方法，得到下一层的数据</p><p>需要多少条数据，就会有多少次这样的链式的函数调用</p><img src="\medias\11-Query-Execution-Part-I\iterator model_01.png" style="zoom: 150%;"><br><br><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>1号算子循环调用<code>child.next()</code>算子，即2号算子</p><p>2号算子分为两部分，要先执行<code>left.next()</code>算子（hash join中构建hash表），再执行<code>right.next()</code>算子（将数据放入hash表中映射）</p><p><code>left.next()</code>算子，即3号算子，则需要一行一行的向上返回数据；4、5号算子同理</p><img src="\medias\11-Query-Execution-Part-I\iterator model_02.png" style="zoom:150%;"><p>而在执行2、3、4、5号算子的过程中，1号算子会因为2号算子没有返回数据而阻塞（因为只有下面的算子返回了数据，上面的算子才能继续运行）</p><br><br><p><strong>几乎所有的DBMS都用到了火山模型</strong>（或者它的变种）</p><p>一条条数据向上吐出（数据流处理），和直观上认为DBMS的运行是不一样的（直观上认为是把所有的数据都计算好，再往上返回）</p><p>某些算子存在阻塞阶段</p><ul><li>比如join算子在构建hash表的时候，是不会返回数据的</li><li>又或者说subqueries子查询</li><li>再比如order by排序，因为需要将所有的数据都获取了以后，进行排序才能够返回</li></ul><p>使用这种方法非常方便控制数据的输出</p><ul><li>比如说此时要求<code>limit 100</code>，那么只需要输出到100条数据的时候停止即可</li><li>而不需要控制底层算子具体需要读取多少条数据，只需要控制算子的出口输出即可</li></ul><p>性能上的一些问题</p><ul><li><p>部分算子依旧存在阻塞</p></li><li><p>每一条数据的输出都是依靠函数调用，可能出现函数栈溢出</p></li></ul><img src="\medias\11-Query-Execution-Part-I\iterator model_03.png" style="zoom:150%;"><br><br><h2 id="Approach-2-materialization-model"><a href="#Approach-2-materialization-model" class="headerlink" title="Approach 2 materialization model"></a>Approach 2 materialization model</h2><p>物化模型（一般大众直观上认为的一种做法）</p><p>每个算子的输入就是当前语句需要执行的所有数据，输出的是语句的所有结果</p><p>即将当前语句涉及的所有数据都处理好了，才返回给上一级</p><br><p>每一个算子都有一个out数组，用于存储当前算子处理好了的数据，并作为结果返回给上一级算子</p><p>模型中所有的算子都只会被调用一次</p><img src="\medias\11-Query-Execution-Part-I\materialization model_01.png" style="zoom:150%;"><br><p>一些偏向OLTP的数据库，比如交易的数据库会使用这种数据库</p><ul><li>因为涉及交易的操作很多都是点查询，只涉及很少的数据</li><li>无论是最终结果还是中间结果，数据量都很小，DBMS能够轻松负载</li></ul><p>因此这种做法并不适用于OLAP的数据库，因为中间结果太大，容易爆内存</p><img src="\medias\11-Query-Execution-Part-I\materialization model_02.png" style="zoom:150%;"><br><br><h2 id="Approach-3-vectorized-x2F-batch-model"><a href="#Approach-3-vectorized-x2F-batch-model" class="headerlink" title="Approach 3 vectorized&#x2F;batch model"></a>Approach 3 vectorized&#x2F;batch model</h2><p>向量化模型（分批模型），属于是方法一和方法二的中间派，就是两种方法的结合</p><p>和<code>iterator model</code>一样有<code>next()</code>方法，但是返回的不是一条数据，而是一批数据</p><p>也和<code>materialization model</code>一样有<code>out</code>数组，但返回的不是全部数据，而是部分数据</p><img src="\medias\11-Query-Execution-Part-I\vectorization model_01.png" style="zoom:150%;"><br><br><p>适用于OLAP类型的数据库</p><ul><li>因为既能使得中间的结果集不太大，又能使得函数的调用次数相对少一点</li></ul><p>在底层指令集上的优势：</p><ul><li>背景：intel有一个能够同时处理多个数据的指令（即在一个机器指令的周期就能够将数据全部计算好），即<strong>AVX指令集</strong></li><li>这种模型的底层就可以利用这种批处理的指令，实现一次性处理多条数据</li><li>也叫做向量执行模型</li></ul><img src="\medias\11-Query-Execution-Part-I\vectorization model_02.png" style="zoom:150%;"><br><br><br><h1 id="Plan-processing-direction"><a href="#Plan-processing-direction" class="headerlink" title="Plan processing direction"></a>Plan processing direction</h1><p>执行语句时，函数调用的方向（是从根节点的函数往下调用叶子节点的函数，还是从叶子结点的函数往上调用根结点的函数）</p><p>PS：数据流动的方向一直是从下往上的</p><br><p>方法一：<strong>top to bottom</strong></p><ul><li>从上往下执行，先执行根结点，再执行叶子节点</li></ul><br><p>方法二：<strong>bottom to top</strong></p><ul><li>从下往上执行，先执行叶子节点，然后叶子节点调用根结点</li></ul><br><br><br><h1 id="Access-methods"><a href="#Access-methods" class="headerlink" title="Access methods"></a>Access methods</h1><p>从磁盘读取数据、存储数据的方式有哪些</p><p>主要就是研究如何读表中的数据</p><img src="\medias\11-Query-Execution-Part-I\access methods.png" style="zoom:150%;"><br><br><h2 id="Sequential-scan"><a href="#Sequential-scan" class="headerlink" title="Sequential scan"></a>Sequential scan</h2><p>顺序扫描，从磁盘中把数据页放到内存中，每条记录每条记录的扫描遍历（说白了就是全表遍历）</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">for</span> page <span class="token keyword">in</span> table<span class="token punctuation">.</span>pages<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#外层循环遍历数据页</span>    <span class="token keyword">for</span> t <span class="token keyword">in</span> page<span class="token punctuation">.</span>tuples<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#内存循环遍历数据页里面的数据</span>        <span class="token keyword">if</span> evalPred<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">#do something</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果需要某个数据页页，就先在buffer pool中去找，如果有的话，就把它取出来遍历；否则就去硬盘中去找</p><p>在执行过程中的算子需要保持一个指针，把这个指针当作迭代器一样去扫描遍历数据（同时记录上一次读取到哪里的数据了）</p><br><br><h3 id="Optimizations"><a href="#Optimizations" class="headerlink" title="Optimizations"></a>Optimizations</h3><p>类似全表扫描等操作，存在很多优化的可能</p><p>方法一：prefetching</p><p>在执行计划之前，提前将数据从磁盘中预先取出来</p><br><p>方法二：buffer pool bypass</p><p>在全表扫描时，假如用过的数据后续不会再用了，那么就不用将数组再存储在buffer中了，而是用完后就丢掉</p><br><p>方法三：parallelization</p><p>多线程并行执行：启用两个线程，一个线程从前扫到中间，另一个线程从中间扫到后面</p><br><p>方法四：zone maps</p><p>背景：假设有一个需求，要扫描大于100的数据值；但是有可能某个数据页里面所有的值都小于100，如果把该页放入内存，就会造成资源的浪费</p><p>所以希望用一个map，用来<strong>记录关于这个页</strong>的相关信息（比如说max，min，avg，sum等），以便DBMS筛选掉某些页，从而优化全表扫描的速度</p><img src="\medias\11-Query-Execution-Part-I\zone maps.png" style="zoom:150%;"><p>缺点：</p><ul><li>浪费空间；如果该信息是存放在每个页的话，那么就无法达到筛选的目的（因为我们本来就是希望利用zone map减少无用数据页的读取），所以必然是存储在额外的数据页的</li><li>不利于数据的存放；如果原始数据可能发生了一点点修改，那么map可能会因此发生很大的修改，不方便维护，甚至可能造成写放大，即单单写入一个数据表的数据，结果需要修改过多zone map上的数据</li></ul><br><p>方法五：late materialization</p><p>延迟物化</p><p>只需要把符合条件的记录的id（offsets）给返回，在最后返回数据的时候才将数据进行物化（最后才回表），减少了扫描的工作量</p><p>适用于<strong>列存储</strong>的数据库，因为算子一般只对列的数据进行处理（而行存储是将一连串数据一起存储，不方便获取单独列的数据）</p><br><br><h2 id="Index-scan"><a href="#Index-scan" class="headerlink" title="Index scan"></a>Index scan</h2><p>查询扫描走索引的一些条件：</p><ul><li>索引有没有我们需要的属性</li><li>索引是否含有我们需要的输出列</li><li>索引的值域</li><li>谓词的压缩</li><li>是否为唯一索引</li></ul><br><p>假如有两个索引，应该选择哪一个索引效果更好？</p><img src="\medias\11-Query-Execution-Part-I\index scan.png" style="zoom:150%;"><p>选择该索引后，剩下的数据，即需要再排查的数据越少，就选那一个</p><p>比如说上面要选择age &lt; 30的，那么如果选择age的索引，最后剩下的数据更少，那么就选择age的索引</p><br><br><h2 id="Multi-index-scan"><a href="#Multi-index-scan" class="headerlink" title="Multi-index scan"></a>Multi-index scan</h2><p>比如上面的问题，多索引的思路是用一个索引筛出数据A，用另一个索引筛出数据B，然后对这两个数据进行取交集</p><img src="\medias\11-Query-Execution-Part-I\multi-index scan.png" style="zoom:150%;"><p>在PG中，multi-index scan的底层就是用bitmap实现的</p><br><br><br><h1 id="Modification-queries"><a href="#Modification-queries" class="headerlink" title="Modification queries"></a>Modification queries</h1><p>此前对于数据的研究都是读取，并没有涉及到数据层面的修改</p><p>而涉及数据的修改的语句的执行逻辑，和读取的逻辑是截然不同的</p><br><p>比如说，对于数据的插入、更新和删除，都是要检查其是否符合数据库的约束的，即一致性（比如unique等），同时还要维护数据的索引</p><br><p>update&#x2F;delete</p><ul><li>下面的算子将要删除的记录id返还给上一层（而不是整条数据），然后用这个id回表删除记录</li><li>删除算子和更新算子都要记录自己对哪些数据进行了操作</li></ul><br><p>insert</p><ul><li>算子内部将数据物化，将数据整个插入</li><li>需要子算子将行记录物化好，则当前的insert算子只要将记录插入即可</li></ul><br><br><h2 id="Update-query-problem"><a href="#Update-query-problem" class="headerlink" title="Update query problem"></a>Update query problem</h2><p>假设要更新一个索引上所有的数据，使其全部加上100</p><p>update的操作流程是，按照索引的顺序，每读一个数据就把该数据先从index中移除，接着给这个数据+100，然后再放回去</p><p>而如果不记录当前update的算子对于哪些数据进行了操作，</p><p>比如说我们希望age小于30的人全部加10岁，某个人现在11岁</p><p>那么在第一次加10岁以后，变成了21岁，但我们没有记录对哪些数据进行了操作，那么就会重复给这个数据再加10岁</p><p>造成数据更新的重复</p><p>因此无论是update还是delete，都要记录下自己对哪些数据进行了操作</p><p>这个问题被简称为halloween problem，即万圣节问题</p><br><br><br><h1 id="Expression-evaluation"><a href="#Expression-evaluation" class="headerlink" title="Expression evaluation"></a>Expression evaluation</h1><p>谓词表达式的一些计算（谓词表达式本质上就是一个计算式，涉及到不同的符号，比如等于不等于等符号）</p><img src="\medias\11-Query-Execution-Part-I\expression evaluation.png" style="zoom:150%;"><br><br><p>在DBMS中，一个通用的处理方案是：</p><p>将谓词表达式拆分为一个树状的流程图，即分为几个不同的算子</p><img src="\medias\11-Query-Execution-Part-I\expression evaluation_01.png" style="zoom:150%;"><br><br><p>不过这种流程存在一些优化的方向：</p><img src="\medias\11-Query-Execution-Part-I\expression evaluation_02.png" style="zoom:150%;"><br><p>这里的<code>WHERE</code>需要先读取<code>B.value</code>，然后计算<code>? + 1</code>的值是多少，最后再将二者进行比较看是否相等</p><p>而每次都要计算一遍<code>? + 1</code>的值是多少，效率非常低</p><p>一个优化的方式就是先直接将<code>? + 1</code>的值计算好，后续直接调用即可</p><br><p>这就有点类似java里面的JIT</p><ul><li><p>just in time，java运行的是字节码，相当于把代码编译为了字节码，而不是二进制；于是有一种思路就是，发现一些重复利用的代码，于是就将其编译成了二进制，提高效率，即再使用这类代码的时候就变为二进制执行了</p></li><li><p>把一些热点的代码段编译为二进制，从而提高效率</p></li><li><p>PS：jit是在执行的时候判断</p></li><li><p>而与JIT对立的是AOT，执行之前就判断，还没运行的时候就将重复的字节码编译为二进制</p></li></ul><br><br><br><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>一个相同的执行计划，不同的执行模型，执行方法也会不同</p><p>在排查大部分DBMS的问题的时候，查询是否走索引是一个经常需要注意的方向</p><p>按照树形的方法进行查询是非常灵活的，但是会很慢，所以需要后续的一些优化</p>]]></content>
      
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> CMU 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 10-Join Algorithms</title>
      <link href="/2022/12/26/cmu-15-445-10-join-algorithms/"/>
      <url>/2022/12/26/cmu-15-445-10-join-algorithms/</url>
      
        <content type="html"><![CDATA[<h1 id="Why-do-we-need-to-join"><a href="#Why-do-we-need-to-join" class="headerlink" title="Why do we need to join"></a>Why do we need to join</h1><p>因为数据在关系型数据库中的存储，是按照数据模型间的连接关系分开的</p><p>所以，如果想要获取一连串相关联的数据，就需要用join连表查询</p><p>本节主要研究的是<strong>内连接</strong>，用<strong>相等</strong>谓词连接的算法</p><p>在进行join的时候，有个原则就是尽量把小一点的表放到左边（也就是外表）</p><p>PS：本节说的小表，都是指<strong>文件页少</strong>的数据表</p><br><br><br><h1 id="Join-operators"><a href="#Join-operators" class="headerlink" title="Join operators"></a>Join operators</h1><p>首先就要研究<strong>算子的输出</strong>，向上级输出的数据是什么类型的</p><p>接着就要研究<strong>不同算法的花费</strong>，并根据开销决定用选取算法</p><br><br><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><p>early materialization（提前物化）</p><p>向上输出的是两个表连接后得到的数据，即把整条数据记录都往上传</p><p>优点：算子得到的结果不需要回表查询</p><p>缺点：传输整条数据的开销过大</p><img src="\medias\10-Join-Algorithms\data.png" style="zoom:150%;"><br><br><h3 id="Record-ids"><a href="#Record-ids" class="headerlink" title="Record ids"></a>Record ids</h3><p>late materialization（延迟物化）</p><p>向上输出的是数据记录的id号</p><p>优点：数据在算子间的传输开销较小</p><p>缺点：如果想要获取完整的数据记录，就需要回表查询</p><img src="\medias\10-Join-Algorithms\ids.png" style="zoom:150%;"><br><br><h2 id="Cost-analysis-criteria"><a href="#Cost-analysis-criteria" class="headerlink" title="Cost analysis criteria"></a>Cost analysis criteria</h2><p>对算法的开销进行分析</p><p>以<strong>磁盘的IO次数</strong>衡量算法的开销</p><br><p>笛卡尔积</p><p>笛卡尔积是解决join最朴素的方法，但它是非常低效的</p><p>因此，为了降低连表查询时开销，提出了以下算法：</p><ul><li>nested loop join（simple，stupid，block，index）</li><li>sort-merge join</li><li>hash join</li></ul><br><br><br><h1 id="Nested-loop-join"><a href="#Nested-loop-join" class="headerlink" title="Nested loop join"></a>Nested loop join</h1><p>嵌套循环join</p><br><h2 id="Simple-nested-loop-join"><a href="#Simple-nested-loop-join" class="headerlink" title="Simple nested loop join"></a>Simple nested loop join</h2><p>简单嵌套循环，分为外层循环和内层循环（可以理解为<code>O(n^2)</code>的循环）</p><p>外层循环时遍历R表的每一行，针对R表的每一行</p><p>再在内层循环中遍历S表中的每一行，进行匹配</p><br><p>具体的操作就是读取外表（R表）的每一条记录，然后从头开始遍历一遍S表，看看是否能够匹配上</p><p>PS：此时内存最少能够存放三个数据页即可（R、S表的数据页，以及匹配结果的数据页）</p><img src="\medias\10-Join-Algorithms\stupid nested loop join.png" style="zoom:150%;"><br><p>缺点：没有充分利用到缓存池的特点</p><ul><li>比如说对于R表的第一条记录进行join的时候，会轮流将S表的数据都读到buffer中</li><li>而在用完S表的数据后又会将它放回磁盘，并在对R表的第二条记录进行join的时候重新读入</li><li>此时就会发现buffer失效了，明明可以重复利用此前读入内存的S表的数据页，但都没有用上</li><li>即，这种做法并没有利用缓冲池能提高内存页的利用率的优点</li></ul><br><br><p><strong>算法开销</strong></p><p>要读取整个R表，所以是<code>M</code>（总共有M个数据页）</p><p>对于R表中的每一条记录，都需要一一和S表中的数据匹配，所以是<code>m * N</code>（R表中有m条记录，每条记录都需要读取S表的N个数据页）</p><img src="\medias\10-Join-Algorithms\stupid nested loop join_01.png" style="zoom:150%;"><br><br><h2 id="Block-nested-loop-join"><a href="#Block-nested-loop-join" class="headerlink" title="Block nested loop join"></a>Block nested loop join</h2><p>一个优化思路，此前都是按照一条条数据记录进行join，可以改进为按照数据页进行遍历</p><br><p>先读取R数据表的数据页A</p><p>然后再依次的遍历S中的数据页，从而将数据页A中的数据一一对上</p><p>接着再读取R表的下一个数据页B，一次类推</p><p>PS：此时内存最少能够存放三个数据页即可（R、S表的数据页，以及匹配结果的数据页）</p><p>下图的block可以理解为一个页Page</p><img src="\medias\10-Join-Algorithms\block nested loop join_01.png" style="zoom:150%;"><br><br><p><strong>算法开销</strong></p><p>要读取整个R表，所以是<code>M</code>（R表中有M个页）</p><p>而此时是以数据页进行匹配的，即每个数据页都匹配一遍S表，所以是<code>M * N</code>（R表中有M个页，S表有N个页）</p><img src="\medias\10-Join-Algorithms\block nested loop join_02.png" style="zoom:150%;"><br><br><p><strong>基于缓冲池的优化</strong></p><p>假设内存缓冲池中有B个缓存页</p><p>选取其中一个页作为输出缓存，一个页作为内表（S表）的缓存</p><p>剩下的B-2个页作为外表（R表）的缓存</p><p>此时的流程：将R表的数据读入内存后，依次从头遍历S表的每一页，将S表上的数据和R表上的数据进行匹配</p><img src="\medias\10-Join-Algorithms\block nested loop join_03.png" style="zoom:150%;"><br><br><p><strong>算法开销</strong></p><p><code>M + (M / (B - 2) * N)</code></p><ul><li>M表示要将R表中所有的数据都读取一遍</li><li><code>M/(B - 2)</code>表示将R表中的数据全数放入大小为<code>B - 2</code>内存中，需要多少次</li><li>因此如果&#96;&#96;B - 2 &gt; M<code>，那就相当于只需要</code>M + N&#96;</li></ul><img src="\medias\10-Join-Algorithms\block nested loop join_04.png" style="zoom:150%;"><br><br><h2 id="Index-nested-loop-join"><a href="#Index-nested-loop-join" class="headerlink" title="Index nested loop join"></a>Index nested loop join</h2><p>思考：为什么simple&#x2F;block nested loop join那么慢？换言之，为什么一定要完全遍历S表的所有数据？</p><p>主要是因为内表（S表）没有加索引，导致每次数据的查询必须全遍历，由此引申出基于索引的查询</p><br><p>算法的开销：<code>M + (m * C)</code>（C是指每次查询所有需要的页数）</p><img src="\medias\10-Join-Algorithms\index nested loop join.png" style="zoom:150%;"><br><br><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>如果选取nested loop join作为join的算法，那么：</p><ul><li><p>尽量把小一点的表作为外表（这样遍历内表的次数就会减少）</p></li><li><p>尽量缓存多一点外表的数据，这样可以减少内表的遍历次数</p><ul><li>因为我们是以外表为核心遍历的，所以内表的数据缓存下来是没有意义的，每次都还是得从头遍历</li></ul></li><li><p>每次查找都会一直遍历循环内表，因此提出利用索引进行查询，提高效率</p></li></ul><br><br><br><h1 id="Sort-merge-join"><a href="#Sort-merge-join" class="headerlink" title="Sort-merge join"></a>Sort-merge join</h1><p>将需要进行join的数据列，先进行sort，然后再merge</p><img src="\medias\10-Join-Algorithms\sort merge join的伪代码.png" style="zoom: 150%;"><br><p>merge时的一些细节：</p><ul><li><p>首先，哪一边较小，就将小的一边的指针往下移一位</p></li><li><p>而，对于双指针中二者值相等的时候，一般的做法是输出值后同时下移指针</p></li><li><p>但这里内表（S表）中可能会出现多个数据相同的情况，如果同时下移指针可能会略过一些数据</p></li><li><p>所以不能同时移动两边的指针，而只能移动内表的指针（即移动S表的指针）</p></li></ul><br><br><p><strong>算法开销</strong></p><p>排序时的开销就是上一节所说的外部排序</p><img src="\medias\10-Join-Algorithms\sort merage join的cost_01.png" style="zoom:150%;"><br><br><p>缺点：如果两边的数据全都一样，或者说重复的数据太多，在最严重的时候会导致退化为simple nested loop join</p><ul><li>比如两个表的数据都是完全一样的话，那么执行效率上就会和Simple nested loop join的双层循环一样了</li></ul><img src="\medias\10-Join-Algorithms\sort-merge.png" style="zoom:150%;"><br><br><p>那什么时候该算法才是最高效的？</p><ul><li>当数据本身就排好序了，就减少了sort的过程，直接merge（比如说下一级算子给的数据是有序的，或者是从index读取的数据）</li><li>或者说需要的数据本身要求是有序的，那么sort就必不可少（比如说是按照索引读取数据的）</li></ul><br><br><br><h1 id="Hash-join"><a href="#Hash-join" class="headerlink" title="Hash join"></a>Hash join</h1><p>思考：发现B+树的查询有点随机性（和树的结点数和层数有关）；并且我们的需求其实是点查询，不需要B+树范围扫描的特性</p><p>而点查询中最快的是hash，因此引入了hash查询</p><br><h2 id="Basic-hash-join-algoritham"><a href="#Basic-hash-join-algoritham" class="headerlink" title="Basic hash join algoritham"></a>Basic hash join algoritham</h2><p>Phase I：build，扫描外表数据，构建hash表</p><p>Phase II：probe，扫描内表的数据，放入hash表中查询</p><img src="\medias\10-Join-Algorithms\basic hash join algorithm.png" style="zoom:150%;"><br><br><h2 id="Hash-table-values"><a href="#Hash-table-values" class="headerlink" title="Hash table values"></a>Hash table values</h2><p>hash表中的key是语句用于join的那一列数据</p><p>而value有以下几种表示方法：</p><ul><li>提前物化（full tuple，将整个元组作为数据存储）</li><li>推迟物化（tuple identifier，即是数据的行id之类的，后续回表取数据）</li><li><img src="\medias\10-Join-Algorithms\hash table values.png" style="zoom:150%;"></li></ul><br><br><h2 id="Probe-phase-optimization"><a href="#Probe-phase-optimization" class="headerlink" title="Probe phase optimization"></a>Probe phase optimization</h2><p>背景：发现如果使用hash匹配数据，没匹配上很浪费时间精力，因此想要用<strong>bloom filter</strong>进行优化</p><br><p>即用外表做一个hash，同时维护一个bloom filter，然后内表查数据的时候，就先查bloom filter，如果没有就不继续查了</p><br><p>为什么bloom filter可以提高性能，因为内表查询数据首先会去filter中查找，如果没找到，就会跳过当前数据</p><p>而如果没有bloom filter的话，就会加载hash表的page，然后去寻找（这种磁盘的IO无疑是浪费资源的）</p><p>所以bloom filter就可以提早知道数据不存在，就不会去读取内存，从而提高效率</p><p>PS：bloom filter会出现假阳性</p><br><br><p><strong>算法开销</strong></p><img src="\medias\10-Join-Algorithms\hash join cost_01.png" style="zoom:150%;"><br><br><h2 id="Grace-hash-join"><a href="#Grace-hash-join" class="headerlink" title="Grace hash join"></a>Grace hash join</h2><p>背景：上述算法的主要问题是：内存不够，会导致hash难以构建，那该怎么办？因此需要把一些hash表的数据放到硬盘中</p><p>但是又不需要随机的将数据页驱逐到磁盘中，而是希望能够控制内存页驱逐的策略</p><ul><li>所以有了grace hash join</li></ul><br><p>Phase I：用同一个hash函数，把R表和S表分别做一个hash表1和hash表2</p><p>Phase II：把R表的hash表1和S表的hash表2，各取一个分区的数据，进行nested loop join</p><ul><li>这里的原理就是，都是用的同一种hash算法，能够join的元素必然是在同一个分区当中的</li></ul><img src="\medias\10-Join-Algorithms\grace hash join.png" style="zoom:150%;"><br><br><h3 id="Recursive-partitioning"><a href="#Recursive-partitioning" class="headerlink" title="Recursive partitioning"></a>Recursive partitioning</h3><p>背景：上述的假设中，每个单独的bucket（即分区）是可以放入到内存中的</p><p>但，如果一个分区的元素都非常多，都放不到内存中，该如何处理？</p><p>解决办法：对这个非常大的分区，对两边的数据表，再用一个新的hash函数进行hash，直到能够分到足够小的块</p><img src="\medias\10-Join-Algorithms\recursive partitioning.png" style="zoom: 150%;"><br><br><p><strong>算法的开销</strong></p><p>partitioning phase：<code>2（M + N）</code></p><ul><li>无论是内表还是外表，一次是要把数据从硬盘读到内存中，另一次是要把数据放到hash表中并写入磁盘</li><li>这里假设hash表的页数也是和原来的数据表同页</li></ul><br><p>probing phase：<code>M + N</code></p><ul><li>两边分别把hash表的数据都读入到内存，所以就是M + N</li><li>读到内存的数据再进行nested loop join</li></ul><br><p>因此总共的开销是<code>3 * (M + N)</code></p><img src="\medias\10-Join-Algorithms\grace hash join cost.png" style="zoom:150%;"><br><br><h2 id="Observation"><a href="#Observation" class="headerlink" title="Observation"></a>Observation</h2><p>如果提前知道外表的大小，就可以用静态的hash表对数据操作，而不是使用动态扩容的hash表</p><br><br><br><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><img src="\medias\10-Join-Algorithms\join algorithms summary.png" style="zoom: 150%;"><p>如果是两个大表做join的话，最好就是做hash join（绝大部分情况下，都是选择hash join的）</p><p>但，如果需要数据是倾斜的，即发生hash冲突的概率较大（会导致算法退化），那么最好还是选择sort-merge</p><p>或者，输出结果需要被排序的时候，会选择sort-merge</p><p>一般，比较好的DBMS会选择hash join和sort-merge join</p>]]></content>
      
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> CMU 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 09-Sorting,Aggregations</title>
      <link href="/2022/12/26/cmu-15-445-09-sorting-aggregations/"/>
      <url>/2022/12/26/cmu-15-445-09-sorting-aggregations/</url>
      
        <content type="html"><![CDATA[<h1 id="Course-status"><a href="#Course-status" class="headerlink" title="Course status"></a>Course status</h1><p>接下来的几节课里面，主要讲述以下内容：</p><ul><li>Operator Algorithms（具体的算子，比如join，sort是如何执行的）</li><li>Query Processing Models（用什么方案执行查询，比如火山模型）</li><li>Runtime archiectures（查询在内存中是什么架构，例如进线程模型）</li></ul><br><br><br><h1 id="Disk-oriented-DBMS"><a href="#Disk-oriented-DBMS" class="headerlink" title="Disk-oriented DBMS"></a>Disk-oriented DBMS</h1><p>硬盘中存储了大量的数据</p><p>而查询过程中，数据的中间结果不能全放在内存中</p><ul><li>内存空间有限，中间结果可能很多，存放太多中间结果会导致内存用尽</li></ul><p>并且，需要内存缓存池和硬盘进行配合，进行算子的操作</p><p>同时希望最大化的利用顺序IO，降低随机IO的次数</p><br><br><br><h1 id="Why-do-we-need-to-sort"><a href="#Why-do-we-need-to-sort" class="headerlink" title="Why do we need to sort?"></a>Why do we need to sort?</h1><p>关系型数据库没有要求数据要按照特定的顺序排列（如果没有指定，一般SQL得到的结果都是无状态的）</p><p>但是查询往往希望按照特定的顺序检索元组</p><p>比如一些常见的操作：</p><ul><li>去重操作（DISTINCT，先排序再去重）</li><li>聚合操作（GROUP  BY、ORDER BY等，先排序再聚集）</li></ul><br><br><br><h1 id="Sorting-algorithms"><a href="#Sorting-algorithms" class="headerlink" title="Sorting algorithms"></a>Sorting algorithms</h1><p>如果数据能够在内存中排序（即要排序的数据都在内存中），那么就可以使用标准的排序算法（比如快排等）</p><p>否则，就需要一种排序方法，能将大于内存大小的数据进行排序，同时也能兼顾数据在磁盘上读写的成本</p><br><br><h2 id="External-merge-sort"><a href="#External-merge-sort" class="headerlink" title="External merge sort"></a>External merge sort</h2><p>要排序的数据不是在内存中的，而是在硬盘中的</p><p>将数据集分割成单独的运行，然后分别排序</p><p>阶段一：排序（对装入主存的数据块进行排序，然后将排序后的数据块写回磁盘上的文件中）<strong>Sorting</strong></p><p>阶段二：合并（将排序后的子文件合并成一个更大的文件）<strong>Merging</strong></p><br><br><h2 id="Sorted-run"><a href="#Sorted-run" class="headerlink" title="Sorted run"></a>Sorted run</h2><p>假设我们需要对数据的某一列进行排序，则将这一列设为key，这一条数据设为value，组成一个kv对</p><p>其中数据的表达形式（即value）有以下两种方式：</p><ul><li>方式一：v存储的是一整行的数据（early materialization，提早物化）<ul><li>数据排序后不需要回表查询</li></ul></li><li>方式二：v存储的是记录的id或者主键值（late materialization，延迟物化）<ul><li>数据排序后需要用id或主键值进行回表查询</li></ul></li></ul><br><br><h2 id="2-way-external-merge-sort"><a href="#2-way-external-merge-sort" class="headerlink" title="2-way external merge sort"></a>2-way external merge sort</h2><p>2路归并排序</p><br><p>假设当前有page1和page2</p><p>先把page1放到内存中进行排序，把得到的结果1写入磁盘中</p><p>再把page2放到内存中进行排序，把得到的结果2写入磁盘中</p><p>此时磁盘中有page1、page2、结果1、结果2</p><p>然后将结果1和结果2都放到内存中，进行归并；合并得到的结果放到一个新的数据页中</p><p>合并好后把这个数据页放到磁盘中</p><br><br><h3 id="Phase-I"><a href="#Phase-I" class="headerlink" title="Phase I"></a>Phase I</h3><p>将表中的数据页读入到内存中，对数据页的内容进行排序，然后把排序好的结果返回给磁盘</p><img src="\medias\09-Sorting-Aggregations\2-way external merge sort_01.png" style="zoom: 150%;"><br><br><h3 id="Phase-II"><a href="#Phase-II" class="headerlink" title="Phase II"></a>Phase II</h3><p>递归的将数据页成对成对合并（使用三个缓冲页，2个输入页，1个输出页）</p><img src="\medias\09-Sorting-Aggregations\2-way external merge sort_02.png" style="zoom:150%;"><br><br><h3 id="Cost"><a href="#Cost" class="headerlink" title="Cost"></a>Cost</h3><p>因为需要对每个页内部的数据进行排序，所以就需要<code>1</code>个阶段</p><p>而每两个页进行合并排序，所以需要<code>log2 N</code>个阶段（这里需要向上取整）</p><p>统计总共需要多少个阶段，然后再乘以一个2N（因为每个阶段都需要读写2次数据，一次是将数据写入到内存，一次是将排序好的数据写入回内存）</p><img src="\medias\09-Sorting-Aggregations\2-way external merge sort_cost.png" style="zoom: 150%;"><br><br><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Pass #0：读取每一个数据页，将每一个数据页内的数据进行内部排序，使得数据页本身变为有序的</p><p>Pass #1，2，3：每次将两个数据页读入到内存中，将它们归并排序</p><img src="\medias\09-Sorting-Aggregations\2-way external merge sort.png" style="zoom:150%;"><br><br><h3 id="Double-buffering-optimization"><a href="#Double-buffering-optimization" class="headerlink" title="Double buffering optimization"></a>Double buffering optimization</h3><p>发现该算法只需要3个缓冲区页来执行排序，但是我们的内存buffer远远不止三个缓冲页，即这个思路没有有效的把空间利用起来</p><p>因此，当发生排序的时候，在后台预先取下一次要运行的数据页，并在系统当前处理其他页面的时候把它放到第二个缓冲区</p><p>不断的利用磁盘读取数据，减少每一步的IO请求的等待时间</p><p>本质上就是利用多余的内存，实现提前拉取数据的目的</p><br><br><h2 id="General-external-merge-sort"><a href="#General-external-merge-sort" class="headerlink" title="General external merge sort"></a>General external merge sort</h2><p>K路归并排序</p><p>Phase I：使用B个缓冲页对数据进行排序（假设数据表总共有N个数据页，总共需要<code>[N/B]</code>次读取数据并排序）</p><p>Phase II：将内存中的一个缓冲页作为输出页，其他的B-1个缓冲页用作K路合并排序</p><p>PS：MySQL就是用这种方法的</p><img src="\medias\09-Sorting-Aggregations\general external merge sort.png" style="zoom:150%;"><br><br><h3 id="Cost-1"><a href="#Cost-1" class="headerlink" title="Cost"></a>Cost</h3><p>总共的阶段数是$1 + \lceil log_{B-1} \lceil N &#x2F; B\rceil \rceil$（推理过程同上）</p><p>总共的消耗是$2N* (1 + \lceil log_{B-1} \lceil N &#x2F; B\rceil \rceil)$</p><br><br><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><p>第一个阶段，读取5个数据页，将这5个数据页的数据进行一次<strong>整体</strong>的排序</p><p>Pass #0：此时有108个数据页，分为22个整体（108&#x2F;5向上取整，每个整体有5个page，最后一个整体只有3个page）；对每个整体内的数据进行排序</p><p>第二个阶段，将一个数据页位置作为输出位，那么此时剩余4个数据页</p><p>Pass #1：此时有22个整体（108&#x2F;5向上取整，每个整体有5个page，最后一个整体只有3个page），那么每次就取4个整体，每个整体中取出一页，进行归并排序</p><p>Pass #2：此时有6个整体（22&#x2F;4向上取整，每个整体有20个page，最后一个整体只有8个page），那么每次就取4个整体，每个整体中取出一页，进行归并排序</p><p>Pass #3：此时有2个整体（6&#x2F;4向上取整，每个整体有80个page，最后一个整体只有28个page），那么每次就取4个整体，每个整体中取出一页，进行归并排序</p><img src="\medias\09-Sorting-Aggregations\general external merge sort_cost.png" style="zoom:150%;"><br><br><h2 id="Using-B-trees-for-sorting"><a href="#Using-B-trees-for-sorting" class="headerlink" title="Using B+trees for sorting"></a>Using B+trees for sorting</h2><p>如果需要排序的属性，在表中建立了索引（比如说B+ tree），那么就可以使用它来加速排序</p><p>通过直接遍历B+ tree的叶子数据页，得到排序好的数据</p><br><p>这总是比外部排序好，因为没有计算成本，而且所有的磁盘访问都是顺序IO</p><p>分类：聚簇索引和非聚簇索引的B+树</p><br><br><h3 id="Clustered-index"><a href="#Clustered-index" class="headerlink" title="Clustered index"></a>Clustered index</h3><p>聚簇索引，数据提早物化，已经放到B+树里面中，查询数据后不需要回表</p><p>B+树的数据结点和文件页是一一关联的，每一个叶子结点的数据，和文件页里面的tuple是一一关联的</p><img src="\medias\09-Sorting-Aggregations\clustered index.png" style="zoom:150%;"><br><br><h3 id="Unclustered-index"><a href="#Unclustered-index" class="headerlink" title="Unclustered index"></a>Unclustered index</h3><p>非聚簇索引，数据延迟物化，只记录行id，查询数据后需要用id进行回表</p><p>随机IO的次数可能会因为回表而变多</p><p>叶子结点的内容和数据页文件本身是不关联的</p><img src="\medias\09-Sorting-Aggregations\unclustered index.png" style="zoom:150%;"><br><br><br><h1 id="Aggregations"><a href="#Aggregations" class="headerlink" title="Aggregations"></a>Aggregations</h1><p>将多个元组<strong>聚合</strong>为单个标量值</p><p>主流的方式是<strong>排序</strong>和<strong>哈希</strong></p><br><br><h2 id="Sort-aggregation"><a href="#Sort-aggregation" class="headerlink" title="Sort aggregation"></a>Sort aggregation</h2><p>将数据过滤后，对数据进行排序，然后聚合去重</p><img src="\medias\09-Sorting-Aggregations\sorting aggregation.png" style="zoom: 150%;"><p>如果SQL语句不要求对原数据进行排序，那么这种方法的时间复杂度就会偏高</p><ul><li>比如说group by分组，不需要排序</li><li>比如说distinct中的重复项，也不需要排序</li></ul><br><p>因此，在上述情况下，hash aggregation是一个更好的选择：</p><ul><li>只删除重复的数据</li><li>比排序更加的高效</li></ul><br><br><h2 id="Hash-aggregation"><a href="#Hash-aggregation" class="headerlink" title="Hash aggregation"></a>Hash aggregation</h2><p>执行Hash aggregation的两个目的：</p><ul><li>DISTINCT：对原数据进行<strong>去重</strong></li><li>GROUP BY：对原数据进行<strong>聚集</strong></li></ul><img src="\medias\09-Sorting-Aggregations\external hashing aggregate.png" style="zoom:150%;"><br><br><h3 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h3><p>利用hash函数将数据进行划分（这里假设数据量非常大，因此需要将部分数据先写入磁盘中）</p><img src="\medias\09-Sorting-Aggregations\hash partition.png" style="zoom:150%;"><p>假设总共有B个buffer page，那么就将B-1个page作为分区，1个用于输入数据的缓冲区</p><p>使用哈希函数h1将元组拆分为磁盘上的分区，把所有相同hash值都位于同一分区中</p><p>最后将数据按照分区放到磁盘中（落盘的时候可以做一些优化，比如说把重复的数据给删除）</p><img src="\medias\09-Sorting-Aggregations\hash_partition.png" style="zoom: 150%;"><br><br><h3 id="Rehash"><a href="#Rehash" class="headerlink" title="Rehash"></a>Rehash</h3><p>为每个分区建立内存哈希表并计算聚合</p><ul><li>为什么这里还需要rehash，因为上一个阶段的hash1可能发生哈希碰撞，因此需要rehash</li></ul><img src="\medias\09-Sorting-Aggregations\hash rehash.png" style="zoom:150%;"><p>把每个分区得数据都读到内存中（假设每个分区都适合内存），再进行以此rehash，就可以把第一次发生碰撞的值给找出来</p><p>对于磁盘上的每个分区，将其读入内存并构建内存哈希表（基于第二个哈希函数h2，h2适用于将数据按照指定条件分割）</p><p>然后遍历该hash的bucket以匹配元组</p><img src="\medias\09-Sorting-Aggregations\hash_rehash.png" style="zoom: 150%;"><br><br><h3 id="Hash-summarization"><a href="#Hash-summarization" class="headerlink" title="Hash summarization"></a>Hash summarization</h3><p>存在一些场景，需要对数据进行sum、max、min，或avg的运算</p><p>所以在Rehash阶段中的hash2函数（第二个hash函数），应该存入的是一个kv对</p><img src="\medias\09-Sorting-Aggregations\hash summarization.png" style="zoom: 150%;"><br><br><br><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>对于Sort，Aggreagation，并没有说哪一种方法更好，只能说看情况选择合适的方法</p><ul><li>如果数据本身就已经排好序了，那么就用Sort进行Aggreagtions即可</li></ul><br><p>Sort排序时的一些优化思路：</p><ul><li>把多个文件页组成文件块</li><li>尽量将随机IO变为顺序IO</li><li>提前预读数据（pre read）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> CMU 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 23-Distributed OLAP Databases</title>
      <link href="/2022/12/19/cmu-15-445-23-distributed-olap-databases/"/>
      <url>/2022/12/19/cmu-15-445-23-distributed-olap-databases/</url>
      
        <content type="html"><![CDATA[<h1 id="Decision-support-systems"><a href="#Decision-support-systems" class="headerlink" title="Decision support systems"></a>Decision support systems</h1><p>决策支持型数据库</p><p>分析当前的数据，以便对未来公司的发展做预计，帮助公司做商业决策</p><p>在这种AP型的数据库中，数据（表）的结构分为以下两种：<code>star schema</code>和<code>snowflake schema</code></p><br><h2 id="Star-schema"><a href="#Star-schema" class="headerlink" title="Star schema"></a>Star schema</h2><p>星型结构，一张主表被若干张维度表包围</p><p>数据的每一个维度都可以抽象出一张表，然后和主表的外键相连（不同维度之间没有关联）</p><img src="/medias/23-Distributed-OLAP-Databases\star schema.png" style="zoom:150%;"><br><p>优点：查询时更加迅速（相比Snowflake schema，因为不会造成过多表的join）</p><br><p>缺点：造成<strong>数据的冗杂</strong></p><p>可能每个同种类型的产品，都有相同的字段，如果对于每个产品都需要写入这个相同的字段，就会造成数据的冗余</p><ul><li>解决方案：用一个新的数据表记录每个类型的产品，然后用一个外键与其相连，以此减少数据的冗余</li></ul><br><p>造成<strong>数据类型不一致</strong></p><p>比如说针对产品属于哪一种类型，有些人可能会写入低端，而有些人可能会写入low，导致数据类型的不统一</p><ul><li>解决方案：和上面一样，用一个新的数据表记录，再用外键连接</li></ul><br><br><h2 id="Snowflake-schema"><a href="#Snowflake-schema" class="headerlink" title="Snowflake schema"></a>Snowflake schema</h2><p>雪花模型是在基于星型模型之上拓展来的，每一个维度可以再扩散出更多的维度，根据维度的层级拆分成颗粒度不同的多张表</p><img src="/medias/23-Distributed-OLAP-Databases\snowflake schema.png" style="zoom:150%;"><br><p>优点：减少维度表的数据量；占用更少的存储空间（不需要存储冗余的数据）</p><br><p>缺点：需要额外维护更多的维度表（导致join的查询上需要多表连接，查询效率低下）</p><br><br><br><h1 id="Execution-Models"><a href="#Execution-Models" class="headerlink" title="Execution Models"></a>Execution Models</h1><br><h2 id="Push-query-to-data"><a href="#Push-query-to-data" class="headerlink" title="Push query to data"></a>Push query to data</h2><p>将查询发送给带有数据的节点（<code>shared nothing架构</code>）</p><p>数据节点尽量在本地对数据进行一些过滤的操作，最后再将结果合并统一</p><p>数据在哪儿，就将查询发送到对应的节点上</p><br><p>比如说这里的查询，会将查询的操作传给每一个有对应数据的节点上</p><img src="/medias/23-Distributed-OLAP-Databases\push query to data.png" style="zoom:150%;"><br><br><h2 id="Pull-data-to-query"><a href="#Pull-data-to-query" class="headerlink" title="Pull data to query"></a>Pull data to query</h2><p>将数据传输到需要执行查询的节点上（<code>shared disked架构</code>）</p><p>节点需要什么数据，就拉取什么数据进行查询</p><br><p>每一个节点需要查询的范围不同，因此节点向Storage拉去的数据也都各不相同</p><img src="/medias/23-Distributed-OLAP-Databases\pull data to query_01.png" style="zoom:150%;"><br><br><h2 id="Observation"><a href="#Observation" class="headerlink" title="Observation"></a>Observation</h2><p>从其他节点获取的数据和DBMS查询的中间临时结果都存储在缓冲池中</p><p>但是如果发生了崩溃，中间临时结果则会丢失</p><p>那么DBMS该如何处理这种情况呢？</p><br><br><h2 id="Query-fault-tolerance"><a href="#Query-fault-tolerance" class="headerlink" title="Query fault tolerance"></a>Query fault tolerance</h2><p>在大部分的<code>share nothing</code>架构的分布式OLAP中，都是假定执行期间事务是不会失败的</p><ul><li>因为一旦有一个节点失败了，那么整个查询都会失败，此时只需要重新查询即可</li></ul><br><p>因此，可以让DBMS在查询执行的过程中保留中间结果的快照，以便在节点崩溃的时候进行恢复</p><br><p>例如下面的查询，会将临时查询得到的数据存储在Storage中</p><img src="/medias/23-Distributed-OLAP-Databases\query fault tolerance_01.png" style="zoom:150%;"><br><p>那么即使后面该节点崩溃了，其他节点也可以去Storage上读取中间结果，而不用从头再开始查一次</p><img src="/medias/23-Distributed-OLAP-Databases\query fault tolerance_02.png" style="zoom:150%;"><br><p>一般来说用这种方式的数据库比较少</p><p>这种机制有点像Flink中的checkpoint</p><br><br><br><h1 id="Query-Planning"><a href="#Query-Planning" class="headerlink" title="Query Planning"></a>Query Planning</h1><p>在分布式OLTP的场景下，查询语句并不复杂，中间数据并不多，涉及到的数据量也不多，不需要太多的如何进行查询计划</p><p>但是在分布式OLAP的场景下，长时间海量的查询，多表查询，再加上数据的不同分布，需要考虑如何进行数据的查询</p><br><p>此前在单节点的DBMS中的一些查询优化，依然适用于分布式环境：</p><ul><li>谓词下推</li><li>数据的早物化或晚物化</li><li>join顺序的排序</li></ul><br><p>而分布式情况下，更加困难的是：</p><ul><li>数据都存放在不同的节点上</li><li>同时还要考虑网络传输的成本</li></ul><br><h2 id="Physical-operators"><a href="#Physical-operators" class="headerlink" title="Physical operators"></a>Physical operators</h2><p>将SQL的语句转化为物理查询计划，即若干个查询算子</p><p>然后将查询算子拆分为几个小节，让不同的节点去执行</p><p>是最多DBMS使用的方法</p><br><br><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><p>将SQL语句，从字符串的角度切分为不同的节点</p><p>然后让不同的节点去执行（不同的节点对SQL语句进行解析和优化）</p><p>基本上没有DBMS使用这种方法</p><img src="/medias/23-Distributed-OLAP-Databases\SQL.png" style="zoom:150%;"><br><br><h2 id="Observation-1"><a href="#Observation-1" class="headerlink" title="Observation"></a>Observation</h2><p>其实，分布式的join查询效率高度依赖于数据表的分区情况</p><p>因此，分布式OLAP的查询计划，需要根据数据的不同分区，进行不同的处理</p><br><p>最简单的方法就是将整张表的数据都放到同一个节点，然后执行join操作</p><p>但，一方面这会导致分布式DBMS失去并行性</p><p>而另一方面，大量数据在网络中传输，开销巨大的同时，传输效率也会降低</p><br><br><br><h1 id="Distributed-Join-Algorithms"><a href="#Distributed-Join-Algorithms" class="headerlink" title="Distributed Join Algorithms"></a>Distributed Join Algorithms</h1><p>分布式OLAT的join算法</p><p>比如说要连接表R和表S的数据，那么DBMS需要做的</p><p>是基于当前节点已有的数据，将当前节点中可以进行join的部分进行join（而不再是像此前，将所有的数据都集中进行join）</p><br><p>当相应的数据元组到达了同一个节点上，就可以使用此前单机DBMS中的join算法了</p><br><p>下面列举两个表（表R和表S）进行join的情况：</p><p>需要执行的SQL：<code>SELECT *FROM R JOIN S ON R.id = S.id</code></p><br><br><h2 id="Scenario-01"><a href="#Scenario-01" class="headerlink" title="Scenario 01"></a>Scenario 01</h2><p>表R的数据是根据id（目标列；查询列）进行分区的，而表S的数据是每个节点都有表S中所有的数据（即每个节点都有表S的副本）</p><img src="/medias/23-Distributed-OLAP-Databases\scenario 01_01.png" style="zoom:150%;"><br><p>这种情况下的join是比较简单的，因为只需要在每个节点中</p><p>将每个节点所持有的R表的数据和S表的数据进行join，得到结果</p><p>然后再将每个节点的结果汇总在一起，便是查询的最终结果</p><img src="/medias/23-Distributed-OLAP-Databases\scenario 01_02.png" style="zoom:150%;"><br><br><h2 id="Scenario-02"><a href="#Scenario-02" class="headerlink" title="Scenario 02"></a>Scenario 02</h2><p>表R和表S的数据都是按照id（目标列；查询列）进行分区的，并且分区的数据范围都是相同的</p><img src="/medias/23-Distributed-OLAP-Databases\scenario 02_01.png" style="zoom:150%;"><br><p>只需要在每个节点上完成join的操作，最后汇总在一起就是最终结果</p><img src="/medias/23-Distributed-OLAP-Databases\scenario 02_02.png" style="zoom:150%;"><p>PS：如果每个分区的数据范围是不一致的话，对于每个节点的join</p><p>就需要强制将对应范围内的数据预先复制一份到本地，然后再进行操作</p><br><br><h2 id="Scenario-03"><a href="#Scenario-03" class="headerlink" title="Scenario 03"></a>Scenario 03</h2><p>表R的数据是按照id（目标列；查询列）进行分区的，而表S的数据则是按照Val（非查询列）进行分区的</p><img src="/medias/23-Distributed-OLAP-Databases\scenario 03_01.png" style="zoom:150%;"><br><p>此时对于每个节点的join操作，都需要从其他节点的位置，获取整个表S的副本</p><p>然后再进行操作，最后将结果汇总</p><img src="/medias/23-Distributed-OLAP-Databases\scenario 03_02.png" style="zoom:150%;"><br><br><h2 id="Scenario-04"><a href="#Scenario-04" class="headerlink" title="Scenario 04"></a>Scenario 04</h2><p>表S和表R都不按照id（目标列；查询列）进行分区</p><img src="/medias/23-Distributed-OLAP-Databases\scenario 04_01.png" style="zoom:150%;"><br><p>这种情况是最麻烦的，需要转化为Scenario 01的情况</p><p>对于每个节点，都需要先指定当前节点需要处理的数据</p><p>比如节点1需要处理id在1-100范围内的数据，节点2需要处理id在101-200范围内的数据</p><p>然后将划分好范围内的数据，迁移到指定的节点上</p><p>然后变化为Scenario 01的情况</p><img src="/medias/23-Distributed-OLAP-Databases\scenario 04_02.png" style="zoom:150%;"><br><br><h2 id="Semi-join"><a href="#Semi-join" class="headerlink" title="Semi-join"></a>Semi-join</h2><p>半连接（查询的结果只需要左表上的数据列）</p><p>很朴素的思路：检测左半边的数据是否可以和右半边的数据进行连接；如果可以，就保留左半边的数据</p><p>例子：<code>SELECT R.id FROM R JOIN S ON R.id = S.id WHERE R.id IS NOT NULL</code></p><br><p>有些DBMS是支持<code>SEMI JOIN</code>的语法的，如果不支持的话可以换为<code>EXISTS</code></p><p>上述语句可以替换为下述查询：</p><img src="/medias/23-Distributed-OLAP-Databases\semi-join_02.png" style="zoom:150%;"><br><p>针对上述这种朴素的思想，可以进一步的优化：</p><p>只传输需要查询的那一部分数据（比如这里只传输R表的id列），而不用将整个表都传输</p><img src="/medias/23-Distributed-OLAP-Databases/semi-join_03.png" style="zoom:150%;"><br><br><br><h1 id="Cloud-Systems"><a href="#Cloud-Systems" class="headerlink" title="Cloud Systems"></a>Cloud Systems</h1><p>越来越多的数据库厂商提供数据库产品服务，即<code>DBaaS</code></p><p>可以理解为，将数据库和数据库运行的具体环境（CPU、存储、硬盘等）打包</p><p>然后给用户提供使用该产品的接口（比如说可能是一个ip地址）</p><p>客户可以直接在这个ip地址上对DBMS进行操作</p><br><p>而另一方面，<code>shared-nothing</code>和<code>shared-disk</code>，这二者的界限也因为数据库的云化而变得逐渐模糊</p><p>比如说我们买一个虚拟服务器，但这个服务器上的硬盘可能也是厂商虚拟出来的（不存在CPU、内存和硬盘在同一个物理机上的情况）</p><p>而厂商的实现手段可能是<code>shared-disk</code>架构，即存算分离（虚拟出多个硬盘、CPU等资源）</p><p>使得用户好像是在使用<code>shared-nothing</code>架构一样</p><p>PS：现在很多厂商都在将原有的<code>shared-nothing</code>架构转向<code>shared-disk</code>架构</p><br><p>云厂商的数据库可以提供更加丰富的服务，比如说Amazon S3</p><p>可以在存储层对数据进行过滤，即在云的场景下，存储层可以实现更加丰富的功能</p><br><br><h2 id="Managed-DBMS"><a href="#Managed-DBMS" class="headerlink" title="Managed DBMS"></a>Managed DBMS</h2><p>DBMS的设计理念上保持不变，而是让传统的DBMS在云环境上运行</p><p>并将DBMS和其运行的云端环境打包，以此作为软件产品，对外提供服务（比如腾讯云、阿里云等）</p><p>可以理解为是将传统的DBMS是运行在云厂商的虚拟环境上</p><br><p>这种类型价格便宜，适合刚刚转向云端的厂商</p><br><br><h2 id="Cloud-Native-DBMS"><a href="#Cloud-Native-DBMS" class="headerlink" title="Cloud-Native DBMS"></a>Cloud-Native DBMS</h2><p>这种类型的DBMS从设计之初就是为了能够运行在云环境中的</p><p>首选<code>shared-disk</code>架构（主要是存算分离、方便扩容）</p><p>比如SnowFlake，Google BigQuery，Amazon Redshift，Microsoft SQL Azure</p><br><br><h2 id="Serverless-Databases"><a href="#Serverless-Databases" class="headerlink" title="Serverless Databases"></a>Serverless Databases</h2><p>在此之前，云厂商的客户都是一致使用着服务器等资源，无论此时服务器上是否有工作需要运行</p><p>而serverless DBMS，会根据服务器上的工作负载，动态的调度资源</p><br><p>无服务器，可以理解为客户使用的存储资源和计算资源都不是客户单独一人占有的</p><p>是从一个较大的存储缓冲池或是计算缓冲池中抽离出来的</p><p>当客户不再需要的时候又会归还回去</p><br><br><h2 id="Disaggregated-componsents"><a href="#Disaggregated-componsents" class="headerlink" title="Disaggregated componsents"></a>Disaggregated componsents</h2><p>可以像组装玩具一样，利用不同的插件，根据需求，满足不同数据库的需求</p><img src="/medias/23-Distributed-OLAP-Databases/disaggregated components.png" style="zoom:150%;"><br><br><h2 id="Universal-formats"><a href="#Universal-formats" class="headerlink" title="Universal formats"></a>Universal formats</h2><p>很多数据库之间的互通，一个比较难处理的事情就是数据页格式的不同</p><p>而不同系统之间，数据的传输，很多都是依赖于CSV，JSON，XML等文件格式</p><p>当然，也有一些致力于解决这些问题的开源项目</p><img src="/medias/23-Distributed-OLAP-Databases/universal formats.png" style="zoom:150%;">]]></content>
      
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> CMU 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 22-Distributed OLTP Databases</title>
      <link href="/2022/12/19/cmu-15-445-22-distributed-oltp-databases/"/>
      <url>/2022/12/19/cmu-15-445-22-distributed-oltp-databases/</url>
      
        <content type="html"><![CDATA[<h1 id="OLTP-vs-OLAP"><a href="#OLTP-vs-OLAP" class="headerlink" title="OLTP vs OLAP"></a>OLTP vs OLAP</h1><h2 id="On-line-transaction-processing（OLTP）"><a href="#On-line-transaction-processing（OLTP）" class="headerlink" title="On-line transaction processing（OLTP）"></a>On-line transaction processing（OLTP）</h2><p>事务的流程较短、语句较少、涉及数据的读写操作（可能写数据的情况会多一些）</p><p>一般来说，每个事务对整体数据的影响都很小</p><p>存在大量重复性的小事务</p><br><br><h2 id="On-line-analytical-processing（OLAP）"><a href="#On-line-analytical-processing（OLAP）" class="headerlink" title="On-line analytical processing（OLAP）"></a>On-line analytical processing（OLAP）</h2><p>事务的流程较长、语句较多、大部分是只读操作</p><p>语句中有非常复杂的join操作</p><p>大部分用于数据分析的场景</p><br><br><br><h1 id="Decentralized-coordinator"><a href="#Decentralized-coordinator" class="headerlink" title="Decentralized coordinator"></a>Decentralized coordinator</h1><p>中心化的协调思想</p><p>应用先向主节点（primary node）发送事务开始的请求（begin request）</p><img src="/medias/22-Distributed-OLTP-Databases\decentralized coordinator_01.png" style="zoom:150%;"><br><p>然后，应用可以去各个节点对数据进行查询</p><img src="/medias/22-Distributed-OLTP-Databases\decentralized coordinator_02.png" style="zoom:150%;"><br><p>当事务结束以后，应用需要再给主节点（primary node）发送一个commit request的请求</p><p>然后主节点（primary node）需要去各个节点判断，事务是否可以在本节点上安全的提交</p><img src="/medias/22-Distributed-OLTP-Databases\decentralized coordinator_03.png" style="zoom:150%;"><br><br><h2 id="Observation"><a href="#Observation" class="headerlink" title="Observation"></a>Observation</h2><p>但，这种场景下没有讨论如何确保所有的节点都能够成功的提交事务</p><p>比如说：</p><p>如果单个副节点的提交失败了，该如何处理？</p><p>节点直接的通信发生了严重的延迟，该如何处理？（rpc调用延迟过长）</p><p>不想等待所有的节点都同意再提交，该怎么处理？（可能有些节点需要很长时间才能够将事务提交）</p><br><br><br><h1 id="Important-assumption"><a href="#Important-assumption" class="headerlink" title="Important assumption"></a>Important assumption</h1><p>数据节点分布在全世界，而这里要假设每个节点的DBMS是正常工作的（是善意的），是可控的（是在可以管理的情况下的）</p><p>也就是说，数据节点不会被黑客攻击</p><br><p>因此，这里讨论的分布式数据库暂时不考虑<strong>拜占庭问题</strong></p><br><p>PS：类似区块链这种场景，可以理解为是一个分布式数据库</p><p>但是每个节点的信息是不可靠的（因为每个节点都是由不同的人或机构组成的，互相之间是不可信的）</p><p>因此在区块链的场景下，需要更加复杂的共识算法去实现共识机制，去解决拜占庭问题（比如工作量证明等）</p><br><br><br><h1 id="Atomic-commit-protocol"><a href="#Atomic-commit-protocol" class="headerlink" title="Atomic commit protocol"></a>Atomic commit protocol</h1><p>当一个多节点事务完成后，DBMS需要了解各个节点是否都是安全可提交的</p><p>因此为了实现分布式数据库中的原子提交，可以使用以下协议去实现：</p><img src="/medias/22-Distributed-OLTP-Databases\atomic commit protocol.png" style="zoom:150%;"><br><br><h2 id="Two-phase-commit"><a href="#Two-phase-commit" class="headerlink" title="Two-phase commit"></a>Two-phase commit</h2><p>2PC分为两个部分：<strong>准备阶段</strong>（prepare）和<strong>提交阶段</strong>（commit）</p><br><br><h3 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h3><p>首先接收到应用commit request的节点会变为协调者（coordinator）</p><p>而其他的节点会变为参与者（participant）</p><p>协调者首先会向参与者发送确认请求，让参与者确认本次事务的修改是否是合理正确的</p><p>如果是，就会回复ok</p><img src="/medias/22-Distributed-OLTP-Databases\2PC_01.png" style="zoom:150%;"><br><br><p>但如果不是，那么参与者（participant）就会回复abort，并进入abort阶段</p><img src="/medias/22-Distributed-OLTP-Databases\2PC_04.png" style="zoom:150%;"><br><br><h3 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h3><p>在收到参与者的回复（ok）之后，协调者就明白当前事务在其他各个节点上都是安全可提交的</p><p>接着进入commit阶段</p><p>此时协调者会再向参与者发送一个commit请求，参与者就会在本地提交当前的事务</p><p>提交成功后会回复ok</p><img src="/medias/22-Distributed-OLTP-Databases\2PC_02.png" style="zoom:150%;"><br><br><p>此时，事务提交成功，并会给应用层返回信息</p><p><img src="/medias/22-Distributed-OLTP-Databases%5C2PC_03.png"></p><br><br><h3 id="Abort"><a href="#Abort" class="headerlink" title="Abort"></a>Abort</h3><p>进入abort阶段后，协调者会发送abort请求给参与者</p><p>告知参与者事务需要取消回滚</p><p>参与者回复ok之后，协调者就会给应用层返回abort请求</p><p><img src="/medias/22-Distributed-OLTP-Databases%5C2PC_05.png"></p><br><br><h3 id="Optimizations"><a href="#Optimizations" class="headerlink" title="Optimizations"></a>Optimizations</h3><p>2PC的两个优化方向</p><p><strong>Early prepare voting</strong></p><p>如果已知某个查询语句是事务中的最后一个语句，那么就可以将这个语句和commit request一并发送给coordinator协调者</p><p>而不是将语句和commit request分开发送</p><p>一并发送后可以提前开始投票，即提前开始prepare阶段</p><br><p><strong>Early acknowledgement after prepare</strong></p><p>在prepare阶段收到所有节点的同意的时候，就可以提前告知用户事务commit success</p><p>而不是等到commit阶段结束后再告诉用户（有点像异步IO）</p><img src="/medias/22-Distributed-OLTP-Databases\early acknowledgement.png" style="zoom:150%;"><p>但是这种方法也有缺点，比如说返回成功以后集群断电了，就可能造成数据的丢失</p><br><br><h3 id="question"><a href="#question" class="headerlink" title="question"></a>question</h3><p>如果2PC过程中，协调者发生了崩溃，那么参与者该如何处理？</p><p>答：有可能此时参与者还在执行着一部分事务，所以此时需要参与者将事务进行回滚</p><br><p>如果2PC过程中，参与者发生了崩溃，那么协调者该如何处理？（或者说发送的请求因为网络等其他原因，导致参与者没有接收到）</p><p>答：那么此时，协调者会认为该参与者是不同意该事务的发生的，默认它返回的是abort</p><br><br><h2 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h2><p>Paxos或Raft，其实本质上是一个<strong>共识机制</strong>，或者是一个<strong>一致性协议</strong></p><p>通过投票机制，取得大部分人的共识，选出一个大部分人都认可的决策</p><p>如果一个集群中大部分的参与者（都是正常可用的）都同意某个决定，那么全体成员就都需要执行这个决定</p><p>这里的大部分，一般是指一半的参与者</p><br><br><h3 id="单个事务的Paxos"><a href="#单个事务的Paxos" class="headerlink" title="单个事务的Paxos"></a>单个事务的Paxos</h3><p>在Paxos中，分为提议人（Proposer）和接收者（Acceptor）</p><p>收到应用commit request的就是提议人</p><p>首先，proposer收到应用的commit request，系统就会进入propose阶段</p><p>proposer会提出提案，即要将当前的事务提交</p><p>acceptor就会评估proposer给出的提案是否可以提交，如果能够提交，就会回复一个agree</p><img src="/medias/22-Distributed-OLTP-Databases\Paxos_01.png" style="zoom:150%;"><br><br><p>在收到acceptor的回复以后，如果有<strong>超过一半</strong>的acceptor都同意这个提案</p><p>接下来就会进入commit阶段</p><p>proposer会发指令让所有的acceptor都同意这个提案</p><p>最后，acceptor执行完之后，会再给proposer发送一个accept</p><img src="/medias/22-Distributed-OLTP-Databases\Paxos_02.png" style="zoom:150%;"><br><br><p>面对那些处于崩溃状态的节点（acceptor），proposer会持续不断地向其发送信息</p><p>直到该节点接受这条信息</p><br><br><h3 id="多个事务的Paxos"><a href="#多个事务的Paxos" class="headerlink" title="多个事务的Paxos"></a>多个事务的Paxos</h3><p>一开始进来的是事务n，此时的事务n完成了propose阶段</p><p>而此时又来了一个事务n+1，开始了它的第一阶段propose阶段</p><p>而Paxos为了要实现可串行化，因此就会要将原来的事务n给reject</p><p>所以acceptors就会给事务n的proposer一个reject</p><p>然后继续原来事务n+1的流程</p><img src="/medias/22-Distributed-OLTP-Databases\Paxos_03.png" style="zoom:150%;"><br><br><p>其实Paxos更多的是做<strong>副本分发的一致性</strong>，用于做事务的协调是很少的（基本没有）</p><br><br><h2 id="Multi-paxos"><a href="#Multi-paxos" class="headerlink" title="Multi-paxos"></a>Multi-paxos</h2><p>如果系统内部可以选举出一个单独的proposer，相比Paxos，那么就可以跳过Propose的过程</p><p>缺点：如果这个proposer挂了的话，就会导致系统的崩溃</p><br><p>因此，为了维护这个proposer，系统会周期性的维护这个proposer，即每隔一段时间就会选举出一个新的proposer</p><p>这种每隔一段时间选取出一个新的leader的机制在Raft中名为<strong>租约</strong></p><br><br><h2 id="2PC-vs-Paxos"><a href="#2PC-vs-Paxos" class="headerlink" title="2PC vs Paxos"></a>2PC vs Paxos</h2><p>在2PC，如果协调者或是接受者宕机了，整个系统都会无法运作</p><p>在Paxos，只要大多数的参与节点不会宕机（指一半），系统都是可以运作的</p><br><br><h1 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h1><h2 id="Replica-configurations"><a href="#Replica-configurations" class="headerlink" title="Replica configurations"></a>Replica configurations</h2><p>副本的架构</p><br><br><h3 id="Primary-replica"><a href="#Primary-replica" class="headerlink" title="Primary-replica"></a>Primary-replica</h3><p>主备模式</p><p>对于数据的操作，一般都需要在主节点上操作</p><p>主节点可以在没有原子提交的情况下（指可以只在主节点上操作，不需要多节点协调），通过log的方式将数据分发给备节点</p><p>对于只读操作，可以在备节点中进行</p><p>如果主节点崩溃了，那么就会在其余的备节点中选举出一个新的节点</p><p>主备模式是副本架构中运用<strong>最多</strong>的一种方式</p><br><p>主节点用于数据的读写</p><p>备节点用于做数据的备份、主节点崩溃时选取备节点当主节点、当需要查看线上数据的时候可以用备节点查看</p><p>比如说一些小公司，对于数据的分析，很多都是读取备节点上的数据</p><img src="/medias/22-Distributed-OLTP-Databases\primary-replica.png" style="zoom:150%;"><br><br><h3 id="Multi-primary"><a href="#Multi-primary" class="headerlink" title="Multi-primary"></a>Multi-primary</h3><p>多主模式</p><p>任何一个节点都是主节点，因此对于数据的操作可以在任何一个节点上执行</p><p>也正因如此，多个主节点之间需要频繁的同步数据，尤其是出现矛盾的时候，更加难以处理</p><p>因此需要原子提交协议的支持（多个主节点，2PC提交）</p><br><img src="/medias/22-Distributed-OLTP-Databases\multi-primary.png" style="zoom:150%;"><br><br><h3 id="K-safety"><a href="#K-safety" class="headerlink" title="K-safety"></a>K-safety</h3><p>需要保证线上的数据始终保持至少有k份</p><p>可以理解为这个叫作安全度，也就是说如果线上的数据数量少于这个，就不能够对外提供服务</p><p>比如说主备模式中，要始终保持线上的数据有2份</p><p>如果少于2份，就必须停止服务（这里可以理解为此时只有1份了，即主节点的数据，那么备节点就没有数据了，相当于备份失效）</p><br><br><h2 id="Propagation-scheme"><a href="#Propagation-scheme" class="headerlink" title="Propagation scheme"></a>Propagation scheme</h2><p>主节点的数据如何同步到其他节点上</p><br><h3 id="Synchronous"><a href="#Synchronous" class="headerlink" title="Synchronous"></a>Synchronous</h3><p>同步（强一致性）</p><p>当向主节点提交数据的时候，系统会强制将此时的数据同步到其他节点上（因此会造成延迟）</p><p>只有主节点和副节点都提交成功了以后，才会返回给用户（不仅仅是日志要到副节点上，而且副节点还要执行完这个日志才返回）</p><p>一般主节点使用log与副节点进行同步（比如mysql的binlog）</p><p>缺点：存在时延，需要多个节点一起同步</p><img src="/medias/22-Distributed-OLTP-Databases\synchronous.png" style="zoom:150%;"><br><br><h3 id="Asynchronous"><a href="#Asynchronous" class="headerlink" title="Asynchronous"></a>Asynchronous</h3><p>异步（最终一致性）</p><p>当主节点操作完数据以后，便立刻返回给用户，表示数据的操作成功了</p><p>将数据同步到备节点上的操作，后续再执行</p><p>缺点：如果后续数据同步的过程中，DBMS宕机了，就会造成数据的丢失</p><img src="/medias/22-Distributed-OLTP-Databases\asynchronous.png" style="zoom:150%;"><br><br><p>Mysql使用的是半同步半异步的方案：</p><p>主节点将日志传给备节点，然后当<strong>日志传输成功后</strong>，就返回给主节点，留着备节点慢慢执行</p><br><br><h2 id="Propagation-timing"><a href="#Propagation-timing" class="headerlink" title="Propagation timing"></a>Propagation timing</h2><p>数据传输的时机问题</p><h3 id="Continuous"><a href="#Continuous" class="headerlink" title="Continuous"></a>Continuous</h3><p>主节点不断地将数据传播给备节点，用户发一条SQL，主节点就发一条SQL给备节点</p><p>最后还需要将commit&#x2F;abort的信息发送给备节点</p><br><p>缺点：如果发生了回滚，那么主备节点都需要一起回滚（复杂度高）</p><br><br><h3 id="On-commit"><a href="#On-commit" class="headerlink" title="On commit"></a>On commit</h3><p>平常的时候不会将操作SQL传给备节点</p><p>只有事务真正提交的时候，才会将SQL传给备节点</p><br><p>优点：回滚上不会有很大问题；不会浪费时间在发送失败事务的日志记录上</p><p>缺点：最后事务提交的时候，需要发送日志，存在时间上的开销</p><p>并且，如果事务的SQL太多的话，主节点本地就需要存储大量的日志，浪费空间</p><br><br><h2 id="Active-vs-Passive"><a href="#Active-vs-Passive" class="headerlink" title="Active vs Passive"></a>Active vs Passive</h2><h3 id="Active-active"><a href="#Active-active" class="headerlink" title="Active-active"></a>Active-active</h3><p>主备同步的时候，主节点传递的是SQL，因此SQL还需要在备节点上再执行一遍</p><p>即SQL需要在每个节点上单独执行一遍</p><p>最后，还要检查事务是否在每个副本中都得到了相同的结果</p><p>缺点：SQL会被不同的节点重复执行</p><br><br><h3 id="Active-Passive"><a href="#Active-Passive" class="headerlink" title="Active-Passive"></a>Active-Passive</h3><p>主备同步的时候，主节点先将SQL执行一遍</p><p>记录到底需要修改哪些数据，并记录成日志</p><p>然后再将日志传递给备节点</p><br><br><p>PS：此前说的数据，都是数据未分片的例子</p><p>而实际上，此前的做法也是可以用于数据分片的情况的</p><p>比如说主备模式，</p><p>节点A可以做数据1的主数据库、数据2的备数据库</p><p>节点B可以做数据2的备数据库、数据1的备数据库</p><p>那么操作数据1的时候，就得用节点A，然后同步到节点B</p><p>操作数据2的时候，就得用节点B，然后同步到节点A</p><br><br><br><h1 id="Consistency-issues（CAP）"><a href="#Consistency-issues（CAP）" class="headerlink" title="Consistency issues（CAP）"></a>Consistency issues（CAP）</h1><p><code>consistent</code>（<strong>一致性</strong>；线性一致性，最终一致性）</p><p><code>always available</code>（<strong>高可用</strong>；即使部分节点崩溃，也能对外提供服务）</p><p><code>network partition tolerant</code>（<strong>网络分区容忍</strong>；如果集群因为网络的断开，集群不会因此分裂为两个集群）</p><p><strong>三者不可能同时实现，最多同时实现其中两个</strong></p><img src="/medias/22-Distributed-OLTP-Databases\CAP.png" style="zoom:150%;"><br><p>为什么三者不能够同时实现？</p><br><p>比如说此时选择的是<strong>CP</strong>，那么在发生网络分区后</p><p>为了实现一致性和网络分区容忍性，我们就必须保证数据的读写都是在同一个数据中心上（一般名为<code>Leader</code>）</p><p>那么除去这个数据中心外的节点，就不能进行数据的读写，直到网络恢复后才能进行同步（<strong>违背了可用性</strong>）</p><br><p>或比如说此时选择的是<strong>AP</strong>，那么在发生网络分区后</p><p>为了实现一致性和可用性，就必须保证每个节点都是可以运行的（可以读写数据）</p><p>而网络的断开导致节点间无法同步数据，直到网络恢复后才能同步（<strong>违背了一致性</strong>）</p><br><p>再比如说此时选择的是<strong>CA</strong>，那么此时的方案就是每个数据节点都有单独的一份副本</p><p>数据更新的时候就需要通过网络进行同步</p><p>这可以保证一致性（都是从同一个节点读取数据）和可用性（每个节点都有数据）</p><p>但，因为数据不可以在节点间进行同步，导致系统不能够正常运行（<strong>违背了分区容错性</strong>）</p><br><br><h2 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h2><p>这里的一致性是<strong>强一致性</strong>（强调的是<strong>数据的正确性</strong>）</p><p><strong>一旦数据写入到了系统中，就能够立刻在任何一个节点上读到这个数据</strong>（强调操作的<strong>可线性化</strong>）</p><p>要么读到正确的数据，要么就返回读取错误（不存在读取错误数据的情况）</p><img src="/medias/22-Distributed-OLTP-Databases\consistency.png" style="zoom:150%;"><br><br><h2 id="Availability"><a href="#Availability" class="headerlink" title="Availability"></a>Availability</h2><p>高可用性（强调<strong>服务的可用性</strong>）</p><p>如果集群中的<strong>某个节点</strong>崩溃了，那么其他的应用节点依旧能够对外提供服务</p><p>DBMS一定会返回数据，但不保证数据的正确性和一致性</p><ul><li>服务不会出错</li><li>服务必定会返回数据，但不保证数据的正确性</li></ul><br><p>比如说这里的备用节点，在没崩溃之前都是访问备用节点的</p><p>备用节点崩溃后，应用可以访问主节点，使用上不受任何影响</p><img src="/medias/22-Distributed-OLTP-Databases\availability.png" style="zoom:150%;"><br><p>和网络分区容忍性相比，可用性更加侧重的是某个节点崩溃后，系统是否可以提供服务</p><p>而网络分区容忍性，更加注重的是网络崩溃后，系统是否可以正常运作</p><br><br><h2 id="Partition-tolerance"><a href="#Partition-tolerance" class="headerlink" title="Partition tolerance"></a>Partition tolerance</h2><p>网络分区容忍性（强调<strong>系统的正常运作</strong>）</p><p>如果发生了网络崩溃，节点之间不可通信（造成了网络分区）</p><p>在这种情况下，系统依然可以正常对外提供服务</p><br><p>比如以下这个例子，因为网络崩溃造成了网络分区</p><img src="/medias/22-Distributed-OLTP-Databases\partition tolerance_01.png" style="zoom:150%;"><br><p>那如果两个应用各自向主节点Primary提交修改相同数据的事务</p><p>因为都是主节点，所以修改是可以成功的，即可用性得到解决，但是一致性上却无法同步</p><img src="/medias/22-Distributed-OLTP-Databases\partition tolerance_02.png" style="zoom:150%;"><br><br><h2 id="CAP-for-OLTP-DBMS"><a href="#CAP-for-OLTP-DBMS" class="headerlink" title="CAP for OLTP DBMS"></a>CAP for OLTP DBMS</h2><p>对于传统型数据库，或者是NewSQL型数据库：</p><p>如果崩溃的节点数量达到一定的阈值，那么整个数据库就会直接下线，不对外提供服务</p><p>即<strong>牺牲可用性，以此保证一致性和分区容忍性</strong>（CP）</p><br><p>但是对于一些NoSQL型数据库来说，会在分区的集群重新连接以后</p><p>判断那些不一致的数据，选取其中一部分并保留下来</p><br><br><br><h1 id="Federated-databases"><a href="#Federated-databases" class="headerlink" title="Federated databases"></a>Federated databases</h1><p>背景：</p><p>此前都假设分布式系统中的节点运行的都是相同的DBMS</p><p>但实际中可能是多种不同的DBMS同时使用</p><p>因此需要引入联邦数据库</p><br><p>但是，将多个DBMS连接在同一个分布式架构中，是一件非常困难的事情：</p><ul><li>不同数据库的数据模型不同，同时也受查询语言的限制（SQL其实并不统一）</li><li>很难去实现查询的优化</li><li>大量的数据复制</li></ul><br><br><p>一种较为好的方案就是利用PostgreSQL（Pg可以存储不同的数据模型）</p><p>利用Pg作为中间件（服务端），连接各个不同类型的数据库</p><img src="/medias/22-Distributed-OLTP-Databases\federated database example.png" style="zoom:150%;"><br><br><p>还有一个在国内实践上比较多的办法：</p><p>因为国内很多企业用的都是MySQL</p><p>而很多数据库都可以识别MySQL的log（比如flink、spark）</p><p>那么可以让一些其他类型的数据库作为备节点</p><p>让MySQL的主节点源源不断的发送log给备节点，并在本地解析它</p><br><p>一个比较常用的场景：日常使用的是TP型数据库，而需要用AP型数据库对数据进行分析</p><p>那么就可以让AP型数据库作为备节点，让主节点的TP数据库不断的向它发送日志</p><br><p>还有一种场景：</p><p>就是需要检查某个数据是否发生了变化，那么就可以将数据同步到其他的DBMS中，实现监听</p><p>（或者使用数据库的触发器）</p><br><br><br><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>上述的很多方案都是基于数据库节点本身是友好的</p><p>而区块链数据库都假设每个节点都是恶意的、都是对抗性极大的</p><p>因此需要使用更加复杂的协议来提交事务，以此实现DBMS的正确运行</p><br><br><br><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><p><a href="https://www.51cto.com/article/706373.html" target="_blank" rel="noopener">https://www.51cto.com/article/706373.html</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/528894934" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/528894934</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> CMU 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 21-Introduction To Distributed Databases</title>
      <link href="/2022/12/19/cmu-15-445-21-introduction-to-distributed-databases/"/>
      <url>/2022/12/19/cmu-15-445-21-introduction-to-distributed-databases/</url>
      
        <content type="html"><![CDATA[<h1 id="Parallel-vs-Distributed"><a href="#Parallel-vs-Distributed" class="headerlink" title="Parallel vs Distributed"></a>Parallel vs Distributed</h1><p>并行数据库和分布式数据库的区别</p><br><h2 id="Parallel-DBMS"><a href="#Parallel-DBMS" class="headerlink" title="Parallel DBMS"></a>Parallel DBMS</h2><p>多个节点在物理上是放在一起的（比如说是放在同一个机房中）</p><p>物理节点之间是通过高速的局域网连接的</p><p>节点之间的通信消耗是很小的，可以忽略不计的（光纤连接的）</p><p>比如说Oracle数据库集群之类的并行数据库集群</p><br><br><h2 id="Distributed-DBMS"><a href="#Distributed-DBMS" class="headerlink" title="Distributed DBMS"></a>Distributed DBMS</h2><p>多个节点在物理上不是放在一起的（存在一定距离，比如说一个在亚洲，另一个在欧洲）</p><p>节点之间是通过公网连接的</p><p>节点之间的通信的消耗是不可忽略的</p><br><p>针对单节点DBMS中的一些组件，是可以复用到distributed DBMS中的</p><p>比如说SQL的优化查询，分布式事务的并发控制，以及分布式数据库的日志及恢复</p><br><br><p>因此，当说到分布式数据库的时候，要分清到底是哪一种类型的DBMS</p><br><br><br><h1 id="System-architecture"><a href="#System-architecture" class="headerlink" title="System architecture"></a>System architecture</h1><p>在分布式DBMS中，可以指定CPU可以直接访问哪些共享资源</p><p>而指定的共享资源的范围，则直接影响CPU之间的协调、以及如何在DBMS中检索数据</p><br><h2 id="Shared-memory"><a href="#Shared-memory" class="headerlink" title="Shared memory"></a>Shared memory</h2><img src="/medias/21-Introduction-To-Distributed-Databases\shared memory.png" style="zoom:150%;"><br><p>CPU之间的分布式，即CPU之间通过network进行通信</p><p>而各个CPU都共享同一块内存和磁盘</p><p>每一个DBMS都知道对方的存在</p><p>如果CPU需要通过网络才能够操作内存的话，那么内存的优点就没有了</p><p>分布式数据库用的少，几乎没有</p><p>主要用在服务器上，即多路服务器（比如四路服务器，总共就有四个CPU，中间通过高速总线相连）</p><p>或超级计算器，多个核通过高速网络连接</p><br><br><h2 id="Shared-disk"><a href="#Shared-disk" class="headerlink" title="Shared disk"></a>Shared disk</h2><img src="/medias/21-Introduction-To-Distributed-Databases\shared disk.png" style="zoom:150%;"><br><img src="/medias/21-Introduction-To-Distributed-Databases\shared disk_02.png" style="zoom:150%;"><p>CPU和内存打包，单体之间用网络通信</p><p>节点间共享磁盘资源</p><br><p>优点：存算分离，计算能力和存储能力解耦（计算能力差加CPU，存储能力差加磁盘），无论存储还是计算都可以单独扩容</p><p>缺点：缓存一致性（即内存的同步）</p><ul><li>A节点更新了数据，但是没有实时刷盘，只是在本地的内存更新了，而B节点此时需要访问数据，那么就出现问题了</li><li>或者说，A节点将数据更新到了磁盘上，但是其他节点的缓存并没有更新，就会造成数据的不一致</li></ul><br><p>运用的非常广泛（主要是现在的数据库都开始走向云化，存算分离有利于扩容）</p><img src="/medias/21-Introduction-To-Distributed-Databases\shared disk_01.png" style="zoom:150%;"><br><br><h2 id="Shared-nothing"><a href="#Shared-nothing" class="headerlink" title="Shared nothing"></a>Shared nothing</h2><img src="/medias/21-Introduction-To-Distributed-Databases\shared nothing.png" style="zoom:150%;"><br><img src="/medias/21-Introduction-To-Distributed-Databases\shared nothing_01.png" style="zoom:150%;"><p>每一个DBMS都有自己的CPU、内存、硬盘</p><p>DBMS的节点之间只通过网络进行通信</p><br><p>优点：能够获得更好的性能（因为硬盘也是在本地，所以访问性能更快）</p><p>缺点：</p><ul><li><p>数据的一致性更难处理</p></li><li><p>没有办法独立的扩容（因为数据的存储和计算都是在同一个节点上；比如说新加一个硬盘，会导致数据重新分布）</p></li></ul><br><p>也有不少的平台使用这种架构</p><img src="/medias/21-Introduction-To-Distributed-Databases\shared nothing_02.png" style="zoom:150%;"><br><br><br><h1 id="Design-issues"><a href="#Design-issues" class="headerlink" title="Design issues"></a>Design issues</h1><p>一些设计上的问题：</p><p>应用应该如何查找数据？（应用应该向哪一个节点请求数据）</p><p>分布式DBMS如何执行查询？（如何执行SQL）</p><ul><li>Push query to data</li><li>Pull data to query</li></ul><p>分布式DBMS如何保证数据的一致性和正确性？</p><br><br><h2 id="Homogenous-Nodes"><a href="#Homogenous-Nodes" class="headerlink" title="Homogenous Nodes"></a>Homogenous Nodes</h2><p>均匀、一致的节点</p><p>集群中的每个节点的设计、职责、任务、运行逻辑、角色都是一样的（只是负责的数据不同）</p><br><br><h2 id="Heterogenous-Nodes"><a href="#Heterogenous-Nodes" class="headerlink" title="Heterogenous Nodes"></a>Heterogenous Nodes</h2><p>每个节点的角色是不一样的</p><p>节点之间不是平等关系，允许一个节点管理多个其他节点</p><br><p>比如mongodb</p><p>当查询到Router节点的时候，Router节点会向Config Server节点获取具体数据的信息，然后再到指定的区域进行查询</p><img src="/medias/21-Introduction-To-Distributed-Databases\heterogenous architecture.png" style="zoom:150%;"><br><br><h2 id="Data-transparency"><a href="#Data-transparency" class="headerlink" title="Data transparency"></a>Data transparency</h2><p>数据透明，即用户是不需要了解数据具体的物理位置，或是数据是如何分区的（或是数据副本的情况）</p><p>理想情况下，用户使用分布式DBMS和单节点DBMS应该是一样的</p><br><br><br><h1 id="Partitioning-schemes"><a href="#Partitioning-schemes" class="headerlink" title="Partitioning schemes"></a>Partitioning schemes</h1><p>因为数据都是分布在不同的数据节点上的</p><p>因此DBMS需要在每个分区上执行查询操作，将结果组合在一起才是最终答案</p><br><br><h2 id="Naive-table-partitioning"><a href="#Naive-table-partitioning" class="headerlink" title="Naive table partitioning"></a>Naive table partitioning</h2><p>理想情况下，每个节点都有足够的空间来存放整张数据表</p><p>因此可以将整张数据表分配给单个节点</p><p>而比较理想的查询是，对数据的查询不跨节点，并且访问模式是统一的</p><img src="/medias/21-Introduction-To-Distributed-Databases\naive table partitioning.png" style="zoom:150%;"><br><p>这种方法的缺点是，如果某个表实在是太大了，可能一个节点的容量装不下</p><p>而如果某个表又太小了，单独存在一个节点中又有点浪费</p><br><br><h2 id="Horizontal-partitioning"><a href="#Horizontal-partitioning" class="headerlink" title="Horizontal partitioning"></a>Horizontal partitioning</h2><p>水平分区</p><p>将一个表的数据水平分开，分配到不同的节点上</p><p>比如说可以以某一列作为水平分区的标准（比如下图便是对某一列的值进行hash，取hash值进行分区）</p><img src="/medias/21-Introduction-To-Distributed-Databases\horizontal partitioning.png" style="zoom:150%;"><br><br><p>水平分区下，最友好的查询便是查询谓词中包含分区的那一列数据</p><p>垂直分区（竖着切分数据，将数据切分为两张表）的情况在分布式数据库中是用的比较少的</p><br><p>水平分区面临的问题：</p><ul><li>如果查询不是按照分区来的列进行查找的话，就会造成每个节点的数据都要遍历一遍（比如分区是按照age列分的，但是查找却是按照name进行查找的）</li><li>或者说，想要添加一个新的数据节点，扩容上复杂度会很高</li></ul><p>所以基于上述的扩容问题，提出了一致性hash算法（consistent hashing）</p><br><br><h3 id="Consistent-hashing"><a href="#Consistent-hashing" class="headerlink" title="Consistent hashing"></a>Consistent hashing</h3><p>一致性hash算法</p><p>比如说hash值在0-P1之间的数据，就会存储在P1节点，以此类推</p><img src="/medias/21-Introduction-To-Distributed-Databases\consistene hashing_01.png" style="zoom:150%;"><br><br><p>如果此时需要新添加一个数据节点，比如P4</p><p>那么就需要将P3中，归属于P2-P4范围的数据移动到P4中（这种扩容后的代价小于此前扩容的代价）</p><img src="/medias/21-Introduction-To-Distributed-Databases\consistene hashing_02.png" style="zoom:150%;"><br><br><p>同时，在这种算法下，还可以指定数据的副本数量</p><p>比如说这里执行数据的副本数量要为3，那么P1上的数据就需要复制到P6和P2上面</p><img src="/medias/21-Introduction-To-Distributed-Databases\consistene hashing_03.png" style="zoom: 150%;"><br><br><h2 id="Logical-partitioning"><a href="#Logical-partitioning" class="headerlink" title="Logical partitioning"></a>Logical partitioning</h2><p>逻辑分区，一般是<code>shared disk</code>架构</p><p>数据都存储在一个统一的Storage中</p><p>每个节点本身不存储数据，而是指定需要处理的数据分区</p><p>比如下图中的上面节点，处理的就是id&#x3D;1和id&#x3D;2的数据</p><p>下面的节点处理的就是id&#x3D;3和id&#x3D;4的数据</p><img src="/medias/21-Introduction-To-Distributed-Databases\logical partitioning.png" style="zoom:150%;"><br><br><h2 id="Physical-partitioning"><a href="#Physical-partitioning" class="headerlink" title="Physical partitioning"></a>Physical partitioning</h2><p>物理分区，一般是<code>shared nothing</code>架构</p><p>数据的存储和计算查询都是在同一个节点上</p><img src="/medias/21-Introduction-To-Distributed-Databases\physical partitioning.png" style="zoom:150%;"><br><br><br><h1 id="Single-node-vs-distributed"><a href="#Single-node-vs-distributed" class="headerlink" title="Single-node vs distributed"></a>Single-node vs distributed</h1><p>在单节点的情况下，数据都是在本地操作的，并发控制的处理都是在本节点上，方便处理</p><p>而分布式DBMS的情况下，事务的处理需要跨多个节点（对一个节点上的数据进行操作，别的节点是不知道的；需要非常昂贵的代价去处理）</p><p>因此，如果我们的系统需要在多节点上处理分布式事务，就需要一种多节点并发控制协议去协调</p><br><p>而在分布式的情况下，有以下两种处理的方式：集中式的和非集中式的</p><br><h2 id="Centralized-coordinator"><a href="#Centralized-coordinator" class="headerlink" title="Centralized coordinator"></a>Centralized coordinator</h2><p>用Coordinator来管理数据是否可以读取</p><p>应用的每次commit request都是向Coordinator请求，同时Coordinator上会记录数据的状态（比如读锁写锁等）</p><p>这种方案用的比较少（因为它本质上还是一个单节点的DBMS，存在性能上的缺陷）</p><img src="/medias/21-Introduction-To-Distributed-Databases\centralized coordinator.png" style="zoom:150%;"><br><p>后续演化为了中间件模式</p><img src="/medias/21-Introduction-To-Distributed-Databases\centralized coordinator_01.png" style="zoom:150%;"><br><br><h2 id="Decentralized-coordinator"><a href="#Decentralized-coordinator" class="headerlink" title="Decentralized coordinator"></a>Decentralized coordinator</h2><p>分散式的布局</p><p>应用会向分区中的其中某个节点发出请求，首先接收到该节点请求的节点会变为此次事务的<code>Master Node</code></p><img src="/medias/21-Introduction-To-Distributed-Databases\coordinator_01.png" style="zoom:150%;"><br><p>然后<code>Master Node</code>会给予应用反馈，应用就可以去其他节点的位置对数据进行操作</p><img src="/medias/21-Introduction-To-Distributed-Databases\coordinator_02.png" style="zoom:150%;"><br><p>操作完毕后就会去Master Node上进行commit</p><p>Master Node会检查事务数据是否可以提交</p><img src="/medias/21-Introduction-To-Distributed-Databases\decentralized coordinator.png" style="zoom:150%;"><br><br><br><h1 id="Distributed-concurrency-control"><a href="#Distributed-concurrency-control" class="headerlink" title="Distributed concurrency control"></a>Distributed concurrency control</h1><p>分布式的并发控制是需要多个事务在多个节点上同时并发</p><p>当然，单节点的并发控制也是可以移植到分布式系统中的</p><br><p>但是，这在分布式中会有以下几个挑战：</p><p>副本数据节点的同步</p><p>网络通信上的开销</p><p>节点的容错（事务执行到一半时，节点崩溃该如何处理）</p><p>时钟偏移（系统时钟在不同的节点中是不同步的）</p><br><br><h2 id="Distributed-2PL"><a href="#Distributed-2PL" class="headerlink" title="Distributed 2PL"></a>Distributed 2PL</h2><p>在分布式的情况下，因为不能够实时同步事务管理的信息（比如锁的情况），导致管理上出现问题</p><p>比如说这里的2PL，事务的锁的信息是不能够实时同步的</p><p>可能会导致各自一方都认为自己是正确的，但是最后数据汇总的时候又会出现问题</p><img src="/medias/21-Introduction-To-Distributed-Databases/distributed 2PL.png" style="zoom:150%;">]]></content>
      
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> CMU 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 20-Database Recovery</title>
      <link href="/2022/12/15/cmu-15-445-20-database-recovery/"/>
      <url>/2022/12/15/cmu-15-445-20-database-recovery/</url>
      
        <content type="html"><![CDATA[<h1 id="Crash-Recovery"><a href="#Crash-Recovery" class="headerlink" title="Crash Recovery"></a>Crash Recovery</h1><p>故障恢复算法是为了确保<strong>数据库一致性</strong>，<strong>事务的原子性</strong>和面对故障时<strong>数据的持久性</strong>的一种技术</p><br><p>故障恢复算法主要分为两部分：</p><p>第一部分：在正常的事务处理阶段添加一些操作，使得DBMS可以在故障发生时对数据进行恢复（防患于未然）</p><ul><li>通过上一章的学习，发现添加的操作主要就是WAL</li></ul><p>第二部分：在数据库故障发生时执行一些操作，以此维护数据库的原子性、一致性和持久性（利用上一个部分所添加的操作，维护DBMS的ACID特性；<strong>本章的重点</strong>）</p><br><br><br><br><h1 id="Checkpoints"><a href="#Checkpoints" class="headerlink" title="Checkpoints"></a>Checkpoints</h1><p>崩溃恢复时，可以直接从checkpoint的位置开始读取数据，而不用将所有的log都读取一遍</p><p>checkpoint会周期性执行</p><br><br><p>checkpoint会将内存中的数据（脏页）和日志全部都写入磁盘</p><p>然后，会在日志中会写入一个checkpoint的标志</p><br><br><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><img src="\medias\20-Database-Recovery\checkpoint_example.png" style="zoom:150%;"><br><p>checkpoint之上的日志和数据页，都已经被写入磁盘中了</p><p>checkpoint之下的日志和数据页，还在内存中</p><p>此时发生了crash，便有如下分析过程：</p><p><strong>事务T1</strong>的开始和结束都是在checkpoint之上的（表示其中的数据都写入了磁盘中），因此DBMS不需要对其进行恢复</p><p><strong>事务T2</strong>的开始是在checkpoint之前，结束是在checkpoint之后（但是T2的commit的日志已经在磁盘上了，表明该事务已经提交了），因此，T2需要进行redo操作，将checkpoint到T2 commit之间的，属于T2的操作全部重现一次，从而实现事务的原子性</p><p><strong>事务T3</strong>的开始是在checkpoint之前，但在磁盘上的log中没有发现T3 commit的日志，因此需要undo操作，将此前T3的相关操作全部都给回滚</p><br><br><br><h1 id="ARIES"><a href="#ARIES" class="headerlink" title="ARIES"></a>ARIES</h1><p>全称是<strong>Algorithms for Recovery and Isolation Exploiting Semantics</strong></p><p>从字面的意思理解就是数据库恢复原型算法</p><p>这种算法的理念各大厂商都有去实现和遵守</p><p>但是工程细节上面又会有所不同，并且不同厂商也会有所创新</p><br><br><h2 id="Main-ideas"><a href="#Main-ideas" class="headerlink" title="Main ideas"></a>Main ideas</h2><p><strong>WAL</strong>：使用的是<code>steal + no-force</code>策略，数据页可以不立刻写入磁盘，但是日志页必须立即写入磁盘</p><p><strong>Repeating History During Redo</strong>：在DBMS崩溃的时候，要使用WAL的日志对数据进行恢复</p><p><strong>Logging Changes During Undo</strong>：日志中虽然记录了一些操作，但是直到DBMS崩溃的时候该事务还没有提交，那么这些执行了一半的事务，操作过的数据都需要撤销回滚</p><img src="\medias\20-Database-Recovery\ARIES.png" style="zoom:150%;"><br><br><br><h1 id="Log-Sequence-Numbers"><a href="#Log-Sequence-Numbers" class="headerlink" title="Log Sequence Numbers"></a>Log Sequence Numbers</h1><p>背景：</p><p>需要给每一条日志一个单调递增的，全局的序列号</p><p>序列号的作用是表明系统当前运行的状态</p><img src="\medias\20-Database-Recovery\LSN_01.png" style="zoom:150%;"><br><br><h2 id="flushedLSN"><a href="#flushedLSN" class="headerlink" title="flushedLSN"></a>flushedLSN</h2><p>该LSN是存放在内存中</p><p>记录的是上一次刷到磁盘上的log的编号</p><p>换言之，现在有哪些日志是已经被写入到磁盘上了的</p><p>比如说，如果此时的LSN是100的话，就代表前100号日志都已经落到了磁盘上</p><p>而在100之后的日志就还没有写入到磁盘中，即还在内存中</p><br><br><h2 id="pageLSN"><a href="#pageLSN" class="headerlink" title="pageLSN"></a>pageLSN</h2><p>该LSN是存放在数据页上的，每一个数据页都有一个pageLSN</p><p>记录的是最近一次，修改当前数据页的日志的编号（LSN）</p><p>也可以认为是当前数据页在内存中时，最新修改该page的日志的编号</p><br><br><h2 id="recLSN"><a href="#recLSN" class="headerlink" title="recLSN"></a>recLSN</h2><p>该LSN是存放在数据页上的，每一个数据页都有一个recLSN</p><p>记录的是，当前的page在上一次写入磁盘后，第一个对该page进行修改的日志编号（LSN）</p><p>可以理解为，比当前磁盘上的page还要新的第一个版本</p><p>或者说，记录的是内存中当前page最早的修改（在此前，更早的修改都已经落盘了）</p><p>因此，关于当前在内存中的page，recLSN到pageLSN之间的日志修改，都存储在了内存中</p><p>recLSN和pageLSN在内存中，对于当前page的修改的上限和下限</p><br><br><h2 id="lastLSN"><a href="#lastLSN" class="headerlink" title="lastLSN"></a>lastLSN</h2><p>该LSN是针对单个事务的，每个事务都有一个lastLSN</p><p>记录的是，当前事务最后一条操作日志</p><br><br><h2 id="MasterRecord"><a href="#MasterRecord" class="headerlink" title="MasterRecord"></a>MasterRecord</h2><p>该MasterRecord是针对全体存储介质的，每个存储介质（例如磁盘）都有一个MasterRecord</p><p>记录的是上一次标记，带有checkpoint点的日志的LSN</p><br><br><h2 id="Writing-log-records"><a href="#Writing-log-records" class="headerlink" title="Writing log records"></a>Writing log records</h2><p>始终遵守的一个原则：当一个脏页X被刷到磁盘的时候，必须要保证pageLSN<del>X</del>小于等于flushedLSN</p><p>这就意味着，写入脏页X的前提是与脏页有关的日志及当前日志之前的所有日志都得写入磁盘中</p><br><p>所以，如果我们想要将脏页X写入到磁盘中，至少需要将脏页X的pageLSN<del>X</del>前面，已经操作过的数据写入磁盘</p><p>然后才能将脏页X写入磁盘</p><br><p>每一个log都有其对应的LSN</p><p>每当事务修改page上的数据的时候，都要更新pageLSN</p><p>每一次将内存上的日志写入到磁盘时，都需要更新flushedLSN</p><br><br><br><h1 id="Normal-commit-amp-Abort-operations"><a href="#Normal-commit-amp-Abort-operations" class="headerlink" title="Normal commit &amp; Abort operations"></a>Normal commit &amp; Abort operations</h1><h2 id="Normal-execution"><a href="#Normal-execution" class="headerlink" title="Normal execution"></a>Normal execution</h2><p>事务的组成：对数据的读写操作、事务的开始标记、事务的commit以及abort</p><p>并且，对于事务的操作简化为以下模型：</p><ul><li>所有的日志记录都保存在同一个page中</li><li>磁盘的写入都是原子操作</li><li>以SS2PL为背景，研究事务的恢复机制</li><li>steal + no-force的方式管理缓冲池</li></ul><br><br><h2 id="Transaction-commit"><a href="#Transaction-commit" class="headerlink" title="Transaction commit"></a>Transaction commit</h2><p>commit时需要执行的操作：</p><p>需要在log中添加commit的标记</p><p>要保证在commit的时候，当前事务的所有日志都要被写入到磁盘中</p><ul><li>日志的写入磁盘的过程，是顺序IO、同步IO（IO线程会卡在IO的步骤，当IO完成了以后才会返回）</li><li>一个日志的文件中，含有多条日志</li></ul><br><p>当事务真正提交的时候，会再添加一条TXN-END的日志</p><ul><li>但这一条log并不需要立刻写入磁盘中</li><li>这条日志表示当前事务，所修改的数据都已经写入到磁盘中了</li><li>这条日志对于用户来说，是无感知的，用户是不知道这条日志的</li></ul><br><p>也就是说，commit日志只代表操作的日志被写入了磁盘</p><p>而TXN-END日志才代表修改的数据被写入磁盘了</p><p>PS：当内存中的日志被flush到了磁盘中时，在内存中的日志就可以被删除了</p><img src="\medias\20-Database-Recovery\transaction commit.png" style="zoom:150%;"><br><br><h2 id="Transaction-abort"><a href="#Transaction-abort" class="headerlink" title="Transaction abort"></a>Transaction abort</h2><p>事务发生回滚是一种非常特殊的情况，因此ARIES算法需要进行一些额外的操作，以达到Undo的目的</p><br><p>在每一条日志的后面，加上<strong>prevLSN</strong></p><ul><li><p>记录在当前日志所在的事务中，上一个操作日志的LSN</p></li><li><p>因为LSN是所有的事务共同使用的，所以有可能当前LSN是15号，但14号LSN日志不是当前事务的日志，是其他事务的LSN</p></li><li><p>prevLSN是为了找到，在当前日志所在的事务中，前一条日志是多少号</p></li><li><p>这样在abort的时候就可以像一个链表一样将数据进行回滚</p></li><li><p>PS：事务开始的日志（即begin）的prevLSN是nil</p></li></ul><img src="\medias\20-Database-Recovery\transaction abort.png" style="zoom:150%;"><br><br><h2 id="Compensation-log-records"><a href="#Compensation-log-records" class="headerlink" title="Compensation log records"></a>Compensation log records</h2><p>背景：可以利用prevLSN对事务的操作进行回滚，但是仍然需<strong>要用日志记录当前的事务是如何回滚</strong>的，因此引入CLR</p><p>定义：CLR是记录事务的数据是如何被回滚的<strong>日志</strong>（如何撤销此前更新的操作）</p><p>CLR日志包含了被回滚日志操作的所有字段，同时还有undoNext指针（记录下一步要回滚的日志LSN）</p><p>CLR日志也是被写入到日志文件中，但并不会被要求强制刷盘（因为本身DBMS就在回滚，所以即使此时的日志又发生了崩溃，下次恢复的时候在回滚即可）</p><br><br><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><img src="\medias\20-Database-Recovery\transaction abort_example.png" style="zoom:150%;"><p>此时需要回滚T1事务，那么就要添加一条新的日志，即CLR-00x，00x表示需要撤销的操作的LSN（例子中需要回滚LSN为002的数据，因此这里是CLR-002）</p><p>这条日志的prevLSN就被设为011，因为这条撤销的日志依然属于这个事务</p><p>UndoNext就被设为001，因为此时回滚完002号日志后，就需要回滚002的上一条日志，即001</p><br><p>当回滚结束后，就需要添加TXN-END日志，表示该事务的回滚操作都结束了（此时的undoNext是nil）</p><p>PS：因此，TXN-END既可以表示事务正常运行的结束；也可以表示事务回滚过程后，事务的结束（即commit和abort）</p><img src="\medias\20-Database-Recovery\transaction abort_example_01.png" style="zoom:150%;"><br><br><h2 id="Abort-algorithm"><a href="#Abort-algorithm" class="headerlink" title="Abort algorithm"></a>Abort algorithm</h2><p>回滚算法的具体操作：</p><ul><li><p>首先，在日志中写下当前事务的abort log</p></li><li><p>接着，需要撤销当前事务对数据的修改</p><ul><li><p>先加上一条清理日志（<strong>CLR</strong>）</p></li><li><p>然后再恢复旧版本的数据</p></li></ul></li><li><p>最后，将事务的操作全都回滚了以后，再加上一条TXN-END的日志</p></li></ul><p>PS：清理日志（CLR）是不需要被回滚的（清理日志本身就是用来回滚其他的日志的，所以不应该被回滚）</p><br><br><br><h1 id="Fuzzy-checkpointing"><a href="#Fuzzy-checkpointing" class="headerlink" title="Fuzzy checkpointing"></a>Fuzzy checkpointing</h1><h2 id="Non-Fuzzy-Checkpoints"><a href="#Non-Fuzzy-Checkpoints" class="headerlink" title="Non-Fuzzy Checkpoints"></a>Non-Fuzzy Checkpoints</h2><p>一般的checkpoint要生成一个一致性的快照，就需要执行以下操作：</p><ul><li>任何新的事务都不可以开始</li><li>需要把正在运行的事务全部都做完</li><li>将内存上的脏页都写入磁盘</li></ul><br><p>这种方式对于正在运行的DBMS不利</p><ul><li>因为需要停下来专门处理checkpoint</li><li>并且，有些正在运行的事务可能需要非常久的时间才能做完，那么就需要非常久的等待，并且在这期间不能做其他事</li></ul><p>但是对DBMS的恢复有利</p><br><br><h2 id="Slightly-Better-Checkpoints"><a href="#Slightly-Better-Checkpoints" class="headerlink" title="Slightly Better Checkpoints"></a>Slightly Better Checkpoints</h2><p>一个很自然的想法：不一定要等待所有正在执行的事务都结束后，再进行checkpoint</p><p>换个角度说，只要给内存中活跃事务的脏页加锁，让checkpoint机制无法将这类脏页写入磁盘</p><p>那么就不用等到所有的事务都结束后，再进行checkpoint了</p><br><p>而为了实现这种效果，需要维护以下两个表：</p><p>Active transaction table（ATT，记录当前活跃事务的列表）</p><p>Dirty page table（DPT，脏页表，记录当前系统中有哪些脏页）</p><br><br><h3 id="Active-transaction-table"><a href="#Active-transaction-table" class="headerlink" title="Active transaction table"></a>Active transaction table</h3><p>活动事务表：记录的是做checkpoint时，内存中活跃的事务</p><br><p>每条事务记录的组成：</p><ul><li>txnID（事务ID）</li><li>txn status（事务的状态）<ul><li>R：running</li><li>C：committing</li><li>U：还没提交，可以理解为undo候选人，如果崩溃的时候，事务的状态依然是U，那么就要执行Undo操作了</li></ul></li><li>lastLSN（事务最近的一条操作日志）</li></ul><br><p>只有当事务结束了（写入TXN-END）的时候，才可以把事务从当前的表中移除</p><img src="\medias\20-Database-Recovery\active transaction table.png" style="zoom:150%;"><br><br><h3 id="Dirty-page-table"><a href="#Dirty-page-table" class="headerlink" title="Dirty page table"></a>Dirty page table</h3><p>脏页表：记录的是内存中，还没有写入磁盘的脏页</p><p>表中的每一个脏页，都会记录recLSN</p><ul><li>recLSN是指第一次使得当前page变为脏页的日志，也就是自上一次刷盘后开始的第一个日志</li></ul><br><br><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h3><img src="\medias\20-Database-Recovery\slightly better checkpoints.png" style="zoom:150%;"><p>对于slightly better checkpoints来说，</p><p>会在每个checkpoint点的位置，额外的记录一下此时的ATT和DPT</p><br><br><h3 id="Observation"><a href="#Observation" class="headerlink" title="Observation"></a>Observation</h3><p>slightly better checkpoint的做法，其实是让正在运行的事务先暂停</p><p>并给这些事务的脏页上锁，以此保证checkpoint的时候不会把这些没完成的脏页写入磁盘</p><br><p>换言之，相比原来的checkpoint方法</p><p>slightly better checkpoint的优点是不需要等到所有的事务全部做完</p><p>允许其留下还没执行完的活跃事务及其脏页</p><br><p>但是缺点是，尽管没有清空事务，但还是暂停了事务（失去了并发性）</p><br><p>思考：之所以造成checkpoint会有性能问题，是因为我们一直要求要有一个一致性的快照</p><p>要求此时（具体的某个时间点），所有的数据页都被刷入到了磁盘中</p><p>由此引发的一个思路就是，由具体某个时间点的快照，变为某个时间段的快照，即fuzzy checkpoints</p><br><br><h2 id="Fuzzy-checkpoints"><a href="#Fuzzy-checkpoints" class="headerlink" title="Fuzzy checkpoints"></a>Fuzzy checkpoints</h2><p>主要思路：</p><p>将checkpoint的一致性快照，由时间点变为了时间段</p><p>那些还在活跃事务下的脏页，checkpoint就不需要对其进行强制刷盘</p><br><p>将checkpoint的时间点变为时间段，即分别写入checkpoint-begin、checkpoint-end两条日志</p><ul><li>checkpoint-begin表示checkpoint的开始</li><li>checkpoint-end表示checkpoint的结束，同时附上ATT和DPT这两个表</li><li>对于ATT和DPT，这两个表都表示是在checkpoint-begin之前活跃的事务，和未刷入磁盘的脏页</li><li>而checkpoint-end则表示，记录在checkpoint-begin以前提交的事务的日志及数据都已经刷盘</li><li>在checkpoint-begin之后的，checkpoint-end之前的任何事务，都不会被记录到ATT中</li></ul><br><br><br><h1 id="ARIES-Recovery-phases"><a href="#ARIES-Recovery-phases" class="headerlink" title="ARIES - Recovery phases"></a>ARIES - Recovery phases</h1><p><strong>Phase I：Analysis</strong></p><p>数据库发生崩溃后，先读入WAL文件</p><p>找到MasterRecord（即上一次checkpoint的位置，如果是fuzzy checkpoint，那就是checkpoint-begin）</p><p>并对其上下的日志进行分析</p><br><p><strong>Phase II：Redo</strong></p><p>把应该写入到磁盘中，但是还没有写入磁盘的数据，对其进行恢复</p><br><p><strong>Phase III：Undo</strong></p><p>把应该回滚，但是还没有回滚的数据进行回滚</p><img src="\medias\20-Database-Recovery\ARIES - Recovery phases.png" style="zoom:150%;"><br><br><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>当DBMS发生崩溃之后，首先要找到上一次checkpoint的位置，也就是<strong>MasterRecord</strong>，也是<strong>last checkpoint</strong></p><p>接着就需要去找哪些日志的操作需要redo，也就是要找DPT（脏页表）里面最小的<strong>recLSN</strong></p><ul><li>为什么要去脏页表里面找，因为此时脏页表里面的数据并没有写入到磁盘里面</li><li>no-fuzzy checkpoint之前所有的日志和数据都已经写入到磁盘中了，但是这里使用的是fuzzy checkpoint，那么就会导致有部分脏页数据是还没有写入磁盘的（为了性能，使用了fuzzy checkpoint）</li><li>因此就要找对应脏页的recLSN，然后从这一点开始做数据的Redo操作</li></ul><p>最后，就是Undo操作</p><ul><li>从DBMS崩溃时的位置往前进行分析，分析有哪些事务到最后依然是活跃的，那么这些事务的操作就需要回滚</li></ul><img src="\medias\20-Database-Recovery\ARIES overview.png" style="zoom:150%;"><br><br><h2 id="Analysis-phase"><a href="#Analysis-phase" class="headerlink" title="Analysis phase"></a>Analysis phase</h2><p>首先先找到上一次checkpoint的位置，然后从这个位置往前扫描（即往最新的方向扫描；如果是fuzzy checkpoint，那么就要从checkpoint-begin的位置开始扫描）</p><p>如果发现了TXN-END的日志，就表明这个事务是已经完成了的，不需要对其进行redo或是undo的操作</p><p>就可以把这个事务从ADT（活跃事务表）中移除</p><br><p>对于接下来读到的每一条日志记录：</p><ul><li>把当前记录的事务放到ADT中，并且标记为<strong>UNDO状态</strong></li><li>如果找到了读到了某个事务的commit，就把该事务在ADT中的状态改为<strong>COMMIT状态</strong></li><li>特别的，针对<strong>UPDATE</strong>的记录，就把发生了数据修改的page添加到DPT（脏页表）中，然后把该脏页的recLSN改为该日志的LSN</li></ul><br><p>上述的分析阶段其实就是不断地构建ATT和DPT的过程：</p><ul><li>ATT记录的是在系统崩溃的时候，还有哪些事务是<strong>活跃</strong>的</li><li>DPT记录的是在系统崩溃时，系统还没有写入到磁盘的<strong>脏页</strong></li></ul><br><br><h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example"></a>Example</h3><img src="\medias\20-Database-Recovery\analysis phase example.png" style="zoom:150%;"><p>当DBMS发生了崩溃之后，就需要找到最近的checkpoint-begin点，分析从这个点到Crash的时候，中间的日志：</p><p>020号日志：先将该日志添加到ATT和DPT中，并将该事务的状态标记为U（因为此时还没有提交）；而在DPT中，就把脏页给记录下来</p><p>030号日志：发现是checkpoint-end，那么就把此时的ATT和DPT的数据覆盖到已有的ATT和DPT上</p><p>040号日志：发现是事务T96的commit日志，于是就可以把事务T96在ATT中的状态修改为C（commit）</p><p>050号日志：发现是事务T96的TXN-END日志，就代表与这个事务有关的操作全部都完成了，被刷入盘中，那么就可以把T96事务相关的数据和页从DPT和ATT中移除</p><br><br><h2 id="Redo-phase"><a href="#Redo-phase" class="headerlink" title="Redo phase"></a>Redo phase</h2><p>Redo阶段的主要目的是重现DBMS在发生了崩溃时的状态</p><p>因此，需要Redo已经commit的事务记录，</p><p>需要Redo直到Crash时还依然没有提交的事务记录，</p><p>同时还要CLR（回滚清理日志）</p><br><p>一些优化的思路：对于那些未提交事务的操作记录，是不需要回滚（因为它们属于未提交事务）</p><p>但基本的ARIES是不这样做的，可能有些工程实践中有这些操作</p><br><p><strong>Redo</strong>的具体流程：</p><p>针对DPT中的每一个页，都找到这个页的recLSN，然后从recLSN的日志位置开始对数据进行Redo操作，恢复至Crash发生时的状态</p><p>对于其中每一条日志记录或是CLR记录，都需要进行Redo操作，<strong>除了以下两个情况</strong>（即以下两种情况不需要Redo）：</p><ul><li>DPT中没有当前页（比如说发现一个日志修改了某一页的数据，但是脏页表DPT中没有这一页，那么就不需要Redo这条日志）<ul><li>代表这个页早已经被写入到磁盘中了</li></ul></li><li>DPT有当前修改的页，但是当前日志的LSN小于这一页的recLSN<ul><li>这代表着当前日志的修改，是在recLSN之前的，那么这个修改必然是已经被写入磁盘了的</li></ul></li></ul><br><p><strong>Redo一条日志</strong>的具体流程：</p><ul><li>将数据读入内存，在内存中重新执行一遍这条语句</li><li>把当前数据页的pageLSN修改为<strong>这条日志的LSN</strong></li><li>在重新执行日志的操作中，是不需要额外写入日志的，也不强制将数据写入磁盘</li></ul><br><p>最后，将ATT中所有的状态是C的事务，添加上TXN-END的日志，并把这个事务从ATT中移除</p><br><br><h2 id="Undo-phase"><a href="#Undo-phase" class="headerlink" title="Undo phase"></a>Undo phase</h2><p>背景：一方面，Redo阶段可能会重做一些未提交事务的日志；另一方面，有些未提交事务的数据可能已经被写入磁盘中了</p><br><p>因此，需要在ADT中找到所有状态为U的事务（U代表事务未提交）</p><p>然后根据ADT中事务的lastLSN，对事务的操作一条一条的回滚（回滚过程中利用UndoNext来记录下一条需要回滚的日志）</p><br><p>PS：在Undo阶段，需要为每一个Undo操作的日志写入CLR（清理日志）</p><br><br><h2 id="Full-example"><a href="#Full-example" class="headerlink" title="Full example"></a>Full example</h2><p>举个例子，利用ARIES算法对DBMS的崩溃进行一次分析：</p><img src="\medias\20-Database-Recovery\full example_01.png" style="zoom:150%;"><br><p>首先是<strong>Analysis</strong>阶段，从Log中分析出此时的ATT和DPT</p><img src="\medias\20-Database-Recovery\full example_02.png" style="zoom:150%;"><br><p>接着是<strong>Redo</strong>阶段，针对DPT中的数据脏页，将数据进行刷盘</p><p>比如说此时脏页有P1，那么就先将脏页P1从磁盘中读取到内存中，然后从recLSN的位置，直到Crash这个区间进行分析，将数据页按照log上的操作进行修改</p><p>PS：此时的Redo操作是没有日志的</p><img src="\medias\20-Database-Recovery\full example_02.png" style="zoom:150%;"><br><p>最后是<strong>Undo</strong>阶段，对ATT中尚未提交的事务（状态是<strong>U</strong>的事务）操作进行回滚</p><p>事务的回滚便是利用每个事务的lastLSN，逐条逐条的往上回滚（事务的语句是利用UndoNext进行连接的）</p><p>比如这里需要回滚事务T2，那么就需要lastLSN对事务的操作进行回滚，同时UndoNext就会记录下一条需要回滚的日志操作</p><img src="\medias\20-Database-Recovery\full example_03.png" style="zoom:150%;"><br><p>再比如说这里回滚事务T3，而T3只有一条语句，那么这里UndoNext就为空，并且在该事务回滚完毕后（即所有的与该事务的脏页都被写入了磁盘中），会再添加一条<code>TXN-END</code>的log</p><img src="\medias\20-Database-Recovery\full example_04.png" style="zoom:150%;"><br><p>一个小插曲：如果在崩溃后的恢复过程中，又发生了一次崩溃，那么此时的恢复也是和之前是一样的（再次恢复的时候，重复ARIES的几个步骤即可）</p><img src="\medias\20-Database-Recovery\full example_05.png" style="zoom:150%;"><br><br><br><h1 id="Additional-crash-issues"><a href="#Additional-crash-issues" class="headerlink" title="Additional crash issues"></a>Additional crash issues</h1><p>问题一：如果DBMS在分析阶段又发生了崩溃，是否有问题？</p><p>答：没问题，下次恢复的时候再分析即可</p><br><p>问题二：如果DBMS在Redo阶段又发生了崩溃，是否有问题？</p><p>答：没问题，因为Redo阶段是不计入日志的，如果是在Redo的过程中崩溃了，那么此时的数据还是在内存上，并没有写入磁盘，所以没有影响；而如果说是在事务TXN-END之后发生崩溃了，也不会有问题，因为TXB-END日志写入就代表数据已经落盘了</p><br><p>问题三：在Redo阶段，有什么能够提高性能的方案？</p><p>答：在Redo的时候，同时在后台将数据异步刷盘</p><br><p>问题四：在Undo阶段，有什么能够提高性能的方案？</p><p>答：懒加载，即先不要立刻执行Undo操作；因为可能某个数据页一直都没有人访问，那么做不做Undo操作都不影响性能</p><p>所以可以选择当有新的事务要对其进行操作的时候，再对数据页进行Undo的操作（<strong>Lazily rollback</strong>）</p><p>好处就是能让DBMS快速的对外提供服务</p><p>但缺点就是会间接的影响后续事务的性能</p><br><p>另一方面，从应用的使用者的角度来说，尽量不要写太长的事务（这会导致Undo阶段非常的影响性能）</p><br><br><br><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>ARIES的几个实现细节：</p><ul><li><p>需要使用WAL，<code>steal + no-force</code>的策略</p></li><li><p>需要使用<code>fuzzy checkpoints</code></p></li><li><p>分析阶段过后，需要先进行Redo操作，再进行Undo操作</p></li><li><p>在Undo的时候需要写入CLR日志</p></li></ul><br><p>LSN（日志序列号），在整个ARIES中都非常重要的概念</p><ul><li>可以用LSN实现一个链表，利用prevLSN记录一整个日志的所有日志操作</li><li>也可以利用pageLSN，做数据页和日志记录的比较</li></ul><br><br><br><h1 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h1><p>使用WAL的主要目的应该不是为了提高性能（虽然顺序IO是快于随机IO的，但是写了日志后，还是要执行语句，还是要随机IO）</p><p>而是为了在崩溃恢复的时候，确保DBMS依旧能够保证提供ACID的特性</p>]]></content>
      
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> CMU 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 19-Database Logging</title>
      <link href="/2022/12/12/cmu-15-445-19-database-logging/"/>
      <url>/2022/12/12/cmu-15-445-19-database-logging/</url>
      
        <content type="html"><![CDATA[<h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><p>从事务的角度来说，事务commit之后，使用者就会认为处理好的数据就被放到硬盘上了（并不管底层是如何实现的）</p><p>但实际上，出于对性能的考量（硬盘和磁盘的访问速度有明显差距）</p><p>实时修改的数据页是不会立刻写入到磁盘上的</p><p>而是优先放到内存中的（至于什么时候数据才能落盘，会根据不同的置换策略对内存上的数据进行写入）</p><img src="\medias\19-Database-Logging\motivation_logging.png" style="zoom:150%;"><br><br><p>因此，如果修改好的数据只保存在了内存中，而并没有写入到磁盘上</p><p>那么当内存遭到破坏时（比如说断电、希特勒打仗等突发情况）</p><p>就会造成事务数据的丢失</p><p>因此需要DBMS的recovery机制</p><img src="\medias\19-Database-Logging\motivation_logging_01.png" style="zoom:150%;"><br><br><br><h1 id="Crash-recovery"><a href="#Crash-recovery" class="headerlink" title="Crash recovery"></a>Crash recovery</h1><p>故障恢复算法是为了确保<strong>数据库一致性</strong>，<strong>事务的原子性</strong>和面对故障时<strong>数据的持久性</strong>的一种技术</p><br><p>故障恢复算法主要分为两部分：</p><p>第一部分：在正常的事务处理阶段添加一些操作，使得DBMS可以在故障发生时对数据进行恢复（防患于未然；<strong>本章的重点</strong>）</p><p>第二部分：在数据库故障发生时执行一些操作，以此维护数据库的原子性、一致性和持久性（利用上一个部分所添加的操作，维护DBMS的ACID特性）</p><br><br><p>思考：</p><p>DBMS的不同组件是依赖于在不同的存储器</p><p>比如说缓存是放到内存上的（易失性存储，但访问速度快），而数据一般是放在硬盘上的（非易失性存储，但能持久化数据）</p><p>因此，DBMS需要对不同类型的故障进行分类，从而针对不同故障给出应对处理</p><br><img src="\medias\19-Database-Logging\storage types.png" style="zoom:150%;"><br><br><br><h1 id="Failure-classification"><a href="#Failure-classification" class="headerlink" title="Failure classification"></a>Failure classification</h1><br><h2 id="Transaction-failure"><a href="#Transaction-failure" class="headerlink" title="Transaction failure"></a>Transaction failure</h2><p>事务级别的故障，是正常运行的过程中不可避免的</p><p>是DBMS的开发者必须要考虑的</p><br><p><strong>逻辑错误</strong></p><ul><li><p>事务因为某些原因不能完整的执行下去</p></li><li><p>例如：用户发出rollback指令、事务执行的过程中违背了完整性约束、又或是说并发控制协议（比如OCC）发生了冲突，从而造成事务<strong>回滚</strong></p></li></ul><br><p><strong>内部状态错误</strong></p><ul><li>DBMS发现内部状态错误（比如事务间的<strong>死锁</strong>），必须终止某个活跃的事务</li></ul><br><br><h2 id="System-failure"><a href="#System-failure" class="headerlink" title="System failure"></a>System failure</h2><p>系统级别的故障，比如当数据还在内存的时候，就发生了硬件故障，导致内存中的数据消失了</p><p>也是DBMS的开发者需要考虑的</p><br><p><strong>软件故障</strong></p><ul><li>OS、DBMS本身的故障（例如：DBMS未捕获的除零异常）</li></ul><br><p><strong>硬件故障</strong></p><ul><li>存储数据库的电脑崩溃（例如：断电、CPU损坏）</li><li>硬件故障的前提是：非易失性存储（硬盘）上的数据不会因为系统崩溃而损坏</li><li>PS：硬盘故障属于Storage media failure</li></ul><br><br><h2 id="Storage-media-failure"><a href="#Storage-media-failure" class="headerlink" title="Storage media failure"></a>Storage media failure</h2><p>存储媒介的故障，比如说SSD、HHD等存储介质出现了问题</p><p>或是说磁盘的磁头崩溃，破坏了全部或部分非易失性存储</p><p>这种故障属于无法修复的硬件故障，是<strong>不可恢复</strong>的</p><br><p>但另一方面，这类故障是可以被检测出来的（例如：磁盘控制器可以使用校验和来检测故障）</p><br><p>因此这种故障在设计数据库的时候，不会考虑这类问题（当然可以在数据库运维的时候可以备份多份数据，实现容灾）</p><br><br><h2 id="Observation"><a href="#Observation" class="headerlink" title="Observation"></a>Observation</h2><p>DBMS的主要数据都存储在了非易失性存储器上</p><p>但是非易失性存储器（例如磁盘）的读取效率远慢于易失性存储器</p><br><p>因此，为了高效的利用易失性存储，实际的读取数据流程：</p><ul><li>首先将目标数据读取到内存中</li><li>然后在内存中对数据进行修改</li><li>最后将修改过的数据放回磁盘中</li></ul><br><p>但另一方面，DBMS还需要对使用者做出如下保证：</p><ul><li>一旦某个事务提交了，那么对这个事务的提交便已经持久化（维护<strong>持久性</strong>）</li><li>如果某个事务终止了，那么前面的部分修改是不能持久化的（维护<strong>原子性</strong>；好像这个事务没有发生一样）</li></ul><br><p>其实从上述二者的论述中，发现了设计DBMS的一个<strong>矛盾</strong>：</p><p>一方面，为了性能考虑，需要将数据先放到非易失性存储介质上，后续在写回磁盘</p><p>而另一方面，为了ACID，需要将数据实时落盘</p><br><br><h2 id="Undo-vs-Redo"><a href="#Undo-vs-Redo" class="headerlink" title="Undo vs Redo"></a>Undo vs Redo</h2><img src="\medias\19-Database-Logging\undo vs redo.png" style="zoom:150%;"><br><br><h3 id="Undo"><a href="#Undo" class="headerlink" title="Undo"></a>Undo</h3><p>删除不完整的事务，或被终止的事务对数据的影响</p><p>也就是，对那些不完整的事务（或被终止的事务）中已经完成了操作的数据进行回滚</p><p>目的是为了在事务终止的时候，维护<strong>原子性</strong>（要么都执行，要么都不执行）</p><br><br><h3 id="Redo"><a href="#Redo" class="headerlink" title="Redo"></a>Redo</h3><p>恢复已commited的事务中，已经执行了的操作，以此维护事务的<strong>持久性</strong></p><p>比如操作日志已经落盘了，但是数据实际上还没有得到修改</p><p>那么就要将读取并执行日志中的相关操作</p><br><br><br><h1 id="Buffer-pool-policies"><a href="#Buffer-pool-policies" class="headerlink" title="Buffer pool policies"></a>Buffer pool policies</h1><p><strong>背景：</strong></p><p>假设有两个事务A、B，同时对同一个页中不同的数据进行操作</p><br><p>如果事务A要commit，那么此时是否要将数据页刷盘呢？</p><ul><li>如果刷盘的话，如果后续事务B又要使用该数据页，就得重新读数据了，浪费时间</li><li>但如果不刷盘的话，那该数据页就会一直放在内存中，浪费内存</li></ul><br><p>同时还会带来另一个问题：如果要将数据页刷盘，是只将事务B的数据刷盘，还是把整个数据页（包含事务A和事务B）刷盘？</p><ul><li>如果只刷事务B的数据，刷盘效率过低</li><li>如果是刷整个数据页，万一事务A发生了回滚，就有需要重新读取数据再修改</li></ul><img src="\medias\19-Database-Logging\buffer pool 背景.png" style="zoom:150%;"><br><br><h2 id="Steal-policy"><a href="#Steal-policy" class="headerlink" title="Steal policy"></a>Steal policy</h2><p>DBMS是否允许未提交的事务的数据，覆盖原有的数据（即在修改数据的时候，到底应不应该覆盖原有磁盘上的数据）</p><p><code>steal</code>：允许覆盖（<strong>未提交的事务数据可以覆盖原有的数据</strong>；不管脏页的数据是否提交，全部都刷盘）</p><p><code>no steal</code>：不允许覆盖（<strong>未提交的事务数据不可以覆盖原有的数据</strong>；脏页上提交了的数据，才能刷盘）</p><br><br><h2 id="Force-policy"><a href="#Force-policy" class="headerlink" title="Force policy"></a>Force policy</h2><p>当用户发出commit的时候，是否应该立刻将数据全部都更新到磁盘上</p><p><code>force</code>：必须（提交的事务数据时，<strong>必须立刻刷盘</strong>）</p><p><code>no force</code>：非必要（提交的事务数据时，<strong>不需要立刻刷盘</strong>）</p><br><br><h2 id="No-steal-Force"><a href="#No-steal-Force" class="headerlink" title="No-steal + Force"></a>No-steal + Force</h2><img src="\medias\19-Database-Logging\no-steal + force.png" style="zoom:150%;"><br><p>优点：</p><p>实现上简单方便</p><p>不需要撤销终止（回滚）事务的数据修改，因为此时对事务的修改都没有落盘（<strong>不需要undo的操作</strong>）</p><p>不需要恢复（重做）对已提交事务的数据修改，因为此时保证已提交的数据都落盘（<strong>不需要redo的操作</strong>）</p><br><br><p>缺点：</p><p>性能上不好（每个事务的提交都需要频繁的刷盘）</p><p>同时还会在内存中复制出多份快照（为了不将未提交的事务数据刷盘）</p><p>比如说要修改全表的数据，那么就需要将全表的数据都读到内存中（但显然内存大小是有限的）</p><p>因此，这种方法是不能支持写的数据量远大于内存容量的</p><br><br><br><h1 id="Shadow-paging"><a href="#Shadow-paging" class="headerlink" title="Shadow paging"></a>Shadow paging</h1><img src="\medias\19-Database-Logging\shadow paging.png" style="zoom:150%;"><br><br><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>以树形结构组织数据页，其中根是单个磁盘页</p><p>分别维护两个独立的数据库副本：</p><p>master：只包含已提交的事务的数据（DB Root指向该版本的数据）</p><p>shadow：未提交事务的一个临时数据库</p><br><img src="\medias\19-Database-Logging\shadow page example.png" style="zoom:150%;"><br><br><p>shadow paging的过程：</p><p>先将要操作的数据页进行拷贝，即在内存上拷贝一份新的数据</p><p>接着后续的写操作都是在这个备份上进行操作</p><p>事务commit之后将数据刷入盘中</p><p>然后调整DB root指针的指向，使其指向当前新更新的page</p><p>最后清理掉原来的page</p><br><br><h2 id="Undo-x2F-Redo"><a href="#Undo-x2F-Redo" class="headerlink" title="Undo&#x2F;Redo"></a>Undo&#x2F;Redo</h2><p>undo：移除shadow页</p><p>redo：不需要（因为所有数据都落盘了）</p><br><br><h2 id="Disadvantages"><a href="#Disadvantages" class="headerlink" title="Disadvantages"></a>Disadvantages</h2><p>相比一般的no-steal + force，shadow paging的优点是可以先将一部分数据刷到磁盘上（因为shadow paging是在磁盘上新建的页）</p><br><p><strong>数据页的复制</strong>是昂贵的</p><p>比如说我们可能只需要修改一个page中的一条数据，但却要将整个page都复制一份（复制成本高）</p><br><p><strong>复制整个页表</strong>是非常昂贵的</p><ul><li><p>可以使用B+树结构对页表进行优化</p></li><li><p>不要复制整棵树，只需要复制树中通往需要修改的叶子节点的路径</p></li></ul><br><p><strong>事务的提交开销</strong>是非常的昂贵</p><p>事务提交的时候需要做的事情有：将新数据刷盘，调整DB root中的指向，同时还要删除旧的page（垃圾回收）</p><p>数据存在碎片化</p><ul><li>一开始数据是连续存储的，但是后续不断的新生成page，接着又删除原有的page，导致数据的存储实际上并不连续，即碎片化</li></ul><p>每次只支持一个事务的写入</p><br><br><h2 id="SQLITE（PRE-2010）"><a href="#SQLITE（PRE-2010）" class="headerlink" title="SQLITE（PRE-2010）"></a>SQLITE（PRE-2010）</h2><p>Sqlite就是使用shadow paging（Sqlite主要用在一些嵌入式的设备上，或是一些安卓、苹果等系统上）</p><br><p>Sqlite的shadow paging的具体过程：</p><p>当事务开始的时候，Sqlite会将原来的数据页在本地复制一份（放到<code>Journal File</code>区域中）</p><p>然后对数据具体的修改都是在内存上进行</p><p>接着，如果事务commit的话，就会将内存中的数据刷盘到磁盘上</p><p>最后，在<code>Journal File</code>中将对应的page删除</p><br><p>如果刷盘的过程中发生了故障，那么就需要对事务进行回滚</p><p>回滚的方式，就是将Journal File中的文件读到内存中，然后再覆盖回原来的文件</p><img src="\medias\19-Database-Logging\SQLITE.png" style="zoom:150%;"><br><br><h2 id="Observation-1"><a href="#Observation-1" class="headerlink" title="Observation"></a>Observation</h2><p>shadowing page依然存在大量对磁盘的随机IO（性能低下）</p><p>因此需要一种方法，能够将DBMS的随机IO修改为顺序IO，也就是WAL</p><br><br><br><h1 id="Write-ahead-log"><a href="#Write-ahead-log" class="headerlink" title="Write-ahead log"></a>Write-ahead log</h1><p>在磁盘中单独维护一个日志文件，与数据文件是分隔开的</p><ul><li><p>日志中记录的是事务对于DBMS中数据的修改操作</p></li><li><p>假定日志都存放在稳定的存储介质中</p></li><li><p>日志中有足够的信息来执行必要的redo和undo操作，以恢复数据库</p></li></ul><br><p>DBMS必须将对应的日志文件写入磁盘后，才能将对应的修改了的数据页写入磁盘中</p><br><p>策略：<strong>steal  + no force</strong></p><br><br><h2 id="WAL-protocol"><a href="#WAL-protocol" class="headerlink" title="WAL-protocol"></a>WAL-protocol</h2><p>DBMS先将事务操作的所有日志保存在内存中（一般会在内存中开辟一个空间，用于专门存储日志）</p><p>接着，将与更新页面相关的所有日志都保存到了非易失性存储（磁盘）后，才将数据页更新到磁盘上</p><ul><li>PS：这里对于数据的更新，都是先更新内存中的数据页上，后续才刷盘</li></ul><p>只有将事务对应的所有操作日志都写入了非易失性存储（磁盘）后，事务才会被认为是已提交了</p><ul><li>也就是说，当用户发送commit的时候，实际上是将日志写入到了磁盘中</li><li>而用户的数据页还在内存中</li><li>但只要用户的操作日志刷到了磁盘中，就可以保证事务是已提交了的</li></ul><br><br><p><strong>Log的过程</strong></p><p>当事务开始时，向日志中写入<code>&lt;begin&gt;</code>记录，以标记为起点</p><p>当事务结束（提交）时：</p><ul><li>在log中写入一条<code>&lt;commit&gt;</code>的记录</li><li>在写入<code>&lt;commit&gt;</code>的时候，必须要确保所有日志记录在向应用程序返回确认之前被落盘</li></ul><br><br><p><strong>Log的内容</strong></p><p>每个日志条目都包含了关于单个对象变更的信息：</p><ul><li>事务Id</li><li>对象Id（所操作的数据对象）</li><li>前值（修改之前是什么数据；UNDO，用来做undo操作）</li><li>后值（修改之后是什么数据；REDO，用来做redo操作）</li></ul><br><p>MySQL中的innodb引擎，就将日志分为的redo log和undo log两部分日志</p><br><br><h2 id="WAL-example"><a href="#WAL-example" class="headerlink" title="WAL-example"></a>WAL-example</h2><p>事务对数据的操作，首先是写入操作相关的日志，接着在将数据读入到内存中进行修改</p><img src="\medias\19-Database-Logging\wal-example_01.png" style="zoom:150%;"><br><br><p>事务发出commit指令的时候，将buffer中的log写入磁盘中</p><img src="\medias\19-Database-Logging\wal-example_02.png" style="zoom:150%;"><br><br><p>如果事务提交后，修改的数据页仍在内存中，但是因为断电导致内存中的数据消失了</p><p>那么，在后续重启DBMS的时候，可以重新读取log，对事务的数据进行恢复</p><img src="\medias\19-Database-Logging\wal-example_03.png" style="zoom:150%;"><br><br><h2 id="WAL-implementation"><a href="#WAL-implementation" class="headerlink" title="WAL-implementation"></a>WAL-implementation</h2><p>什么时候要将log写入磁盘？</p><p>一般来说是用户发出commit指令的时候就将log写入磁盘</p><p>但是这样频繁的写入磁盘会导致DBMS的运行效率低下（可用户commit的时候是必须要将log刷盘的）</p><br><p>因此给出的一个优化方法是：<strong>组提交</strong></p><p>第一个事务commit的时候，不立刻返回，等累积了多个事务commit的时候，一并返回</p><p>借助组提交分摊写入磁盘的开销</p><br><p>有个问题：可能会出现相互等待的情况（比如此时只有T1、T2两个事务，但WAL非得等到事务足够多的时候才将日志写入磁盘）</p><ul><li>一般用定时器解决：当等待超过了一定的时间后，就直接将日志写入磁盘，不再继续等待</li></ul><br><p>另一个问题：log的page buffer满了该如何处理</p><ul><li>此时可以将一些log的page先写入到磁盘上</li></ul><img src="\medias\19-Database-Logging\WAL flush time.png" style="zoom:150%;"><br><br><p>什么时候将修改好了的数据写入磁盘中？</p><p>每次事务数据发生修改的时候，或者当事务提交的时候</p><br><br><p>在运行时，no-force + steal的性能是最好的（因为steal可以将全部数据刷盘，no-force可以减少刷盘次数）</p><p>在恢复时，no-force + steal的性能是最坏的（因为是no-force，所以很多数据都没有立即刷盘，恢复时需要读取日志刷盘；而steal则可能会写入很多没有提交的数据，那么恢复的时候又要读取出来进行undo操作）</p><img src="\medias\19-Database-Logging\buffer pool policy.png" style="zoom:150%;"><br><p>但，需要数据库恢复的情况占少数，因此<strong>大部分DBMS都选择no-force + steal</strong></p><br><br><br><h1 id="Logging-schemes"><a href="#Logging-schemes" class="headerlink" title="Logging schemes"></a>Logging schemes</h1><p>WAL日志的格式</p><h2 id="Physical-logging"><a href="#Physical-logging" class="headerlink" title="Physical logging"></a>Physical logging</h2><p>物理日志</p><p>记录每个数据页上，在二进制级别上的变化（例如：偏移多少个字节后，数据从什么变为了什么，即数据的变化）</p><p>比如：git diff</p><br><p>缺点：如果有个需求是让某一列的数据全部加一，那么物理日志就会变得非常的多，浪费空间（逻辑日志刚好可以解决这个问题）</p><br><br><h2 id="logical-logging"><a href="#logical-logging" class="headerlink" title="logical logging"></a>logical logging</h2><p>逻辑日志</p><p>记录每个事务执行的SQL语句</p><p>比如：update，delete和insert查询</p><br><p>优点：每次写入的日志记录的大小少于物理日志记录（比如某个SQL语句修改了大面积的数据集的时候）</p><br><p>缺点：</p><p>如果执行的SQL语句是记录当前的某个时间（now函数），但是redo的时候就会有问题（redo的时候重新执行一遍，那此时到底是记录原有的时间，还是现在的时间，无从下手）</p><br><p>再比如说，limit语句，这个语句是不指定到底要输出哪些数据的</p><p>因此在主备数据库的时候，可能主数据库有某个索引，备数据库没有这个索引</p><p>那么同样执行limit语句的时候就会导致结果不一致</p><br><p>而另一方面，如果有并发日志，很难用逻辑日志实现恢复</p><ul><li><p>难以确定数据库的哪些部分可能在崩溃前被查询修改过</p></li><li><p>redo的时候需要很长时间来恢复，因为需要执行每一个事务的SQL语句</p></li></ul><br><p>总的来说，就是逻辑日志在恢复的时候，即执行SQL语句的时候会有逻辑问题</p><br><br><h2 id="Physiological-logging"><a href="#Physiological-logging" class="headerlink" title="Physiological logging"></a>Physiological logging</h2><p>物理日志和逻辑日志的结合，记录的是数据页中，某个元组的数据前后变化</p><p>相比物理日志，Physiological记录了元组数据的具体位置，而不是偏移量</p><p>相比逻辑日志，Physiological记录了数据的前后变化，恢复上不再有逻辑问题</p><img src="\medias\19-Database-Logging\logging schemes.png" style="zoom:150%;"><p>因为记录的是数据页上某个元组数据的变化，所以允许DBMS对数据页中数据的位置进行重新组织（将空间重新分配）</p><br><p>可这依然没有解决物理日志的问题（给某一列加一，日志如何记录）</p><p>而Physiological logging提供了一种mix的记录方式，即可以混合记录日志（实际使用在binlog中）</p><br><p>Physiological logging是<strong>目前最流行的日志记录方法</strong></p><p>PS：MySQL说自己是物理日志，但是实际上说的是Physiological logging日志</p><br><p>当然，Physiological的恢复成本是高于Physical的，因为它需要DBMS去找到对应位置的数据，而Physical不需要，它直接告诉了DBMS偏移量是多少</p><br><p>为什么MySQL要将redo log和undo log给分开，可以从MVCC的角度理解：</p><p>undo log既可以实现数据事务的回滚，页可以用于实现MVCC中，对数据的上一个版本的回推（查找过往数据）</p><p>MySQL的undo log和数据是放在一起的，而redo log是单独分开的</p><br><br><br><h1 id="Checkpoints"><a href="#Checkpoints" class="headerlink" title="Checkpoints"></a>Checkpoints</h1><p>背景：</p><p>1、WAL如果不做一些其他的操作，日志就会无限增长</p><p>2、日志的不断增长，会导致DBMS一旦崩溃，在恢复的时候就需要读取大量的日志，极其耗费时间</p><br><br><p>因此，DBMS会定期写下一个检查点（<strong>checkpoint</strong>）</p><p>在这个检查点之前的日志和内存中的数据页，全部都会被写入磁盘</p><p>那么当DBMS崩溃后，数据的恢复从checkpoint的位置开始恢复即可</p><br><br><h2 id="Challenges"><a href="#Challenges" class="headerlink" title="Challenges"></a>Challenges</h2><p>当写入检查点时，我们必须暂停所有事务以确保快照的一致性（所有的操作都会停止；而暂停会导致吞吐下降）</p><br><p>在崩溃恢复的时候，对于未提交的事务，要执行undo操作</p><p>需要扫描过往日志，可能需要花费很长的时间</p><br><p>DBMS执行检查点的频率应该控制在什么范围内？（或者说数据库多长时间存档一次）</p><ul><li>太频繁会损耗性能</li><li>太稀少又会导致恢复用的时间变长，同时日志太多也会浪费空间</li></ul><br><br><h2 id="Frequency"><a href="#Frequency" class="headerlink" title="Frequency"></a>Frequency</h2><p>检查点会太频繁会导致运行时性能下降（系统花费太多时间刷新缓冲区，给用户的体验就是非常的卡顿）</p><p>而checkpoint时间频率低也不行（会使得恢复时间变长，同时日志浪费空间）</p><br><p>发现存档并没有一个非常确定的方案，只有和具体的工程实践相结合才有最优解</p><br><br><br><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>WAL几乎是处理易失性存储丢失的最佳办法（并且WAL是连续写，性能上优于随机写）</p><p>使用带有checkpoint的增量更新（steal + no force）</p><p>在恢复时：使用undo logo对未提交事务进行回滚，使用redo log对提交事务进行恢复</p>]]></content>
      
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> CMU 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 18-Multi-Version Concurrency Control</title>
      <link href="/2022/12/01/cmu-15-445-18-multi-version-concurrency-control/"/>
      <url>/2022/12/01/cmu-15-445-18-multi-version-concurrency-control/</url>
      
        <content type="html"><![CDATA[<h1 id="Multi-version-concurrency-control"><a href="#Multi-version-concurrency-control" class="headerlink" title="Multi-version concurrency control"></a>Multi-version concurrency control</h1><p>多版本并发控制协议（常常和2PL或TOO一起实现并发控制）</p><p>对于DBMS中的每一个数据，都会去记录数据的所有版本（包括历史版本和当前版本）</p><p>DBMS会维护当前所有数据对象的，所有历史版本和当前版本：</p><ul><li>当事务写入数据的时候，DBMS会创建该数据对象的一个新的版本</li><li>当事务读入数据的时候，DBMS会读取当前事务启动时，该数据存在的最新版本</li></ul><br><br><p>为什么会有MVCC的思路？</p><p>从写数据的角度考虑：</p><ul><li>在2PL中，写数据会加上写锁，这会导致其他的事务无法读取该数据</li><li>但，有可能其他的事务只是需要<strong>读取一个历史版本的数据</strong>，那么只要给该事务提供一个原数据的副本，就可以使得两个事务并发执行</li><li>从中发现，如果我们可以保留历史版本的数据，那么就可以提高并发度（因为不会阻塞读操作）</li></ul><br><p>从读数据的角度考虑：</p><ul><li>在2PL中，读取数据会上读锁，这会导致其他的事务无法写入该数据</li><li>但，其他的事务可能只是给原数据添加了一个新的版本，并没有覆盖原来的数据</li><li>这样的话，读取数据的一方，可以继续读取原有版本的数据；写入数据的一方，可以继续写入新的版本的数据</li></ul><br><br><p>总结：</p><p><strong>Writers do not block readers</strong>（留下当前数据的历史版本，从而事务的写操作就不会阻塞其他事务的读操作）</p><p><strong>Readers do not block writers</strong>（读取数据的历史版本，写入数据变成为数据添加新的版本，从而读取数据不阻塞写入数据）</p><p>Read-only txns can read a consistent <strong>snapshot</strong> without acquiring locks（只读的事务，相当于<strong>无锁</strong>的读取一个<strong>一致性</strong>的<strong>快照</strong>）</p><ul><li>可以理解为，当前事务对数据的读取，并不受数据库动态的影响</li><li>读到的都是事务开始时的那个版本</li></ul><p>使用时间戳来记录当前数据的版本号</p><p>同时方便DBMS的回滚（<code>time-travel</code>）</p><ul><li>比如说想要回滚到DBMS三分钟之前的时候的数据，直接指定版本号读取即可</li></ul><br><br><br><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><p>版本链表中的begin表示该版本数据开始的时间，end表示该版本数据截止的时间（如果没有写的话，就代表是至今）</p><p>同时，全局会维护一个<code>txn table</code>，用于互相查明事务的状态</p><img src="\medias\18-Multi-Version-Concurrency-Control\txn status table.png" style="zoom:150%;"><br><br><h2 id="Example1"><a href="#Example1" class="headerlink" title="Example1"></a>Example1</h2><p>T1读数据会检查当前的版本，发现此时版本为T0，因此就直接读取</p><p>T2写数据，发现当前版本小于自身，因此在table中添加一条新的记录（该记录的begin为当前记录的版本号）</p><img src="\medias\18-Multi-Version-Concurrency-Control\mvcc-example_01.png" style="zoom:150%;"><br><br><p>此后，T1又要读数据A，就得找到当前事务对应的版本（即历史版本）读取数据</p><img src="\medias\18-Multi-Version-Concurrency-Control\mvcc-example_02.png" style="zoom:150%;"><br><br><h2 id="Example2"><a href="#Example2" class="headerlink" title="Example2"></a>Example2</h2><p>T1对数据A的读写、T2对数据A的写入，参考Example1（读历史版本，写入新版本）</p><br><p>T2对数据A的读取：</p><p>此时T1的数据还没有提交，T2不能读取T1还未提交的数据（避免脏读）</p><p>因此T2读取的是A0时刻的数据</p><p>PS：可以看出来单单MVCC是无法实现可串行化的（因为可串行化中，T2读取到的应该是T1时刻修改后的数据，但MVCC读到的却是更早的数据）</p><img src="\medias\18-Multi-Version-Concurrency-Control\mvcc-example_03.png" style="zoom:150%;"><br><p>T2对数据A的写入：</p><p>此时T2要修改数据，发现T1有一个未提交的事务数据（即发现了一个未提交的新版本），所以会wait到T1结束，才能继续修改</p><p>T1发生在T2之前，那么T2对数据写的版本必然是最终版本</p><p>如果T2不阻塞，直接写了新版本的数据</p><p>后续T1又重新写了一遍，逻辑上就会出现错误了</p><p>所以T2必须要等到T1commit，才能给数据添加上新的版本</p><br><p>T1对数据A的读取：读取当前事务中上一次添加的版本A1时的数据</p><img src="\medias\18-Multi-Version-Concurrency-Control\mvcc-example_04.png" style="zoom:150%;"><br><p>当T1事务commit以后，T2事务才可以继续往下写数据</p><img src="\medias\18-Multi-Version-Concurrency-Control\mvcc-example_05.png" style="zoom:150%;"><br><br><p><strong>Oracle的最高隔离级别快照隔离（snapshot隔离）</strong>，依靠的就是<strong>MVCC</strong></p><p>只有<code>MVCC</code>的话，是无法实现可串行化的，所以一般都是结合其他方法实现并发的，比如说TO，OCC，2PL</p><p>MVCC不仅仅是并发控制的手段，更是DBMS管理事务的手段</p><p>几乎所有的DBMS都实现了MVCC</p><img src="\medias\18-Multi-Version-Concurrency-Control\mvcc-example_06.png" style="zoom:150%;"><br><br><br><h1 id="Concurrenct-control-protocol"><a href="#Concurrenct-control-protocol" class="headerlink" title="Concurrenct control protocol"></a>Concurrenct control protocol</h1><p>MVCC常常和其他的并发控制协议结合在一起</p><img src="\medias\18-Multi-Version-Concurrency-Control\concurrency control protocol.png" style="zoom:150%;"><br><br><br><h1 id="Version-storage"><a href="#Version-storage" class="headerlink" title="Version storage"></a>Version storage</h1><p>新老版本（不同版本）的数据是如何存储的</p><p>DBMS会使用一个指针，接着建立一个链表记录每个版本的版本号</p><br><br><h2 id="Append-only-storage"><a href="#Append-only-storage" class="headerlink" title="Append only storage"></a>Append only storage</h2><p>简单追加</p><p>每次向DBMS中给数据追加新的版本，都相当于给数据表中追加了一条新的记录，通过指针将不同的版本记录链接起来，组成版本链</p><p>所有数据的所有版本，都存放在同一个表（<code>Main Table</code>）里面</p><img src="\medias\18-Multi-Version-Concurrency-Control\append-only storage.png" style="zoom:150%;"><br><p>追加一个新的数据记录：</p><p>首先要插入最新的数据记录</p><p>接着找到此时除去当前记录外最新的版本，将该版本的指针指向这个新的数据记录</p><br><br><p><code>Main table</code>中链表的两种实现思路</p><img src="\medias\18-Multi-Version-Concurrency-Control\version chain ordering.png" style="zoom:150%;"><br><p>第一种是将新的数据追加到链表后面（<code>Oldest-to-Newest</code>）</p><ul><li>生成新版本时，将老版本的指针指向新版本</li><li>所以访问最新记录时，需要遍历老记录（造成读放大）</li></ul><p>第二种是将新的数据追加到链表前面（<code>Newest-to-Oldest</code>）</p><ul><li>生成新版本时，将新版本的指针指向老版本</li><li>所以访问某个版本的记录时，需要从新记录开始遍历到指定版本</li></ul><img src="\medias\18-Multi-Version-Concurrency-Control\O2N and N2O.png" style="zoom:150%;"><br><br><h2 id="Time-travel-storage"><a href="#Time-travel-storage" class="headerlink" title="Time-travel storage"></a>Time-travel storage</h2><img src="\medias\18-Multi-Version-Concurrency-Control\time-travel storage.png" style="zoom:150%;"><p>main table存储的是当前最新的数据，time-travel table存储的是历史的数据</p><ul><li>main table中的value是最新版本的数据，pointer则指向time-travel table上的历史数据，version是版本号</li></ul><br><p>数据的写入：将老版本的数据复制到time-travel table中，将新版本数据写入main table中，同时调整指针指向（新版本的指针指向老版本）</p><p>数据的回滚：通过main table中最新版本的指针，找到对应的历史版本</p><br><p>比如说，总共有十行记录</p><p>那么main table就只有十行记录的最新版本，而time-travle table中就可能会存放很多的历史版本（这些历史版本都用链表连在一起）</p><br><p>time-travel也是append-only的存储方式，只是新老版本在不同的表空间中。这种方式有利于回收老版本记录，但同时产生了写放大</p><br><img src="\medias\18-Multi-Version-Concurrency-Control\time travel storage.png" style="zoom:150%;"><br><br><h2 id="Delta-storage"><a href="#Delta-storage" class="headerlink" title="Delta storage"></a>Delta storage</h2><p>如果每次只修改了一点点数据，就要把整份数据都放到time-travel table中，那么无疑是一种浪费</p><p>因此一种改进方案就是只存储增量，即存储数据的变化</p><br><p>main table存储原数据，delta storage segment存储每次修改的增量（具体修改了哪些部分）</p><img src="\medias\18-Multi-Version-Concurrency-Control\delta storage.png" style="zoom:150%;"><br><br><p>如果想读取历史版本，就要调用delta storage segment中的记录逐条回滚</p><p>优点：可以节约历史版本大小</p><p>缺点：查看历史版本（或回滚）复杂度高，即恢复（回滚）的时候需要逐步读delat storage segment（可以理解为用时间换取空间）</p><img src="\medias\18-Multi-Version-Concurrency-Control\delta storage.jpg" style="zoom:150%;"><br><p>PS：MySQL使用的就是这种方法，不过MySQL存储的是undo段</p><br><br><br><h1 id="Garbage-collection"><a href="#Garbage-collection" class="headerlink" title="Garbage collection"></a>Garbage collection</h1><p>背景：DBMS不可能无限存储历史的版本，所以要删除掉一些历史版本</p><br><p>垃圾回收的宗旨：</p><ul><li><p>如果任何活跃的事务都看不到这个版本（或是说不需要这个版本），那么这个版本就直接删掉了</p><ul><li><p>例如：有个事务的版本是1，但当前活跃事务的版本都是10以上的，那么事务1的版本就可以删除了</p></li><li><p>或者说，在快照隔离中，如果所有的事务都不需要它了，就要把它删掉</p></li></ul></li><li><p>如果一个事务发生了abort，就需要删除该版本</p></li></ul><br><p>需要考量的问题：</p><ul><li><p>如何发现这些版本</p></li><li><p>什么时候删掉历史版本</p></li></ul><br><br><h2 id="Tuple-level"><a href="#Tuple-level" class="headerlink" title="Tuple level"></a>Tuple level</h2><p>以元组（行记录）为粒度（范围），清理过期记录</p><p>遍历行记录，寻找哪些没有用的行记录</p><br><h3 id="background-vacuuming"><a href="#background-vacuuming" class="headerlink" title="background vacuuming"></a>background vacuuming</h3><p>开启一个后台线程对当前发生的事务和历史版本进行扫描对比，如果有数据的版本是小于当前所有的活跃事务的版本，就要清理掉</p><img src="\medias\18-Multi-Version-Concurrency-Control\tuple-level gc.png" style="zoom:150%;"><br><p>优化技巧：</p><ul><li>后台线程会对所有的数据进行扫描，浪费时间</li><li>而如果当前的数据页被更新过了就标记一下，后续就扫描那些被标记过的数据页即可，而不是全表扫描</li></ul><br><br><h3 id="cooperative-cleaning"><a href="#cooperative-cleaning" class="headerlink" title="cooperative cleaning"></a>cooperative cleaning</h3><p>合作清理</p><p>执行事务的语句在检索版本的时候</p><p>同时查看一下有哪些版本是没有用的</p><p>发现没有用的版本，就删除</p><img src="\medias\18-Multi-Version-Concurrency-Control\tuple-level gc(cooperative cleaning).png" style="zoom:150%;"><br><br><h2 id="Transaction-level"><a href="#Transaction-level" class="headerlink" title="Transaction-level"></a>Transaction-level</h2><p>以事务为单位进行回收，清理旧事务的数据版本</p><br><img src="\medias\18-Multi-Version-Concurrency-Control\transaction-level gc.png" style="zoom:150%;"><p>每次修改数据时，同时记录修改数据之前的旧版本</p><p>过一段时间后，DBMS决定多少版本号之前的事务都可以干掉了，那么就可以遍历事务，然后把数据的老版本给干掉</p><br><br><br><h1 id="Index-management"><a href="#Index-management" class="headerlink" title="Index management"></a>Index management</h1><p>研究在MVCC（多版本）下，如何对索引进行管理</p><p>主键索引指向的是版本链表的第一个，并且一般是物理地址（比如说某个数据具体在哪一个page的哪一个slot）</p><p>如果一个事务修改了主键的值，就要把数据先删除，后插入</p><br><p>比较麻烦的是辅助索引的处理，下图是辅助索引管理的两大流派：</p><img src="\medias\18-Multi-Version-Concurrency-Control\index management.jpg" style="zoom:150%;"><br><br><h2 id="Logical-pointers"><a href="#Logical-pointers" class="headerlink" title="Logical pointers"></a>Logical pointers</h2><p>键（<code>key</code>）存储的是被索引的那一列的数据</p><p>值（<code>value</code>）记录的是逻辑地址（比如说记录的是主键的值，或者行id的值），即逻辑索引</p><p>索引指向一个”中间指针”，即逻辑指针，这个中间指针再指向主表存储的元组的位置（某个页面的某个位置）</p><br><p>优点：</p><ul><li><p>如果数据发生了更新，那么只需要修改主键索引的地址（因为辅助索引指向的是主键索引的位置，不用批量修改辅助索引）</p></li><li><p>对于数据的写入比较友好：如果更新某条记录，则这条记录相关的所有索引都不需要更新，只需要更新”中间指针”指向新的元组的位置即可</p></li></ul><br><p>缺点：</p><ul><li>存在读放大问题，所有索引访问数据都需要先访问”中间指针”，再跳转到实际数据存储位置，即存在<strong>回表</strong>的过程</li></ul><img src="\medias\18-Multi-Version-Concurrency-Control\index pointers_02.png" style="zoom:150%;"><br><p>PS：MySQL InnoDB就是使用逻辑指针的方式，所有索引都指向主键，通过主键再去访问真实的数据</p><br><br><h2 id="Physical-pointers"><a href="#Physical-pointers" class="headerlink" title="Physical pointers"></a>Physical pointers</h2><p>键（<code>key</code>）存储的是被索引的那一列的数据</p><p>值（<code>value</code>）记录的是物理索引（比如说某个数据具体在哪一个page的哪一个slot）</p><br><p>优点：</p><ul><li>对于读比较友好，索引指向元组的实际位置，直接就可以访问到元组，无需通过中间指针进行跳转（不需要回表）</li></ul><br><p>缺点：</p><ul><li>如果辅助索引记录的是数据记录的物理地址，那么当有新的版本数据到来的时候，所有的辅助索引上数据记录都要修改（特别是在辅助索引数量很多的情况下，复杂度<code>upup</code>）</li><li>因此不利于写，如果更新了某条记录的位置，则相关的索引都需要更新，造成写放大</li></ul><img src="\medias\18-Multi-Version-Concurrency-Control\index pointers_01.png" style="zoom:150%;"><br><p>PS：PostgreSQL使用这种方式，所以更新记录时成本较高</p><br><br><br><h1 id="MVCC-index"><a href="#MVCC-index" class="headerlink" title="MVCC index"></a>MVCC index</h1><p>DBMS的索引一般是不会保存数据的版本号的</p><p>但MVCC有快照，因此索引需要保存冗余的数据（即冗余的键）</p><p>即一个键，可能会指向多个值（多个版本）</p><br><p>为什么要存储冗余的数据？</p><p>T1第一次读数据A</p><p>T2修改了数据A后又删除了数据A</p><p>T3在原来的位置插入了新的数据A</p><p>问题是：T3插入数据的时候，形成了新的版本</p><p>而因为T3认为此时没有数据，此时产生的新版本号是A1</p><p>导致版本号出现了重复的情况，那么此时T1重复读取数据的时候，就会出现问题</p><p>所以就需要存储冗余的键值，以此实现隔离级别（比如此时的数据A，需要维护T1指向的A1的版本和T3指向A1的版本）</p><img src="\medias\18-Multi-Version-Concurrency-Control\mvcc duplicate key problem.png" style="zoom:150%;"><br><p>因此每个索引上需要维护多个版本的数据，更需要额外的逻辑去维护唯一约束等问题</p><br><br><br><h1 id="MVCC-deletes"><a href="#MVCC-deletes" class="headerlink" title="MVCC deletes"></a>MVCC deletes</h1><p>DBMS一般不会在物理上将数据从数据库中删除</p><p>只有当该数据的所有版本在逻辑上被删除（即逻辑上该数据的所有版本都没有用的时候），才会将数据真正删除</p><p>因此，一般数据的删除都是指逻辑上的删除，而不是物理内存上的删除（需要保存历史版本，进行一些处理）</p><p>所以，需要一些方法来查看数据是否在逻辑上被删除</p><br><br><h2 id="Deleted-flag"><a href="#Deleted-flag" class="headerlink" title="Deleted flag"></a>Deleted flag</h2><p>在行记录上加上一个列，用于判断数据是否被删除</p><br><br><h2 id="Tombstone-tuple"><a href="#Tombstone-tuple" class="headerlink" title="Tombstone tuple"></a>Tombstone tuple</h2><p>给这个行记录添加一个新的版本（是没有数据的），相当于是一个墓碑</p><p>代表这个版本之前所有的版本，都是被删掉的</p><p>而在这个墓碑之后新的版本，是正常添加的</p><br><br><br><h1 id="MVCC-implementations"><a href="#MVCC-implementations" class="headerlink" title="MVCC implementations"></a>MVCC implementations</h1><img src="\medias\18-Multi-Version-Concurrency-Control\mvcc implementations.png" style="zoom:150%;"><p>比较core的部分：</p><p>protocol（MVCC和什么手段结合）</p><p>version storage（版本管理，版本存储的方案）</p><p>garbage collection（垃圾回收）</p><p>辅助索引（是logical还是physical的）</p><br><br><br><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>几乎所有的关系型数据库都实现了MVCC，但一般是搭配着其他的并发控制协议使用（比如2PL，OCC等）</p><p>当然，也有部分NoSQL也在使用，比如RocksDB</p><br><br><br><h1 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h1><p>关于读写冲突（写读冲突，同理）</p><ul><li>普通2PL，因为有事务A先拿了读锁，以至于另一个事务B拿不了写锁，另一个事务B必须等到事务A放锁了以后，才能继续往下走拿到写锁</li><li>而MVCC，事务A读不加锁，直接读，然后事务B写一个新的版本放入storage，接着如果事务A继续读的话，读历史版本即可</li><li>由此可见2PL和MVCC都可以解决读写冲突，但MVCC没有锁，没有阻塞，提高了效率和并发度</li></ul><br><p>而因为是用了类似TO的时间戳，MVCC也解决了写写冲突的问题</p><br><br><p>现有的2PL、严格2PL + 间隙锁就可以实现很多的隔离级别，为什么还需要MVCC？</p><ul><li>我觉得使用MVCC可以提高并发度，一定程度的不阻塞读（依靠的是历史版本数据）</li><li>2PL其实是可以实现的，但是会减损一些并发度，所以要使用MVCC（使得原本的范围变得宽松而合理一些）</li><li>从另一个角度说，MVCC需要2PL，因为单靠MVCC无法实现可串行化（参考Example2）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> CMU 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 17-Timestamp Ordering Concurrency Control</title>
      <link href="/2022/11/28/cmu-15-445-17-timestamp-ordering-concurrency-control/"/>
      <url>/2022/11/28/cmu-15-445-17-timestamp-ordering-concurrency-control/</url>
      
        <content type="html"><![CDATA[<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>并发控制的两个流派：悲观的2PL，乐观的OCC</p><br><p>上一章讲到的2PL其实是一种<strong>悲观</strong>的并发控制协议</p><p>它假设未来所有的事务都会发生竞争，所以在操作每一条SQL的时候都会提前加上锁</p><p>即在问题发生之前解决问题，阻止问题的发生</p><p>这种悲观的并发控制协议的缺点，主要是会降低并发度，降低性能</p><p>而另一种<strong>乐观</strong>的并发控制协议，便是本章说的基于时间戳顺序的并发控制协议</p><img src="\medias\17-Timestamp-Ordering-Concurrency-Control\2PL and TOO.png" style="zoom:150%;"><br><br><h2 id="T-x2F-O-Concurrency-Control"><a href="#T-x2F-O-Concurrency-Control" class="headerlink" title="T&#x2F;O Concurrency Control"></a>T&#x2F;O Concurrency Control</h2><p>针对每个事务，给它赋予时间戳，根据事务的时间戳决定它的执行顺序</p><p>如果<code>Ti</code>的时间戳小于<code>Tj</code>的时间戳，那么DBMS要保证，相当于<code>Ti</code>完全先发生，<code>Tj</code>完全后发生</p><img src="\medias\17-Timestamp-Ordering-Concurrency-Control\TO_01.png" style="zoom:150%;"><br><br><h2 id="Timestamp-allocation"><a href="#Timestamp-allocation" class="headerlink" title="Timestamp allocation"></a>Timestamp allocation</h2><p>会给每个事务一个<strong>单调递增</strong>的<strong>独一无二</strong>的时间戳</p><p>实现递增时间戳的不同方法：</p><ul><li><code>System Clock</code>（系统时钟，即OS的时钟）<ul><li>有时会出问题，电脑的时间不完全精确（手机电脑的时钟都是不精确的，之所以如此精确是因为同步机制，每隔一段时间进行时间的校验）</li><li>比如说电脑的时钟每天都会慢一分钟，那么可能会在某个同步的时候，将时钟的时间给调回去</li><li>因此有可能有这种情况：时间A的来了一个事务a，系统时钟校验后居然校验到了时间A，而此时事务b来了，二者的时间戳变一样的了</li></ul></li><li><code>Logical Counter</code>（逻辑计数器）<ul><li>简单计数实现先后，从而避免系统时钟跳变的问题</li><li>分布式系统的问题在于很难在多个机子之间做计数器的校准：如果两个结点同时接收到一个事务，那么counter的校准就出现了问题</li><li>比如说在北京的节点收到了一个新的事务，但远在德国的节点是不能够立刻知道的</li><li>同时，如果德国的节点同时也接收到一个新的事务，就有可能出现这两个事务的时间戳是完全相同的</li></ul></li><li><code>Hybrid</code>（System Clock + Logical Counter，HLC）</li></ul><br><br><br><h1 id="Basic-timestamp-ordering-protocol"><a href="#Basic-timestamp-ordering-protocol" class="headerlink" title="Basic timestamp ordering protocol"></a>Basic timestamp ordering protocol</h1><p>本并发控制协议，读写数据都不需要加锁</p><p>数据库中的所有对象（tuple，即每行记录）都要附上两个时间戳：</p><ul><li>读时间戳（<strong>W-TS</strong>，上次读这个行记录的事务的时间戳）</li><li>写时间戳（<strong>R-TS</strong>，上次写这个行记录的事务的时间戳）</li></ul><p>每一次操作数据的时候，都要检查<strong>当前事务的时间戳</strong>和<strong>上一次操作该数据事务的时间戳</strong>，将二者进行比较</p><p>主要的宗旨：<strong>不能操作来自未来的数据</strong></p><img src="\medias\17-Timestamp-Ordering-Concurrency-Control\Basic TO.png" style="zoom:150%;"><br><br><h2 id="Basic-T-x2F-O-READS"><a href="#Basic-T-x2F-O-READS" class="headerlink" title="Basic T&#x2F;O READS"></a>Basic T&#x2F;O READS</h2><p>假如此时读一个数据，发现上次修改该事务的id（写时间戳）大于当前的id，那当前事务就不能读该数据</p><ul><li>那么此时当前事务就得回滚，然后重开一个新的事务（因为不能读到未来的数据）</li></ul><p>反过来，如果上次修改该事务的id（写时间戳）小于当前的id，那么就是合法的，就可以继续读数据</p><ul><li>就是说，在我之前的事务操作过后的数据，当前事务是可以操作的</li><li>紧接着就是更新该数据的读时间戳（变为<code>max（当前事务的时间戳，当前数据的读时间戳）</code>）</li><li>最后还需要将读到的数据，拷贝一个副本到本地（因为这个数据，后面可能会被其他的事务修改了，为了读到正确的版本，需要留一份备份；以便后续读数据的时候，读到的是本地的快照）</li></ul><img src="\medias\17-Timestamp-Ordering-Concurrency-Control\Basic TO READS.png" style="zoom:150%;"><br><br><h2 id="Basic-T-x2F-O-WRITES"><a href="#Basic-T-x2F-O-WRITES" class="headerlink" title="Basic T&#x2F;O WRITES"></a>Basic T&#x2F;O WRITES</h2><p>如果当前事务的时间戳小于当前数据记录的读时间戳（或写时间戳）</p><ul><li>那么当前事务就需要回滚，并重新开始一个新的事务</li><li>如果一个被未来的事务读过或写过的数据，当前事务还去操作它，那么就不会和TO的宗旨（不能修改来自未来的数据）</li></ul><p>否则，即当前事务的时间戳大于该数据记录的读时间戳和写时间戳，当前事务才可以写该数据记录</p><ul><li>那么当前事务就可以操作该数据</li><li>并且还要将操作后的数据备份到本地，以便后续重复读取</li><li>换句话说，这个数据所有的操作都发生在过去，当前事务才可以继续操作</li></ul><img src="\medias\17-Timestamp-Ordering-Concurrency-Control\Basic TO WRITES.png" style="zoom:150%;"><br><br><h3 id="Thomas-write-rule"><a href="#Thomas-write-rule" class="headerlink" title="Thomas write rule"></a>Thomas write rule</h3><p>TO在写数据时的一个优化规则：</p><p>如果此时事务的时间戳是小于数据的读时间戳的话，那只能abort</p><ul><li>因为这个数据未来要有人读，我就不能先在改变</li></ul><p>但如果此时事务的时间戳小于数据的写时间戳</p><ul><li>就表明未来有事务要修改这个数据</li><li>也意味着即使当前事务修改了这个数据，后续依旧是有事务会将他覆盖掉</li><li>所以可以将本次的数据写成一个副本到本地（方便当前事务中，后面的语句重复读取），而不是写到具体的数据库上</li><li>然后继续往下执行（反正这里未来会被覆盖掉）</li></ul><img src="\medias\17-Timestamp-Ordering-Concurrency-Control\Thomas write rule.png" style="zoom:150%;"><br><br><h2 id="Recoverable-schedules"><a href="#Recoverable-schedules" class="headerlink" title="Recoverable schedules"></a>Recoverable schedules</h2><img src="\medias\17-Timestamp-Ordering-Concurrency-Control\Recoverable Schedules_01.png" style="zoom:150%;"><p>使用TO，存在的一个问题是：后续事务读取的数据，<strong>默认是前面的事务已经提交了的</strong></p><p>可是，如果前面的事务发生了回滚，那么后续的事务读取的数据便是脏读了</p><p>因为事务的回滚恢复是按照顺序恢复的，即要先恢复前面的事务再恢复后面的事务</p><p>但是你前面的事务都回滚了，后面的事务又是基于前面的事务的，那后面的事务就无法回滚了（亦或是说回滚的到的是脏数据）</p><p>即<code>basic top</code>，是无法恢复的（比如下图）</p><img src="\medias\17-Timestamp-Ordering-Concurrency-Control\Recoverable Schedules_02.png" style="zoom:150%;"><br><p>另外一个问题便是：这种算法会复制一份当前的数据（主要是为了实现可重复读，即保持事务中数据前后读取的一致性）</p><p>但如果我们要进行全表扫描的话，那么就会造成把整个数据库的数据都复制了一份，非常浪费空间</p><br><br><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>优点：</p><p>不存在加锁、释放锁的过程；不存在死锁等情况</p><br><p>缺点：</p><p>执行流程非常长的事务会导致<strong>饥饿</strong></p><p>比如说有个非常早就开始的事务，它需要读取的内容非常的多</p><p>但是它可能会发现需要操作的数据都被未来的事务修改</p><p>造成该事务只能被迫的不断地abort（而重启后执行地代价又很大）</p><img src="\medias\17-Timestamp-Ordering-Concurrency-Control\Basic TO_01.png" style="zoom:150%;"><br><br><h2 id="Observation"><a href="#Observation" class="headerlink" title="Observation"></a>Observation</h2><p>如果当前的事务比较短，事务的竞争比较少，那么无锁的方法是最好的</p><img src="\medias\17-Timestamp-Ordering-Concurrency-Control\TO_Observation.png" style="zoom: 150%;"><br><br><br><h1 id="Optimistic-concurrency-control"><a href="#Optimistic-concurrency-control" class="headerlink" title="Optimistic concurrency control"></a>Optimistic concurrency control</h1><p>虽然说是基于乐观的并发控制，但本质上还是TO（基于时间戳实现的；毕竟时间戳方法是不加锁的）</p><p>DBMS为每一个事务在本地都创建一个私有的空间，读取的所有数据都会保存在本地</p><p>并且每次修改的数据都保存在本地，而不是写到数据库里面</p><p>等到真正要提交的时候，会将本地的数据和数据库已有的数据进行比对</p><p>如果和别的事务操作的结果，是没有冲突的，就会全部提交数据（发生了冲突就会abort）</p><br><p>OCC主要分为三个阶段：<code>Read phase</code>（读阶段），<code>Validation phase</code>（校验阶段），<code>Write phase</code>（写入阶段）</p><br><br><h2 id="Read-phase"><a href="#Read-phase" class="headerlink" title="Read phase"></a>Read phase</h2><p>读阶段，是对于数据库来说的，是指将数据从数据库拷贝到本地的私有空间中（为了实现可重复读）</p><p>后续对数据的操作（读写数据），都是针对本地私有空间中的数据而言的</p><p>可以认为是将对数据的操作，都在本地执行</p><br><br><h2 id="Validation-phase"><a href="#Validation-phase" class="headerlink" title="Validation phase"></a>Validation phase</h2><p>校验阶段，是指将私有空间的数据提交到数据库中，发生在commit阶段</p><p>把当前提交的数据和别的事务提交的数据，进行比较，检查是否有发生冲突</p><p>如果没有发生冲突，就进入下一个步骤</p><p>PS：<strong>在进入校验阶段的时候，才会获取到具体的时间戳</strong>（参考时间戳排序；需要保证小时间戳先发生，大时间戳后发生）</p><ul><li>也就是说，在此之前都是没有时间戳的</li></ul><p>检查冲突的大概思路：检查事务的读写冲突和写写冲突，有没有成环</p><p>而检查冲突又分为两种方法：<code>backward validation</code> 和<code>forward validation</code></p><br><br><h3 id="Backward-validation"><a href="#Backward-validation" class="headerlink" title="Backward validation"></a>Backward validation</h3><p>检验过去事务的数据，向前校验（向已经发生了、提交了的事务的数据进行校验）</p><p>比较一下，看有没有成环的冲突（即检查他们是否是可串行化的）：</p><ul><li><p>没有冲突的话就提交</p></li><li><p>有冲突的话就要abort当前事务（不能abort历史的事务数据）</p></li></ul><br><br><h3 id="Forward-validation"><a href="#Forward-validation" class="headerlink" title="Forward validation"></a>Forward validation</h3><p>检验未来事务的数据，向后校验（问题是未来的事务还有一部分没有做，不知道未来会发生什么）</p><p>所以这里是校验未来事务和当前事务交叠的部分，还没发生的部分无法校验</p><p>因此，如果发生了冲突，这里可以灵活的选择是abort当前事务，还是哪些还在进行的事务（因为这两个事务都没有commit）</p><img src="\medias\17-Timestamp-Ordering-Concurrency-Control\forward validation.png" style="zoom:150%;"><br><p>而校验又分为以下三种情况：</p><br><p><strong>情况一</strong>：两个事务的执行步骤就是串行化执行的，那么校验阶段就不存在数据可以校验</p><img src="\medias\17-Timestamp-Ordering-Concurrency-Control\forward validation_step_01.png" style="zoom:150%;"><br><br><p><strong>情况二</strong>：T1先执行，T2后执行，T1的写操作是在T2的读操作之前</p><p>这样造成的问题就是，事务的修改一开始都是放到T1里面的私有空间里面，还没有提交（即还没有进入validation phase）</p><p>那么此时T2读取到的数据就是还没有被T1修改过的数据</p><p>因此T1在validation phase的时候，就会发现来自未来的事务（即T2）的Read phase在此之前执行了</p><p>T1就需要被迫abort（因为这不符合串行化的规则）</p><img src="\medias\17-Timestamp-Ordering-Concurrency-Control\forward validation_step_02.png" style="zoom:150%;"><br><br><p><strong>情况三</strong>：T1的完成READ阶段的时机早于T2的完成READ阶段的时机，同时在此刻，T1已经读取和写入的数据都和T2已经读取和写入的数据没有交集</p><p>在这种情况下，T1的validation阶段是安全的，因为它保证了T2读取的数据，要么是没被T1操作过的数据，要么是已经被T1操作完提交了的数据</p><img src="\medias\17-Timestamp-Ordering-Concurrency-Control\forward validation_step_03.png" style="zoom:150%;"><br><br><h2 id="Write-phase"><a href="#Write-phase" class="headerlink" title="Write phase"></a>Write phase</h2><p>写入阶段，是指数据校验成功以后，将数据写入到具体的磁盘上</p><p>而在一些DBMS的实现上，在写入阶段会将整个数据库的数据表给上锁（主要是为了防止并发问题）</p><p>而且，因为此时是已经准备好了所有需要写入的数据，所以写入的时间是可控的（一般来说执行的时间很短，是可以接受的）</p><p>即不同事务的写入是要排队进行写入，不能同时并发写入数据的（因此会牺牲一定的并发度）</p><br><br><h2 id="Observations"><a href="#Observations" class="headerlink" title="Observations"></a>Observations</h2><p>OCC在冲突比较少的场景是高效的（因为冲突太多，会造成事务都在validation阶段回滚，而且回滚的成本很高，低效）</p><ul><li>在所有的事务都是只读操作的情况下，OOC的效果最好</li><li>或者说不同的事务之间并发执行，但是事务间基本上没有冲突（在validation阶段不存在回滚）</li></ul><p>当数据库的数据量非常大，同时针对数据的查询是均衡的（不存在热点数据），在这种情况下冲突较少，OCC的效果就很好（因为比较少冲突的情况下，使用mutex就是浪费）</p><br><p><strong>缺点</strong>：</p><p>数据的拷贝存在一定的开销（但是read阶段只是读取数据，性能不错）</p><p>Validation阶段逻辑复杂，校验流程冗杂</p><p>Write阶段会锁全表（顺序写表，不能并发写，导致并发度低下）</p><p>Abort的成本会比2PL的更大（2PL有死锁预防和检测，但是OCC是在事务执行完了以后才发现死锁or冲突，才将事务回滚，资源浪费严重）</p><br><br><br><h1 id="Partition-based-T-x2F-O"><a href="#Partition-based-T-x2F-O" class="headerlink" title="Partition-based T&#x2F;O"></a>Partition-based T&#x2F;O</h1><p>参考全局锁到分段锁的优化，OCC也可以将数据库分为若干个不相交的子集（可以水平分区，也可以垂直分区）</p><img src="\medias\17-Timestamp-Ordering-Concurrency-Control\partition-based_01.jpg" style="zoom: 67%;"><p>在各个partition上执行OCC，并且不同partition上的事务之间不需要检查冲突</p><img src="\medias\17-Timestamp-Ordering-Concurrency-Control\partition-based_02.jpg" style="zoom: 50%;"><br><p>每个partition都需要用mutex进行保护</p><ul><li>每个partition都维护一个执行队列</li><li>每个事务都会在其需要操作的partition上排队，如果该事务在该队列拥有最小的时间戳，就会获得锁并执行</li><li>当事务获取到所需要的所有partitions上的锁时，事务才会开始执行（事务启动后，它可以读取写入所有分区的锁）</li><li>事务在执行的时候就已经被分配好了时间戳</li></ul><br><br><h2 id="Partition-based-T-x2F-O-read"><a href="#Partition-based-T-x2F-O-read" class="headerlink" title="Partition-based T&#x2F;O read"></a>Partition-based T&#x2F;O read</h2><p>事务可以在<strong>已经获取了锁的partition</strong>上读取任何内容</p><p>但如果事务试图读取一个<strong>没有获取锁的partition</strong>，将会被abort并重启</p><br><br><h2 id="Partition-based-T-x2F-O-write"><a href="#Partition-based-T-x2F-O-write" class="headerlink" title="Partition-based T&#x2F;O write"></a>Partition-based T&#x2F;O write</h2><p>事务所有的写操作都是在数据库上发生</p><p>DBMS会在内核维护一个缓冲区，用来记录数据的变更（以便事务的回滚）</p><p>如果事务试图写入修改一个<strong>没有获取锁的partition</strong>，将会被abort并重启</p><br><br><p>在以下情景下，OCC是迅速高效的：</p><ul><li>DBMS在事务启动之前就知道它需要使用哪些partition</li><li>大多数事务的操作都只需要访问单个分区</li></ul><br><br><br><h1 id="Dynamic-databases"><a href="#Dynamic-databases" class="headerlink" title="Dynamic databases"></a>Dynamic databases</h1><p>此前并发协议的设计中，都忽略的一点就是新数据的插入和旧数据的删除</p><h2 id="Phantom-problem"><a href="#Phantom-problem" class="headerlink" title="Phantom problem"></a>Phantom problem</h2><p><strong>幻读</strong>：是TO、OCC和2PL都没有考虑的问题</p><ul><li>因为此前的并发控制协议中，认为写数据都是在已有的数据上进行修改</li><li>一种被忽略的情况是：写数据是可以凭空写一个新的数据到表里面的（即<code>insert</code>和<code>delete</code>）</li><li>为什么2PL解决不了？因为mutex只能锁当前的数据，无法控制新数据的插入（可以使用全表锁，但是并发度和性能都会受损）</li></ul><br><p>执行两条SQL，前后读出的内容不一致，好像出现了幻觉</p><p>原因是在这期间发生了有新数据insert</p><p>可以理解为第二次读取到了，第一次读取时数据库中不存在的数据</p><img src="\medias\17-Timestamp-Ordering-Concurrency-Control\the phantom problem_01.png" style="zoom:150%;"><br><p>与不可重复读、脏读的对比：</p><p>比如说查找当前的max值，第一次是A，然后其他的事务添加了数据B，使得当前的max变为了数据B，导致第二次读的时候返回的是数据B，这是<strong>幻读</strong>（侧重的是新数据的插入）</p><p>而针对同一条数据，第一次和第二次读取前后，数据不一致，这是<strong>不可重复读</strong>（侧重的是同一条数据的读取）</p><p>而如果读到的是未提交事务的数据，这是<strong>脏读</strong></p><br><br><h3 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h3><p>常见的三种解决办法：</p><br><p>Approach 1：<strong>re-execute scans</strong></p><p>记录一下事务所有能够出现幻读的地方（例如：查询max，min值、范围查询等）</p><p>在commit前再扫描一遍这些可能出现幻读的地方</p><p>缺陷：多次内存的读取，浪费资源，性能差</p><br><br><p>Approach 2：<strong>predicate locking</strong>（谓词锁）</p><p>给SQL的WHERE谓词加共享锁</p><p>给UPDATE、INSERT、DELETE上加独占锁</p><p>比如下图，WHERE上加了共享锁，那么后续INSERT要加独享锁就会阻塞</p><img src="\medias\17-Timestamp-Ordering-Concurrency-Control\predicate locking.png" style="zoom:150%;"><br><br><p>Approach 3：<strong>index locking</strong>（索引锁）</p><p>如果给定的语句里面有索引的话，就要给这个索引所在的索引页加上锁</p><p>如果没有索引，就要给它加上表锁</p><p>主要目的就是不能让他添加或删除新数据</p><br><br><p>MySQL的实现：<strong>间隙锁</strong></p><p>MySQL将数据和数据之间的间隙也认为是数据，例如max的查询中，将数据和数据之间的间隙上锁</p><p>如果要操作的数据是有索引的，那么就直接将区间<code>[当前max值,正无穷)</code>给上锁</p><ul><li>比如说第一次找到max为20，就给区间<code>[20,max)</code>上锁</li></ul><br><br><h2 id="Isolation-levels"><a href="#Isolation-levels" class="headerlink" title="Isolation levels"></a>Isolation levels</h2><h3 id="Weaker-levels-of-isolation"><a href="#Weaker-levels-of-isolation" class="headerlink" title="Weaker levels of isolation"></a>Weaker levels of isolation</h3><p>已经实现了的事务并发协议，都是为了能够将事务的执行顺序，等效的转化为串行化</p><p>但是实际业务可能并不需要如此严格的隔离级别</p><p>一些比较weaker的隔离级别也可以实现业务（只要程序员coding的时候了解该隔离级别即可）</p><br><p>另一方面，如果强制要求可串行化</p><p>对于乐观的并发控制协议（TO、OCC），可能会出现很多abort的情况</p><p>而对于悲观的并发控制协议（2PL），则会出现死锁、锁等待等情况</p><p>因此得到的一个思路便是：是否可以降低隔离的程度，以便提高性能；因此就有了隔离级别</p><p>隔离级别，换句话说就是控制事务之间数据的暴露程度</p><br><p>而事务的互相暴露，则会有不同的问题发生：</p><ul><li>脏读（读未提交）</li><li>不可重复读</li><li>幻读</li></ul><br><br><p><strong>隔离级别</strong></p><p>PS：并不是只有这四种隔离级别，比如Oracle的最高隔离级别是<strong>快照隔离</strong></p><img src="\medias\17-Timestamp-Ordering-Concurrency-Control\Isolation levels_06.png" style="zoom:150%;"><br><br><p><strong>不同隔离级别的实现</strong></p><img src="\medias\17-Timestamp-Ordering-Concurrency-Control\Isolation levels_07.png" style="zoom:150%;"><br><p>可串行化的实现：所有的读写数据都要加锁，并且还要加索引锁（防止幻读），同时严格遵守SS2PL</p><p>可重复读的实现：所有的读写数据都要加锁，同时严格遵守SS2PL（所以会有幻读）</p><p>读已提交的实现：所有的读写数据都要加锁，同时遵守<strong>弱</strong>SS2PL，但S lock是用完后立刻释放（所以会有幻读和不可重复读）</p><p>读未提交的实现：所有的读写数据都要加锁，同时遵守<strong>弱</strong>SS2PL，但没有S lock（所以会有幻读、不可重复读和脏读）</p><br><br><p><strong>不同数据库对隔离级别的支持</strong></p><img src="\medias\17-Timestamp-Ordering-Concurrency-Control\Isolation levels_08.png" style="zoom:150%;"><br><br><h2 id="Database-admin-survey"><a href="#Database-admin-survey" class="headerlink" title="Database admin survey"></a>Database admin survey</h2><p>实际工作中对隔离级别的需求：</p><img src="\medias\17-Timestamp-Ordering-Concurrency-Control\database admin survey.png" style="zoom:150%;"><br><br><h2 id="SQL-92-access-modes"><a href="#SQL-92-access-modes" class="headerlink" title="SQL-92 access modes"></a>SQL-92 access modes</h2><p>可以通过语句指定当前需要的隔离级别</p><img src="\medias\17-Timestamp-Ordering-Concurrency-Control\SQL-92 access modes.png" style="zoom:150%;"><br><br><br><h1 id="Conclusion-1"><a href="#Conclusion-1" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>并发控制协议的两大流派：乐观（TP，OCC）和悲观（2PL，SS2PL）</p><p>TO主要是通过给不同的事务一个严格递增的id，通过id的先后以及读写顺序，来维持可串行化，以此来找到一些并发度较高的最优解</p>]]></content>
      
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> CMU 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 16-Two Phase Locking</title>
      <link href="/2022/11/27/cmu-15-445-16-two-phase-locking/"/>
      <url>/2022/11/27/cmu-15-445-16-two-phase-locking/</url>
      
        <content type="html"><![CDATA[<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>上一章的分析都是基于事务已经发生了，然后再去判断分析是否可行</p><p>但实际上是不可能这么顺利的，因为我们不知道整个事务是怎么运行的</p><p>所以很自然的想到用锁实现多个事务的并发，从而实现对数据的保护</p><br><br><br><h1 id="Lock-types"><a href="#Lock-types" class="headerlink" title="Lock types"></a>Lock types</h1><img src="\medias\16-Two-Phase-Locking\locks and latches.png" style="zoom:150%;"><br><br><h2 id="Latches"><a href="#Latches" class="headerlink" title="Latches"></a>Latches</h2><p>是微观的概念</p><p>使用在底层的数据结构（比如说B树、红黑树、B+树、hash表等）</p><br><br><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>是宏观的概念</p><p>对数据库的抽象的内容的锁</p><p>对于用户来说，是获取一条数据的lock，而真正去操作这条数据的时候，比如说操作B+树，才会去操作latches</p><p>所以说lock锁的是具体的数据表或者数据行</p><br><p>lock的类型：</p><ul><li>S-LOCK：shared lock，共享锁，读锁</li><li>X-LOCK：exclusive lock，排他锁，写锁</li></ul><img src="\medias\16-Two-Phase-Locking\lock types.png" style="zoom:150%;"><br><p>DBMS使用lock的过程：</p><ul><li>事务需要锁</li><li>锁管理器要么给锁（锁是空闲的），要么阻塞（锁给其他事务了）</li><li>事务释放锁</li><li>锁管理器更新锁的使用情况</li></ul><br><br><br><h1 id="Two-phase-locking"><a href="#Two-phase-locking" class="headerlink" title="Two-phase locking"></a>Two-phase locking</h1><h2 id="2PL"><a href="#2PL" class="headerlink" title="2PL"></a>2PL</h2><p>把锁用在并发控制中，决定了一个事务在运行过程中如何和其他的事务进行协调</p><p>不需要知道提前知道事务做了什么</p><p>PS：2PL是针对单个事务的整体拿锁释放锁来说的</p><p>用二阶段锁的事务执行顺序，用依赖图表示是没有环的</p><br><img src="\medias\16-Two-Phase-Locking\two-phase locking.png" style="zoom:150%;"><img src="\medias\16-Two-Phase-Locking\two-phase locking_01.png" style="zoom:150%;"><p>阶段一：<code>growing</code></p><ul><li>事务只能不断的加锁，不能解锁</li><li>lock manager在这个阶段要么给锁，要么阻塞（此时lock被其他事务获取了）</li></ul><br><p>阶段二：<code>shrinking</code></p><ul><li>事务在这个阶段只能解锁，不能加锁</li></ul><br><p>2PL会出现级联终止的问题（即<strong>脏读</strong>）</p><img src="\medias\16-Two-Phase-Locking\2PL-cascading aborts.png" style="zoom:150%;"><ul><li>T1先做一部分，T2基于T1的数据再做一部分，结果T1要回滚了，导致T2读取了未提交事务的数据</li><li>问题就在于T2是基于T1还未提交的一个版本进行的</li></ul><br><br><h2 id="Strong-Strict-2PL"><a href="#Strong-Strict-2PL" class="headerlink" title="Strong Strict 2PL"></a>Strong Strict 2PL</h2><p>针对级联终止的问题，使用严格二阶段锁（SS2PL）可以解决</p><img src="\medias\16-Two-Phase-Locking\SS2PL.png" style="zoom:150%;"><p>原来的二阶段锁，在shrinking的时候，是可以边操作边解锁的</p><p>而严格二阶段锁，是指一定程度后锁的数量会保持不变，到了最后事务commit的时候才会释放所有的锁</p><p>即事务修改的数据，一直到事务提交之前，别人都不能修改</p><br><p><strong>优点</strong>：不会出现级联回滚；事务中间可能对数据又多次操作，但是不用管，直接回滚到事务之前的版本即可；被abort的txn可以通过恢复到原始数据来消除影响</p><br><img src="\medias\16-Two-Phase-Locking\universe of schedules_01.png" style="zoom:150%;"><br><p>2PL基本上都会遇到死锁的情况</p><p>解决办法：deadlock detection and prevention</p><br><br><br><h1 id="Deadlocking-detection-prevention"><a href="#Deadlocking-detection-prevention" class="headerlink" title="Deadlocking detection + prevention"></a>Deadlocking detection + prevention</h1><p>无论是2PL，还是SS2PL，都可能会产生死锁饥饿的情况</p><img src="\medias\16-Two-Phase-Locking\shit just got read,son.png" style="zoom:150%;"><br><p>解决办法：</p><ul><li>deadlock detection（死锁检测）</li><li>deadlock prevention（死锁预防）</li></ul><br><br><h2 id="Deadlock-detection"><a href="#Deadlock-detection" class="headerlink" title="Deadlock detection"></a>Deadlock detection</h2><p>死锁检测：DBMS在内部会维护一个<strong>锁依赖图</strong>，记录了当前并发的事务谁在等待谁的锁，图的每个结点都是一个事务</p><p>比如说，事务A指向事务B，表示事务A在等待事务B的锁</p><img src="\medias\16-Two-Phase-Locking\dedalock detection_01.png" style="zoom:150%;"><p>DBMS会周期性的检测锁依赖图，检查是否出现成环的情况</p><p>如果发现了环，就会选择其中某个事务进行回滚，以此来解开环，使得事务继续进行下去</p><br><p>这里会有一个权衡：<strong>DBMS检查锁依赖图的频率</strong></p><p>一个考虑因素就是：应该选择<strong>哪一个事务进行回滚</strong>？</p><ul><li>如果是执行了时间特别的长或者快要执行完了的事务，就尽量不要回滚它</li><li>看事务执行了多少条sql语句，即查看要回滚的代价，尽量回滚sql语句做得少的事务</li><li>查看事务拿了多少锁，尽量回滚加锁比较多的事务</li><li>考虑多少其他的事务都因为它而回滚过（即检测该事务被回滚了多少次）</li></ul><br><p>当然还有另一个考虑因素：事务的回滚程度</p><ul><li>完全回滚 completely rollback</li><li>部分回滚 minimallly rollback</li></ul><br><br><h2 id="Deadlock-prevention"><a href="#Deadlock-prevention" class="headerlink" title="Deadlock prevention"></a>Deadlock prevention</h2><p>死锁预防：当T1想要的lock被T2拿到的时候，那么DBMS就会挑选其中一个kill</p><p>根据时间戳给事务优先级，越早开始的事务有高优先级（older time stamp &#x3D; higher priority）</p><img src="\medias\16-Two-Phase-Locking\deadlock prevention.png" style="zoom:150%;"><br><h3 id="Old-waits-young"><a href="#Old-waits-young" class="headerlink" title="Old waits young"></a>Old waits young</h3><ul><li><p>如果是老的事务（高优先级）想要加锁，发现锁被一个年轻的事务（低优先级）拿到了，那么老的事务就要等年轻的事务释放了才能拿</p></li><li><p>反之，年轻的事务想要加的锁在老的事务持有，那么年轻的事务就要abort</p></li></ul><br><h3 id="Young-waits-old"><a href="#Young-waits-old" class="headerlink" title="Young waits old"></a>Young waits old</h3><ul><li><p>如果一个老的事务想要拿的锁被一个年轻的事务持有，那么老的事务就把年轻的事务的锁抢过来，并把年轻的事务abort</p></li><li><p>反之，年轻的事务想要加的锁在老的事务持有，那么年轻的事务要等待老的事务</p></li></ul><br><p>简而言之就是给事务优先级，然后针对优先级指定不同的策略</p><p>（这也是为什么可以解决死锁的原因，有点像swap时，要先拿低地址数据的lock，再拿高地址数据的lock一样，就要保持所有的拿锁都有一个规律的顺序）</p><br><p>被abort的事务的时间戳是多少：应该还是原来的时间戳</p><ul><li>为了防止饥饿，因为此时年轻的时间戳，早晚会变成老的时间戳</li></ul><br><p><strong>MySQL的死锁检测是第一种（Old waits young）</strong></p><br><br><br><h1 id="Lock-granularitiles"><a href="#Lock-granularitiles" class="headerlink" title="Lock granularitiles"></a>Lock granularitiles</h1><p>锁的粒度</p><p>如果两条需要更新的事务都需要把整张表给锁住，那么并发度就会因此下降</p><p>因此DBMS需要尽可能的控制好锁的粒度和数量</p><p>根据业务需求，看看是需要更少的锁的数量，还是要需要更大粒度的锁</p><br><p>大粒度的锁：给整个表加锁，要先检查每个行是否要加锁</p><ul><li>solve：给一个标记，加行锁的时候标记一下，表示当前加不了表锁了</li></ul><br><br><h2 id="Intention-locks"><a href="#Intention-locks" class="headerlink" title="Intention locks"></a>Intention locks</h2><p>意向锁，可以认为是一个意向标记</p><p>当有事务给表的数据行加了共享锁或排他锁，同时会给表设置一个标识，代表已经有行锁了</p><p>其他事务要想对表加表锁时，就不必逐行判断有没有行锁可能跟表锁冲突了</p><p>直接读这个标识就可以确定自己该不该加表锁</p><br><p>意向锁允许更高级别的节点锁定在共享（S锁）或独占（X锁）模式，无需检查所有的节点</p><p>如果一个表被加了意向锁，就代表表中的部分数据被加上了S锁或X锁</p><br><p>意向锁的<strong>类型</strong>：</p><ul><li>intention shared（<strong>IS</strong>）意向共享锁<ul><li>下面的行有被加S锁</li><li>意味着对整个表加S锁前，需要先获取到IS锁</li></ul></li><li>intention exclusive（<strong>IX</strong>）意向排他锁<ul><li>下面的行有被加X锁</li><li>意味着对整个表加X锁前，需要先获取到IX锁</li></ul></li><li>shared + intention -  exclusive （<strong>SIX</strong>）<ul><li>部分行被加了排他锁（X lock），整个表又被加了共享锁（IS）</li></ul></li></ul><img src="\medias\16-Two-Phase-Locking\compatibility matrix_01.png" style="zoom:150%;"><br><br><h2 id="Locking-protocol"><a href="#Locking-protocol" class="headerlink" title="Locking protocol"></a>Locking protocol</h2><p>To get S or IS lock on a node, the txn must hold at  least IS on parent node</p><ul><li>想要对数据加S锁或IS锁，就必须要持有数据的IS锁</li></ul><p>To get X, IX, or SIX on a node, must hold at least  IX on parent node</p><ul><li>想要对数据加X锁，IX，SIX，就必须要持有数据的IX锁</li></ul><br><br><h2 id="Lock-escalation"><a href="#Lock-escalation" class="headerlink" title="Lock escalation"></a>Lock escalation</h2><p>当低级别的锁过多的时候，锁会自动升级为表锁，从而能够减少锁的请求和持有数量</p><br><br><h2 id="Lock-table"><a href="#Lock-table" class="headerlink" title="Lock table"></a>Lock table</h2><p>绝大部分锁，都是DBMS自己加的，当然有时候可以显式的给node加锁</p><p>而DBMS也提供了接口，让用户可以在语法上加锁</p><ul><li><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">LOCK</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span><span class="token keyword">table</span><span class="token operator">></span> <span class="token operator">IN</span> <span class="token operator">&lt;</span>mode<span class="token operator">></span> MODE<span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token operator">&lt;</span><span class="token keyword">table</span><span class="token operator">></span> <span class="token keyword">where</span> <span class="token operator">&lt;></span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//数据库备份的时候用到的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>显式告诉数据读的数据要加的不是共享锁，而是排他锁</p></li></ul><br><br><h2 id="Select…for-update"><a href="#Select…for-update" class="headerlink" title="Select…for update"></a>Select…for update</h2><p>用sql语句显式的给数据加上X lock</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token operator">&lt;</span><span class="token keyword">table</span><span class="token operator">></span> <span class="token keyword">where</span> <span class="token operator">&lt;</span>qualification<span class="token operator">></span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br><br><br><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>几乎所有的关系数据库都用了2PL，例如MySQL,Postgresql（Postgresql有些还有个ssi）</p><p>通过2PL可以放心的让事务进行并发</p><br><p>我对2PL的一些思考：</p><p>无论是2PL还是SS2PL，其实都存在不符合可串行化的情况</p><p>比如说T1，T2两个事务T1先执行，T2后执行，那么准确的语义应该是T2读到数据，都应该是T1执行后的数据</p><p>而如果T2的操作全部是读取数据，而T1的操作是一开始读取数据，最后的时候才修改数据</p><p>那么T1和T2并发的过程中，T2能够读取的数据有可能就是T1一开始读取的数据，即T1还没有修改过的数据</p><p>这是不符合我们事务上的逻辑顺序的（T2晚于T1），我们的要求是T2读到的数据必须是T1执行完后的</p><p>因此商用数据库并不只使用2PL这一种并发控制协议，而是多种（MVCC，TOO）并发协议一起搭配着使用</p>]]></content>
      
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> CMU 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 15-Concurrency Control Theory</title>
      <link href="/2022/11/26/cmu-15-445-15-concurrency-control-theory/"/>
      <url>/2022/11/26/cmu-15-445-15-concurrency-control-theory/</url>
      
        <content type="html"><![CDATA[<h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><p>多个事务对于同一条数据进行修改</p><ul><li>可能会出现竞争、更新丢失的问题</li></ul><br><p>执行多条语句（事务）的时候机房发生断电，该如何处理</p><ul><li>持久化（durability）的问题，需要恢复（recovery）解决</li></ul><br><img src="\medias\15-Concurrency Control Theory\concurrencycontrol_motivation.png" style="zoom:150%;"><br><p><strong>并发控制（concurrency control）</strong>和<strong>恢复（recovery）</strong>是基于ACID的非常重要的功能</p><br><br><br><h1 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h1><p>定义：<strong>事务</strong>是执行一系列操作（SQL语句），以达到一个高级的功能（比如说通过SQL语句对账户的余额增减，以实现转账的功能）</p><img src="\medias\15-Concurrency Control Theory\transactions.png" style="zoom:150%;"><br><p>比如说转账：</p><ul><li>先检查A账户有没有100块钱</li><li>如果有的话，就减去100块钱；否则就报错</li><li>然后给B账户加100块钱</li></ul><br><p>PS：如果没有显式的说明事务的话，那么一条SQL语句就会被认为是一个事务</p><br><p>一些想当然的想法：</p><ul><li>事务串行化执行（能够保证事务的正确性，但是串行化执行效率低下）</li><li>或者事务执行的时候，把整个数据库备份一个出来（能提高并发度，但问题是内存会因为数据库的不断备份导致内存不够，并且磁盘大小也会受限）<ul><li>如果语句执行成功了，就把新的数据覆盖到原数据中</li><li>否则，就丢弃当前备份出来的数据</li></ul></li></ul><br><p>DBMS的需求：</p><ul><li>更高的时空利用率和并发吞吐量</li><li>提高DBMS的响应时间</li><li>事务能够并发的执行，并且维持ACID的性质</li><li>要维护事务的正确性和公平性</li><li>如果不设限的话，并发的事务会存在临时性的数据错误和永久性的数据错误</li></ul><br><p>问题：</p><ul><li>数据库只知道数据的读写，不知道事务的逻辑，不知道事务整体是干什么的</li><li>不受限的并发会导致数据的错误，所以需要一个控制协议让DBMS能够正确的执行并发</li></ul><br><p>简化问题：</p><ul><li>研究事务不需要知道数据具体放在哪儿</li><li>事务的研究本质上就是研究数据的读和写（简化模型）</li></ul><br><br><br><h1 id="Transaction-in-SQL"><a href="#Transaction-in-SQL" class="headerlink" title="Transaction in SQL"></a>Transaction in SQL</h1><p>begin是告诉DBMS事务开始</p><p>commit是告诉DBMS事务结束（或者rollback，abort回滚事务）</p><ul><li>abort有可能是事务本身发出的，也有可能是DBMS发出的</li></ul><br><br><br><h1 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h1><p><strong>atomicity</strong>（原子性）：<code>all or nothing</code></p><ul><li>事务要么都执行，要么都不执行</li></ul><p><strong>consistency</strong>（一致性）：<code>it looks correct to me</code></p><ul><li>比如说两个人的总账户金额为200，A给B转账100后，总金额发生了变化，那就失去了一致性</li></ul><p><strong>isolation</strong>（隔离性）：<code>as if alone</code></p><ul><li>理想的隔离性是指好像数据库中只有这一条事务在操作一样（我做的操作别人看不见，别人做的我也看不见）</li><li>存在现实的妥协（不同业务场景有不同的隔离需求）</li></ul><p><strong>durability</strong>（持久性）：<code>survive failures</code></p><ul><li>事务提交后，它的更新应该是持久的，不能说一停电事务就更新失败了</li></ul><br><br><h2 id="Atomicity"><a href="#Atomicity" class="headerlink" title="Atomicity"></a>Atomicity</h2><p><code>All actions in the txn happen, or none happen</code></p><p>事务只有两种结局：</p><ul><li>所有的SQL语句都执行完了，事务都提交了</li><li>abort终止了，客户端或DBMS终止</li></ul><p>从业务者的角度来看：所有的SQL要么全部执行，要么一个都没有执行（DBMS对部分执行的事务进行回滚）</p><p>而实现Atomicity有以下两种主流的方法：<code>shadow paging</code>和<code>logging</code></p><br><h3 id="shadow-paging"><a href="#shadow-paging" class="headerlink" title="shadow paging"></a>shadow paging</h3><p>事务需要对哪些页进行修改，就将哪些页备份出来</p><p>事务如果commit的话，就将修改好的页替换</p><p>如果abort的话，即需要回滚，就把一开始备份数据页替换回去</p><p>PS：因为比较浪费空间，所以很少有数据库使用这种方法</p><br><h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h3><p>事务每执行一步，都需要记录将当前的操作先记录到日志上（即undo log）</p><p>如果哪一步需要<strong>回滚</strong>，那就按照undo log，一步一步的将数据回滚，撤回数据</p><p>日志的作用（优点）：</p><ul><li>维护事务的原子性（如果事务执行到一般被abort的话，就用日志来<strong>回滚</strong>当前的数据）</li><li><strong>监控审计</strong>的作用，查看SQL语句到底对DB做了什么，监控的作用</li><li><strong>提高运行的效率</strong>（提高性能），因为往往对数据的操作都是随机读写，如果io的性能不行的话，可以把要做的操作先写入日志，写日志是顺序写，效率高，后续在按照顺序把文件的操作一点一点的写入磁盘中，就不需要在当时让用户卡住，随机读写而造成效率低下</li></ul><p>PS：几乎每个DBMS都用它，是一种主流的实现方法</p><br><br><h2 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h2><p><code>If each txn is consistent and the DB  starts consistent, then it ends up consistent</code></p><p>逻辑上说得通的（make sense）</p><p>一致性分为数据库（数据）一致性（后面发生的事务要能够看到前面发生事务的数据）和事务一致性</p><ul><li><strong>数据库一致性</strong>是ACID所保证的（ACID中的C是由AID共同保证的）<ul><li>如果处理不当就会有写写冲突（用户的本意是好的，但在并发执行的时候不上锁，导致了错误）</li></ul></li><li>而<strong>事务一致性</strong>是依靠业务（SQL语句）保证的<ul><li>比如说转账系统，A给B转账100，但是你的SQL写的却是给A减一百，给B加了150，事务的一致性就出问题了</li><li>再比如说A+B&lt;100，那么我们的SQL处理A和B的时候，都要先读取A和B的值，然后在判断下一步如何处理数据（这些操作都是要写到SQL中的）</li></ul></li></ul><br><p>如何判断数据库一致性：执行后的结果和串行化的结果是等效的</p><p>正确的一致性：</p><img src="\medias\15-Concurrency Control Theory\interleavint example_good.png" style="zoom:150%;"><br><p>错误的一致性（有100块钱少算了利息）：</p><img src="\medias\15-Concurrency Control Theory\interleavint example_bad.png" style="zoom:150%;"><br><br><h2 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h2><p><code>Execution of one txn is isolated from that of other txns</code></p><p>好像就只有一个人在使用数据库一样，别人提交的修改我也看不见，数据就和事务刚开始的时候一样</p><p>当某个事务出现问题的时候，不能影响其他的事务（注意串行会影响性能）</p><p>最理想的隔离性：别人的操作我都看不到</p><p>为什么需要隔离性：</p><ul><li>写业务的时候方便（转账只考虑A和B的关系即可，不用考虑别的事情），为了能让用户更好更方便的实现它的业务</li><li>即用户可不管这些其他的情况，专心于自身的业务；如果失败了，DBMS就会直接告诉你失败了，然后重新再做即可</li></ul><p>所以需要设计一种协议，实际上让多个事务能够同时跑起来，但是又能够让用户感觉好像只有他自己的事务在跑一样</p><p>也就是并发控制协议：决定用什么顺序让多个事务穿插的执行</p><p>并发协议的两大流派：</p><ul><li>pessimistic：悲观类，不让问题发生，在问题发生之前就让他停下来</li><li>optimistic：乐观类，假设冲突是非常有限的，在真正出问题的地方回滚</li></ul><br><p>思考：</p><ul><li>从转账的例子发现有些事务的并发顺序是正确的，而有些是错误的，那DBMS如何知道事务是否正确呢？怎样给数据库设置一种算法，证明数据的正确性？</li><li>解：如果一种并发执行的安排执行后是等效于串行化的话，就是正确的</li></ul><br><h3 id="串行化（serial-schedule）"><a href="#串行化（serial-schedule）" class="headerlink" title="串行化（serial schedule）"></a>串行化（serial schedule）</h3><p>serial schedule（串行化执行，真串行）</p><p>equivalent schedule（等效执行）</p><ul><li>如果两种执行的顺序的<strong>结果</strong>是等效的话，那就说明它们是等效的执行安排</li></ul><p>serializable schedule（可串行化，该执行顺序和真正的串行是等效执行）</p><ul><li>这种执行方式安排和真串行是等效的</li><li>使用这种串行，既可以提高并发度，又可以给数据库的执行更多灵活性</li></ul><p>问题转化为如何证明某种执行顺序是可串行化的</p><br><h3 id="冲突的操作（conflicting-operations）"><a href="#冲突的操作（conflicting-operations）" class="headerlink" title="冲突的操作（conflicting operations）"></a>冲突的操作（conflicting operations）</h3><p>两个操作是冲突的意味着：</p><ul><li>操作是来自不同的事务</li><li>两个操作都在操作同一个数据，并且其中一个操作是写</li></ul><br><p>主要分为：读写冲突、写读冲突和写写冲突</p><br><br><p><strong>读写冲突</strong>（<strong>不可重复读</strong> unrepeatable read）</p><img src="\medias\15-Concurrency Control Theory\read-write conflicts.png" style="zoom:150%;"><p>T1第一次读的数据是10，T2修改为19（事务B将数据修改后并提交了），T1第二次读的时候就变为了19，破坏了隔离性</p><p>即对一个数据重复读，发现前后不一致</p><p><strong>不可重复读</strong>侧重的是在当前事务中，对一个数据的重复读，数据发生了不同</p><p>而这个不同是因为在当前事务的执行过程中，有其他的事务对数据进行了修改并<strong>提交</strong></p><br><br><p><strong>写读冲突</strong>（<strong>读未提交</strong> reading uncommited data <strong>脏读</strong> dirty reads）</p><img src="\medias\15-Concurrency Control Theory\write-read conflicts.png" style="zoom:150%;"><p>T1修改了数据a（但是还没有提交事务），T2读取数据的时候读到的数据是T1修改过后的，读到了未提交的数据</p><p>即读到了一个没有提交的值（如果T1发生了回滚，那么T2读到的就是一个脏数据）</p><p>读未提交（脏读）侧重的是读到的是<strong>未提交</strong>的数据，即脏读读到的数据是还没有committed的</p><br><br><p><strong>写写冲突</strong>（overwriting uncommited data）</p><img src="\medias\15-Concurrency Control Theory\write-write conflicts.png" style="zoom:150%;"><p>T1写了数据a，T2又写了数据a，导致T1的操作被覆盖了</p><p>数据A和数据B的结果分别是两个不同的事务带来的，这就会造成数据的不一致</p><br><p>其中一种情况是数据的一致性遭到了破坏，比如说X和Y的账户余额都是50，他们的总和是100</p><p>T1读取X的余额是50，然后T2从X转账50到Y然后提交</p><p>T1在T2提交后读Y发现余额为100，那么它们总和变成了150</p><p>最终导致T1读数据的结果违反数据的一致性，又叫做<strong>读偏斜</strong>（read skew）</p><img src="\medias\15-Concurrency Control Theory\write-write conflicts_01.jpg" style="zoom:150%;"><br><p>而另一种情况也会破坏数据的一致性，即有约束A+B&lt;&#x3D;100，A&#x3D;70，B&#x3D;20</p><p>此时T1、T2都读到了A&#x3D;70，B&#x3D;20</p><p>然后T1改为A&#x3D;75（从T1的角度来说没问题），T2改为B&#x3D;30（单从T2的角度来说没问题）</p><p>可是数据的一致性约束就被破坏了（其实是因为此前读入作为一致性保证的前提数据，被其他的事务修改了）</p><p>又叫做<strong>写偏斜</strong>（write skew）</p><br><p>还有一种情况是：（不是写写冲突，但还是想提一下）</p><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>begin  &#x2F;&#x2F;  开启事务</td><td></td></tr><tr><td></td><td>begin  &#x2F;&#x2F;  开启事务</td></tr><tr><td>update user set username&#x3D;“张三” where id&#x3D;5;</td><td></td></tr><tr><td>commit  &#x2F;&#x2F;  提交事务</td><td></td></tr><tr><td></td><td>update user set username&#x3D;“李四” where id&#x3D;5;</td></tr><tr><td></td><td>ROllBACK;</td></tr></tbody></table><p>此时的sessionB为了避免脏读，那么就会选择读原始数据</p><p>可问题是如果sessionA提交了以后，sessionB发生了回滚</p><p>数据就会被回滚到sessionA和sessionB之前的数据，那么sessionA的修改就被cover掉</p><p>即会导致前一个事务的修改失效，这种情况又叫作<strong>脏写</strong></p><br><p>写写冲突不仅会造成数据一致性的缺失，还可能会造成事务的cover</p><p>PS：一切概念以15-445为准（比如啥写倾斜，读偏斜，都可以根据冲突进行分类）</p><br><p>串行化</p><p><strong>基于冲突的串行化</strong>（conflict serializability），大多数DBMS都是基于此做的可串行化</p><ul><li>如果两个序列的事务是相同的，包含的事务是相同的，产生的冲突是一样的，便可认为是冲突等效</li><li>还有一种等效，即移动SQL语句执行的时机，如果两个序列的结果依然等效的话</li></ul><p><strong>基于观察的串行化</strong>（view serializability），没有DBMS可以基于此做</p><br><p>总结：</p><ul><li>前面的三种冲突是不可以交换顺序的，因为交换顺序后，语义就发生了变化</li><li>那就是说，除了上述的冲突外，其他的语句是可以交换顺序的，所以为了提高并发度，我们可以先给定一个串行化的操作，然后再排除掉上述的三种冲突以外的情况下，交换语句的顺序，以此获得更高的并发度</li><li>所以优化的思路就是通过<strong>调整事务语句的顺序，获取串行化的同时，又能提高并发度</strong><ul><li>这么说，不同的隔离级别本质上是根据场景分别解决不同的冲突问题</li></ul></li></ul><br><h3 id="依赖图（dependency-graphs）"><a href="#依赖图（dependency-graphs）" class="headerlink" title="依赖图（dependency graphs）"></a>依赖图（dependency graphs）</h3><p>如果冲突之间形成的关系成环了，就不能转变为串行化，就代表当前的执行顺序不能等效为串行化执行</p><p>比如事务A和事务B之间发生了写读冲突，就在事务A上画一条边到事务B上</p><ul><li>这个边就是说一个操作一定要在另一个操作之前发生</li><li>注意是先发生的事务指向后发生的事务</li></ul><img src="\medias\15-Concurrency Control Theory\dependency graphs.png" style="zoom:150%;"><br><p>如果几个事务的依赖图形成的图：</p><p>出现了环，就代表永远无法通过滑动语句以实现串行化</p><p>没有成环，就代表其是可串行化的，即最后的效果等价于串行化</p><br><h3 id="view-serializability"><a href="#view-serializability" class="headerlink" title="view serializability"></a>view serializability</h3><p>根据业务的需求，发现有些情况虽然是成环的，但还是可以等效串行化执行</p><p>因此依赖图的做法，可能真的会误判一些隐藏的可串行化的情况</p><p>所以view的可串行化范围是大于conflict的，但是编程无法实现</p><p>即基于观察的串行化也是有效的，但是难以实现</p><br><p>view serializability 和 conflict serializability都没法做到完全识别出所有的可串行化，主要是因为数据库没法做到理解数据库的业务</p><p>比如说下图，虽然依赖图成环了，但是数据A的结果，其实最后就是T3的结果，前面是否覆盖都不重要，所以它也是可串行化的：</p><img src="\medias\15-Concurrency Control Theory\view serializability_01.png" style="zoom:150%;"><img src="\medias\15-Concurrency Control Theory\view serializability_02.png" style="zoom:150%;"><br><p>基于conflict serializability画依赖图的做法是绝大部分的DBMS都在用的（主要是容易实现）</p><p>当然也可以做一些优化，比如说都是只读的事务的话，就直接操作就好了</p><br><img src="\medias\15-Concurrency Control Theory\universe of schedules.png" style="zoom:150%;"><br><br><h2 id="Durability"><a href="#Durability" class="headerlink" title="Durability"></a>Durability</h2><p><code>If a txn commits, its effects persist</code></p><p>事务的持久性</p><p>所有的事务的语句，都必须持久化到磁盘中，不存在事务只更新到一半的情况，也不能有部分事务数据留下来的（失败的数据）的情况</p><p>主要通过logging（redo log）或shadow paging来实现的</p><br><br><br><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p><strong>并发控制</strong>和<strong>恢复</strong>是数据库最重要的功能</p><p>部分数据库是不支持事务，要么全部的操作全部转为可并发的，要么就是自己去判断有没有问题，要么就是在业务里面加锁</p><p>谷歌著名论文设计spanner，很多新的数据库的思路，比如tidb等start up，都是出自这篇论文</p>]]></content>
      
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> CMU 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题之智力题</title>
      <link href="/2022/11/11/mian-shi-ti-zhi-zhi-li-ti/"/>
      <url>/2022/11/11/mian-shi-ti-zhi-zhi-li-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="三人三鬼过桥"><a href="#三人三鬼过桥" class="headerlink" title="三人三鬼过桥"></a>三人三鬼过桥</h1><p><strong>题目：</strong></p><p>有三个人跟三个鬼要过河，河上没桥，只有条小船</p><p>船一次只能渡一个人和一个鬼，或者两个鬼，或者两个人</p><p>无论在哪边岸上，只要是人比鬼少的情况下（比如：两鬼一人，三鬼两人，三鬼一人），人都会被鬼吃</p><p>然而船又一定需要人或鬼操作才能航行</p><p>问：如何安全的把三人三鬼渡过河对岸</p><br><p><strong>思路</strong>：</p><p>先两鬼过去，再一鬼回来。此时：对面有一鬼，这边有三人两鬼</p><p>接着两鬼过去，再一鬼回来。此时：对面有两鬼，这边有三人一鬼</p><p>然后两人过去，再一人一鬼回来。此时：对面一人一鬼，这边两人两鬼</p><p>最后两人过去，再一鬼回来。此时：对面三人，这边三鬼</p><p>剩下的三个鬼，两个过去，一个回来再接另一个即可</p><br><br><br><h1 id="小猴子搬香蕉"><a href="#小猴子搬香蕉" class="headerlink" title="小猴子搬香蕉"></a>小猴子搬香蕉</h1><p><strong>问题：</strong></p><p>一个小猴子边上有100根香蕉，它要走过50米才能到家，每次它最多搬50根香蕉（多了就被压死了）</p><p>它每走1米就要吃掉一根香蕉，请问它最多能把多少根香蕉搬到家里</p><br><p><strong>思路：</strong></p><p>这道题的<strong>关键</strong>是，把香蕉的搬运过程分为两个阶段：</p><p>第一阶段是将香蕉来回搬运，当香蕉数目大于50根时，猴子每搬一米需要吃掉三根香蕉</p><p>第二阶段是直接搬香蕉，当香蕉数小于等于50根时</p><br><p>因此<strong>第一个阶段</strong>，将香蕉分为A和B两箱，把这两箱香蕉往前搬一米需要花费三根香蕉</p><p>因此，当走到17米的时候，还剩下49根香蕉（<code>100 - 3 * 17</code>），就代表此时可以一直往前走，不用来回搬运香蕉了</p><p>而在<strong>第二个阶段</strong>，此时还剩下<code>50 - 17 = 33</code>米还没有走完，因此还需要再消耗33根香蕉</p><p>所以最后还剩下<code>49 - 33 = 16</code>根香蕉</p><br><br><br><h1 id="强盗分金币"><a href="#强盗分金币" class="headerlink" title="强盗分金币"></a>强盗分金币</h1><p><strong>问题：</strong></p><p>5个海盗抢到了100枚金币，每一颗都一样的大小和价值。 他们决定这么分：</p><ul><li>抽签决定自己的号码（1，2，3，4，5）</li><li>首先，由1号提出分配方案，然后大家5人进行表决，当半数以上的人同意时（ 不包括半数），按照他的提案进行分配，否则将被扔入大海喂鲨鱼</li><li>如果1号死后，再由2号提出分配方案，然后大家4人进行表决，当且仅当半超过半数的人同意时， 按照他的提案进行分配，否则将被扔入大海喂鲨鱼</li><li>以此类推</li></ul><p>假设每一位海盗都足够聪明，并且利益至上，能多分一枚金币绝不少分，那么1号海盗该怎么分金币才 能使自己分到最多的金币呢？</p><br><p><strong>思路：从后往前推导</strong></p><p>如果1至3号强盗都喂了鲨鱼，只剩4号和5号的话</p><p>5号一定投反对票让4号喂鲨鱼，以独吞全部金币</p><p>所以，4号惟有支持3号才能保命</p><br><p>3号知道这一点，就会提出<code>[100，0，0]</code>的分配方案</p><p>因为3号知道4号即使一无所获但还是会投赞成票（如果投了反对，就回到上一步了），再加上自己一票，他的方案即可通过</p><br><p>而2号也知道这一点，就会提出<code>[98，0，1，1]</code>的方案</p><p>由于该方案对于4号和5号来说比在3号分配时更为有利，他们将支持他而不希望他出局</p><br><p>同样1号也知道这一点，就会提出<code>[97，0，1，2，0]</code>或<code>[97，0，1，0，2]</code>的方案</p><p>对于此时的方案一，给3号一个金币和给4号两个金币的方案，明显由于2号的方案，所以3号和4号会给1号投赞成票</p><p>再加上1号自己的票，即可通过</p><p>而对于方案二来说，给3号一个金币和给5号两个金币的方案，明显优于2号的方案，同理</p><br><p><strong>总结：</strong>最终的分配方案为<code>[97，0，1，2，0]</code>或<code>[97，0，1，0，2]</code></p><br><br><br><h1 id="空瓶换饮料"><a href="#空瓶换饮料" class="headerlink" title="空瓶换饮料"></a>空瓶换饮料</h1><p><strong>题目：</strong>1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶？</p><br><p><strong>思路：</strong></p><p>先留下1瓶饮料（就当作是向店家借的那一瓶）</p><p>接着可以认为先向店家借一瓶，自己拿两瓶，此时总共就有3瓶</p><p>那么就得到三个空瓶子，换得一瓶饮料，然后还给店家一瓶，即无拖无欠</p><p>所以就只要在原有瓶数的基础上，再计算有多少个两瓶即可</p><p>即<code>1000 + (1000 - 1) / 2 = 1499</code>瓶</p><br><br><br><h1 id="称重类问题"><a href="#称重类问题" class="headerlink" title="称重类问题"></a>称重类问题</h1><p><strong>问题一：</strong>有一个天平，九个砝码，其中一个砝码比另八个要轻一些，问最少要称几次才能找到轻的砝码</p><p><strong>答案：</strong>2次</p><p>第一次：</p><p>在称的两边各放3个砝码：哪边轻就代表轻的砝码在哪边；一样重就代表轻的砝码在剩余的砝码中 </p><p>第二次：</p><p>找到存在轻砝码的那三个砝码，在称的两边各放1个砝码：哪边轻就是哪个；两边一样重，那么轻的砝码就是剩余的砝码</p><br><p><strong>问题二：</strong>十组砝码每组十个砝码，每个砝码都是10g重，但现在其中有一组砝码每个都只有9g重，现有一个能显示克数的秤，最少称几次能找到轻的那组？ </p><p><strong>答案：</strong>1次</p><p>将砝码分组1~10，第一组拿一个，第二组拿两个，以此类推</p><p>将所有的砝码一起放到秤上称重，得到克数<code>x</code>，设<code>y =  550 - x</code>，则第<code>y</code>组就是轻的那组</p><br><p><strong>问题三：</strong>有四瓶药，但有一个是重的，只有一台称，只许称一次，找出那瓶是重的</p><p><strong>思路：</strong></p><p>将药随机分为两组，称一次称</p><p>设比较重的一边是A，轻一点的是B</p><p>接着从A中随机抽出一瓶，从B中也随机抽出一瓶</p><p>如果此时秤的左右两边是相等的，那么重的那一瓶就是从A中抽出的</p><p>否则就是A中还在称上的那一瓶</p><br><br><br><h1 id="舀酒问题"><a href="#舀酒问题" class="headerlink" title="舀酒问题"></a>舀酒问题</h1><p><strong>问题：</strong>两个舀酒的勺子，分别能舀7两和11两酒，如何舀出2两酒</p><br><p><strong>思路：</strong></p><p>先舀7两倒到11两勺里</p><p>再舀7两倒到11两勺里，此时7两的勺里剩3两</p><p>把11两勺里的酒倒掉，把7两的勺里剩的3两倒入</p><p>再舀凳橡枝7两倒到11两勺里，此时11两的勺里还可以装<code>11 - (3 + 7) =1</code>两</p><p>再舀7两倒到11两勺里，7两勺剩<code>7 - 1 = 6</code>两</p><p>把11两勺里的酒倒掉，把6两倒入，11两的勺里还可以装<code>11 - 6 = 5</code>两</p><p>再舀7两倒到11两勺里，7两勺剩<code>7 - 5 = 2</code>两</p><br><br><br><h1 id="毒药毒白鼠"><a href="#毒药毒白鼠" class="headerlink" title="毒药毒白鼠"></a>毒药毒白鼠</h1><p><strong>问题一：</strong></p><p>有1000个一模一样的瓶子，其中有999瓶是普通的水，有1瓶是毒药</p><p>任何喝下毒药的生命都会在一星期之后死亡</p><p>现在你只有10只小白鼠和1个星期的时间，如何检验出哪个瓶子有毒药？</p><br><p><strong>思路：</strong></p><p>首先一共有1000瓶，而$2^{10}$是1024，刚好大于1000，也就是说，1000瓶药品可以使用10位二进制数就可以表示</p><p>即，第一瓶：00 0000 0001，第二瓶：00 0000 0010，第三瓶：00 0000 0011，以此类推</p><p>将当前的十只老鼠按顺序编号A、B、C、D、E、F、G、H、I、J，分别代表从低位到高位每一个位</p><p>每只老鼠对应一个二进制位，比如说数字5，那么对应的就是3号老鼠和1号老鼠，即让3号老鼠和1号老鼠喝下第五瓶水</p><p>观察：若死去的老鼠为1号老鼠和3号老鼠，就代表第五瓶水是毒药</p><br><p><strong>问题二：</strong></p><p>8瓶酒一瓶有毒，用小老鼠测试。每次测试结果8小时后才会得出</p><p>只有8个小时的时间。最少需要几只老鼠测试？</p><br><p><strong>答案：</strong>3只</p><p>思路同上，用三位二进制表示8瓶酒</p><p>其中，第一个老鼠喝下最低位为1对应的酒，第二个老鼠喝下中间位为1对应的酒，第三个老鼠喝下最高位为1对应的酒  </p><p>最后将所有中毒的老鼠，对应的位次进行与操作即可以知道那瓶毒药有毒了</p><br><br><br><h1 id="先手必胜问题"><a href="#先手必胜问题" class="headerlink" title="先手必胜问题"></a>先手必胜问题</h1><p><strong>问题：</strong>100本书，两个人依次拿书，你先拿，每次能够拿1-5本书，怎么拿能保证最后一次是你拿？</p><br><p><strong>思路：</strong></p><p>试想，如果最后一次是我拿的书，那么此时剩下的书的数量必然要是1-5本</p><p>也就是说，在上一次拿书的过程中，也就是对方的拿书的时候，此时最少要剩下6本书</p><p>那么只要保持每个回合结束后都剩下6的倍数，并且在这个回合中保证我拿的和对方拿的加起来为6（这样这个回合结束后剩下的还是6的倍数）</p><p>就能够保证最后一次拿书是我拿的</p><p>因此需要保证书的数量始终是6的倍数，所以第一次先手拿书要拿<code>100 % 6 = 4</code>本书</p><br><br><br><h1 id="辩论赛数量"><a href="#辩论赛数量" class="headerlink" title="辩论赛数量"></a>辩论赛数量</h1><p><strong>问题：</strong>1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛？</p><br><p><strong>思路：</strong></p><p>每一场辩论赛参加两个人，消失一个人</p><p>所以可以看作是每一场辩论赛减少一个人，直到最后剩下1个人</p><p>因此是<code>1000 - 1 = 999</code>场</p><br><br><br><h1 id="奴隶猜帽子颜色"><a href="#奴隶猜帽子颜色" class="headerlink" title="奴隶猜帽子颜色"></a>奴隶猜帽子颜色</h1><p><strong>问题一：</strong></p><p>100个奴隶站成一纵列，每人头上随机带上黑色或白色的帽子，同时每个人都不知道自己帽子的颜色，但能看见自己前面所有人帽子的颜色</p><p>然后从最后一个奴隶开始，每人只能用同一种声调和音量说一个字：”黑”或”白”</p><p>如果说中了自己帽子的颜色，就存活，说错了就拉出去斩了，每个人说的答案所有奴隶都能听见，但是否说对，其他奴隶不知道</p><p>在这之前，所有奴隶可以聚在一起商量策略</p><p>问如果奴隶都足够聪明而且反应足够快，100个奴隶最大存活率是多少？ </p><br><p><strong>思路：</strong></p><p>最后一个人如果看到奇数顶黑帽子报“黑”，否则报“白”（注意：他此时是必然不知道自己的帽子颜色是什么，所以有<code>50%</code>的概率死掉）</p><p>然后从倒数第二个人开始，如果前一个人说的是“黑”，同时他本人看到后面有奇数顶黑色帽子</p><p>就代表自己是白色帽子，因此就会说“白”</p><p>后面的人便以此类推</p><br><p>总结规律便是：</p><p>假设后面有奇数顶帽子为“黑”，有偶数顶帽子为“白”</p><p>如果后面看到的和前面的人说的相同，就报“白”；否则就报“黑”</p><br><p>因此最后的结果就是99人能100%存活，1人50%能活</p><br><br><p><strong>问题二：</strong></p><p>在上面的基础上，给定限定条件：每个奴隶只能看见前面一个人帽子颜色又能最多存活多少人？</p><p><strong>思路：</strong></p><p>此时只能约定偶数位奴隶说他前一个人的帽子颜色</p><p>因此：奇数位置的奴隶<code>100%</code>存活，偶数位置的奴隶<code>50%</code>存活</p><br><br><br><h1 id="利用烧绳子计算时间"><a href="#利用烧绳子计算时间" class="headerlink" title="利用烧绳子计算时间"></a>利用烧绳子计算时间</h1><p><strong>问题：</strong></p><p>现有若干条不均匀的绳子，烧完每一根绳子都需要花费一个小时</p><p>问如何准确计时：15分钟、30分钟、45分钟、75分钟</p><br><p><strong>思路：</strong></p><p>计算15分钟：将绳子对折，然后从两端开始烧（即从四个端点燃烧绳子）</p><br><p>计算30分钟：从绳子的两端分别开始燃烧</p><br><p>计算45分钟：</p><p>拿两根绳子，一根从两端烧，另一根从一端烧</p><p>两端烧的绳子烧完后即过了30分钟</p><p>此时立即将第二根另一头点燃（PS：此时的第二根绳子如果继续用一端燃烧，还可以烧30分钟，而如果从两端烧，就只能烧15分钟）</p><p>待这根绳子烧完便是15分钟</p><p>因此一共加起来便是45分钟  </p><br><p>计算75分钟：等价于30分钟+45分钟</p><br><br><br><h1 id="飞机绕地球"><a href="#飞机绕地球" class="headerlink" title="飞机绕地球"></a>飞机绕地球</h1><p><strong>问题：</strong></p><p>一箱油可供一架飞机绕地球飞半圈</p><p>一架飞机绕地球一圈回到起飞时的飞机场，至少需要出动几架飞机</p><br><p><strong>答案：</strong>三架（前提是允许其他两架飞机可以飞不回来）</p><p>a和b全程顺时针飞，b在a起飞到四分之一处时，把油全部给a，接着b坠毁</p><p>c在a飞到一半时逆时针从机场起飞，c和a相遇时把油全部给a，c坠毁，a刚好回到基地</p><br><br><br><h1 id="老虎吃羊"><a href="#老虎吃羊" class="headerlink" title="老虎吃羊"></a>老虎吃羊</h1><p><strong>问题：</strong></p><p>一百只老虎和一只羊共同生活在一个只有草的魔法岛上。老虎可以吃草，但它们更喜欢吃羊</p><p>其中：每次一只老虎只能吃一只羊，并且吃完后老虎会变成羊</p><p>所有的老虎都很精明，并且都想活下去</p><p>问：羊会被吃掉吗？</p><br><p><strong>思路：</strong></p><p>这类题目需要先降低数量，简化问题，从而找出规律</p><br><p>如果有1只老虎，它肯定会吃掉羊，因为它不用担心变成羊后会被吃掉</p><p>如果有2只老虎，因为两只老虎都很精明，都清楚如果自己吃掉羊后变成羊，就会被另一只老虎吃掉，所以结果是谁也不去吃羊</p><p>如果有3只老虎，如果其中一只老虎吃掉一只羊后变身，剩下的两只老虎不会再继续吃羊，所以第一只老虎把羊吃掉</p><p>如果有4只老虎，每只老虎都知道如果它吃了羊，它就会变成羊。还剩下3只老虎，它还是会被吃掉的。所以为了保证最大的生存可能性，没有老虎会吃羊肉</p><br><p>同样的逻辑，可以证明：<strong>如果老虎的数量是偶数，羊就不会被吃掉。如果数字是奇数，羊就会被吃掉</strong></p><p>因此对于100只老虎的情况，羊不会被吃掉</p><br><br><br><h1 id="翻转硬币"><a href="#翻转硬币" class="headerlink" title="翻转硬币"></a>翻转硬币</h1><p><strong>题目：</strong></p><p>有23枚硬币在桌上，其中10枚正面朝上．蒙住眼睛（无法分清硬币正反，但可以翻转硬币）</p><p>问如何操作能将硬币分成两组，让两组硬币正面朝上的硬币数量一样多</p><br><p><strong>思路：</strong></p><p>将这23枚硬币分成10个、13个两组</p><p>然后将10个一组的所有硬币翻转，这时两堆正面朝上的硬币个数就一样了</p><p>因为总共就只有十个硬币是正面的，假设有<code>x</code>个正面的在10个的这一组，那么就有<code>10 - x</code>个在13个的这一组</p><p>因此只要翻转10个的这一组，那么此时在10个硬币的一边，就有<code>10 - x</code>正面的硬币了</p><br><br><br><h1 id="赛马类问题"><a href="#赛马类问题" class="headerlink" title="赛马类问题"></a>赛马类问题</h1><p><strong>背景</strong>：只知道每次赛马中马的名次，而不知道每匹马具体的速度</p><br><h2 id="25匹马，5条跑道，找最快的3匹马，最少需要跑几次？"><a href="#25匹马，5条跑道，找最快的3匹马，最少需要跑几次？" class="headerlink" title="25匹马，5条跑道，找最快的3匹马，最少需要跑几次？"></a>25匹马，5条跑道，找最快的3匹马，最少需要跑几次？</h2><p><strong>答案：</strong>7次</p><br><table><thead><tr><th>A组</th><th>B组</th><th>C组</th><th>D组</th><th>E组</th></tr></thead><tbody><tr><td>A1</td><td>B1</td><td>C1</td><td>D1</td><td>E1</td></tr><tr><td>A2</td><td>B2</td><td>C2</td><td>D2</td><td>E2</td></tr><tr><td>A3</td><td>B3</td><td>C3</td><td>D3</td><td>E3</td></tr><tr><td>A4</td><td>B4</td><td>C4</td><td>D4</td><td>E4</td></tr><tr><td>A5</td><td>B5</td><td>C5</td><td>D5</td><td>E5</td></tr></tbody></table><p>5次（将25匹马分为A、B、C、D、E五个组，每个组内先跑一次）</p><p>1次（将每组的第一名，即A1、B1、C1、D1、E1，放在一起跑一次）</p><p>1次（假设A1&gt;B1&gt;C1&gt;D1&gt;E1，则现在需要找top2和top3；因此将A2、A3、B1、B2、C1，放在一次跑一次；这里面的top1和top2，便是总排名的top2和top3）</p><br><br><h2 id="25匹马，5条跑道，找最快的5匹马，最少需要跑几次？"><a href="#25匹马，5条跑道，找最快的5匹马，最少需要跑几次？" class="headerlink" title="25匹马，5条跑道，找最快的5匹马，最少需要跑几次？"></a>25匹马，5条跑道，找最快的5匹马，最少需要跑几次？</h2><p><strong>答案：</strong>最少8次，最多9次</p><br><p><strong>预处理：</strong></p><table><thead><tr><th>A组</th><th>B组</th><th>C组</th><th>D组</th><th>E组</th></tr></thead><tbody><tr><td>A1</td><td>B1</td><td>C1</td><td>D1</td><td>E1</td></tr><tr><td>A2</td><td>B2</td><td>C2</td><td>D2</td><td>E2</td></tr><tr><td>A3</td><td>B3</td><td>C3</td><td>D3</td><td>E3</td></tr><tr><td>A4</td><td>B4</td><td>C4</td><td>D4</td><td>E4</td></tr><tr><td>A5</td><td>B5</td><td>C5</td><td>D5</td><td>E5</td></tr></tbody></table><p>5次（将25匹马分为A、B、C、D、E五个组，每个组内先跑一次）</p><p>1次（将每组的第一名，即A1、B1、C1、D1、E1，放在一起跑一次）</p><p>1次（假设A1&gt;B1&gt;C1&gt;D1&gt;E1，则现在需要找top2和top3；因此将A2、A3、B1、B2、C1，放在一次跑一次；这里面的top1和top2，便是总排名的top2和top3）</p><br><p><strong>重点</strong>是根据不同的情况找到top4和top5</p><br><p>情况一：8场比赛</p><table><thead><tr><th>A组</th><th>B组</th><th>C组</th><th>D组</th><th>E组</th></tr></thead><tbody><tr><td><strong>Top1</strong></td><td>B1</td><td>C1</td><td>D1</td><td>E1</td></tr><tr><td><strong>Top2</strong></td><td>B2</td><td>C2</td><td>D2</td><td></td></tr><tr><td><strong>Top3</strong></td><td>B3</td><td>C3</td><td></td><td></td></tr><tr><td>A4</td><td>B4</td><td></td><td></td><td></td></tr><tr><td>A5</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>在此种情况下top4只能在A4、B1中产生</p><p>如果第4名&#x3D;A4，那么第5名只能在A5、B1中产生</p><p>如果第4名&#x3D;B1，那么第5名只能在A4、B2、C1中产生</p><p>则top4和top5需要在马匹<code>[A4、A5、B1、B2、C1]</code>五匹马中产生</p><p>因此只需要额外再来一场比赛即可</p><br><p>情况二：9场比赛</p><table><thead><tr><th>A组</th><th>B组</th><th>C组</th><th>D组</th><th>E组</th></tr></thead><tbody><tr><td><strong>Top1</strong></td><td><strong>Top2</strong></td><td>C1</td><td>D1</td><td>E1</td></tr><tr><td><strong>Top3</strong></td><td>B2</td><td>C2</td><td>D2</td><td></td></tr><tr><td>A3</td><td>B3</td><td>C3</td><td></td><td></td></tr><tr><td>A4</td><td>B4</td><td></td><td></td><td></td></tr><tr><td>A5</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>在此种情况下第4名只能在A3、B2、C1中产生</p><p>如果第4名&#x3D;A3，那么第5名只能在A4、B2、C1中产生</p><p>如果第4名&#x3D;B2，那么第5名只能在A3、B3、C1中产生</p><p>如果第4名&#x3D;C1，那么第5名只能在A3、B2、C2、D1中产生</p><p>则top4和top5需要在马匹<code>[A3、A4、B2、B3、C1、C2、D1]</code>七匹马中产生</p><p>因此还得再比赛两场才能找到top4和top5</p><br><p>情况三：9场比赛</p><table><thead><tr><th>A组</th><th>B组</th><th>C组</th><th>D组</th><th>E组</th></tr></thead><tbody><tr><td><strong>Top1</strong></td><td><strong>Top2</strong></td><td>C1</td><td>D1</td><td>E1</td></tr><tr><td>A2</td><td><strong>Top3</strong></td><td>C2</td><td>D2</td><td></td></tr><tr><td>A3</td><td>B3</td><td>C3</td><td></td><td></td></tr><tr><td>A4</td><td>B4</td><td></td><td></td><td></td></tr><tr><td>A5</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>在此种情况下第4名只能在A2、B3、C1中产生</p><p>如果第4名&#x3D;A2，那么第5名只能在A3、B3、C1中产生</p><p>如果第4名&#x3D;B3，那么第5名只能在A2、B4、C1中产生</p><p>如果第4名&#x3D;C1，那么第5名只能在A2、B3、C2、D1中产生</p><p>则top4和top5需要在马匹<code>[A2、B3、B4、C1、A3、C2、D1]</code>七匹马中产生</p><p>因此还得再比赛两场才能找到top4和top5</p><br><p>情况四：9场比赛</p><table><thead><tr><th>A组</th><th>B组</th><th>C组</th><th>D组</th><th>E组</th></tr></thead><tbody><tr><td><strong>Top1</strong></td><td><strong>Top2</strong></td><td><strong>Top3</strong></td><td>D1</td><td>E1</td></tr><tr><td>A2</td><td>B2</td><td>C2</td><td>D2</td><td></td></tr><tr><td>A3</td><td>B3</td><td>C3</td><td></td><td></td></tr><tr><td>A4</td><td>B4</td><td></td><td></td><td></td></tr><tr><td>A5</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>在此种情况下第4名只能在A2、B2、C2、D1中产生</p><p>如果第4名&#x3D;A2，那么第5名只能在A3、B2、C2、D1中产生</p><p>如果第4名&#x3D;B2，那么第5名只能在A2、B3、C2、D1中产生</p><p>如果第4名&#x3D;C2，那么第5名只能在A2、B2、C3、D1中产生</p><p>如果第4名&#x3D;D1，那么第5名只能在A2、B2、C2、D2、E2中产生</p><p>则top4和top5需要在马匹<code>[A2、B2、C2、D1、A3、B3、C3、D2、E1]</code>九匹马中产生</p><p>因此还得再比赛两场才能找到top4和top5</p><br><p>情况五：9场比赛</p><table><thead><tr><th>A组</th><th>B组</th><th>C组</th><th>D组</th><th>E组</th></tr></thead><tbody><tr><td><strong>Top1</strong></td><td><strong>Top3</strong></td><td>C1</td><td>D1</td><td>E1</td></tr><tr><td><strong>Top2</strong></td><td>B2</td><td>C2</td><td>D2</td><td></td></tr><tr><td>A3</td><td>B3</td><td>C3</td><td></td><td></td></tr><tr><td>A4</td><td>B4</td><td></td><td></td><td></td></tr><tr><td>A5</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>在此种情况下第4名只能在A3、B2、C1中产生</p><p>如果第4名&#x3D;A3，那么第5名只能在A4、B2、C1中产生</p><p>如果第4名&#x3D;B2，那么第5名只能在A3、B3、C1中产生</p><p>如果第4名&#x3D;C1，那么第5名只能在A3、B2、C2、D1中产生</p><p>则top4和top5需要在马匹<code>[A3、B2、B3、C1、A4、C2、D1]</code>七匹马中产生</p><p>因此还得再比赛两场才能找到top4和top5</p><br><h2 id="64匹马，8条跑道，找最快的4匹马，最少需要跑几次？"><a href="#64匹马，8条跑道，找最快的4匹马，最少需要跑几次？" class="headerlink" title="64匹马，8条跑道，找最快的4匹马，最少需要跑几次？"></a>64匹马，8条跑道，找最快的4匹马，最少需要跑几次？</h2><p><strong>答案：</strong>最少10次，最多11次</p><br><p><strong>思路：</strong></p><table><thead><tr><th>A1</th><th>B1</th><th>C1</th><th>D1</th><th>E1</th><th>F1</th><th>G1</th><th>H1</th></tr></thead><tbody><tr><td>A2</td><td>B2</td><td>C2</td><td>D2</td><td>E2</td><td>F2</td><td>G2</td><td>H2</td></tr><tr><td>A3</td><td>B3</td><td>C3</td><td>D3</td><td>E3</td><td>F3</td><td>G3</td><td>H3</td></tr><tr><td>A4</td><td>B4</td><td>C4</td><td>D4</td><td>E4</td><td>F4</td><td>G4</td><td>H4</td></tr><tr><td>A5</td><td>B5</td><td>C5</td><td>D5</td><td>E5</td><td>F5</td><td>G5</td><td>H5</td></tr><tr><td>A6</td><td>B6</td><td>C6</td><td>D6</td><td>E6</td><td>F6</td><td>G6</td><td>H6</td></tr><tr><td>A7</td><td>B7</td><td>C7</td><td>D7</td><td>E7</td><td>F7</td><td>G7</td><td>H7</td></tr><tr><td>A8</td><td>B8</td><td>C8</td><td>D8</td><td>E8</td><td>F8</td><td>G8</td><td>H8</td></tr></tbody></table><br><br><p>第一轮：8场（先将64匹马分为8组，各个组组内进行赛跑；同时会淘汰每组的后4名）</p><table><thead><tr><th>A1</th><th>B1</th><th>C1</th><th>D1</th><th>E1</th><th>F1</th><th>G1</th><th>H1</th></tr></thead><tbody><tr><td>A2</td><td>B2</td><td>C2</td><td>D2</td><td>E2</td><td>F2</td><td>G2</td><td>H2</td></tr><tr><td>A3</td><td>B3</td><td>C3</td><td>D3</td><td>E3</td><td>F3</td><td>G3</td><td>H3</td></tr><tr><td>A4</td><td>B4</td><td>C4</td><td>D4</td><td>E4</td><td>F4</td><td>G4</td><td>H4</td></tr></tbody></table><br><br><p>第二轮：1场（每组的第一名进行一次赛跑；会再淘汰一部分）</p><table><thead><tr><th>A1</th><th>B1</th><th>C1</th><th>D1</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>A2</td><td>B2</td><td>C2</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>A3</td><td>B3</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>A4</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><br><br><p>第三轮：先选择B1、C1、A2、B2、C2、A3、B3、A4进行赛跑，然后分情况进行探讨：</p><br><p><strong>情况一（11场）：</strong></p><p>如果C1以第二名的成绩晋级（除D1比赛中的第二名，已知B1&gt;C1，所以C1不可能是第一名）</p><p>那么最终第三名（除D1比赛中的第三名）在A2-4、B2-3、C2中产生</p><p>并不能知道D1与它们的快慢，所以需要D1与A2-4、B2-3、C2共7匹马再进行一次比赛</p><p>第一名进入TOP4（是总成绩中的第四名）</p><br><p><strong>情况二（10场）：</strong></p><p>如果C1以第三至七名的成绩完赛（除D1的比赛，已知C1&gt;D1，所以C1不可能是第八名）</p><p>那么除D1这8匹马中的前三名就直接进入TOP4（总成绩中的第二、三、四名）</p><p>无需进行加赛</p><br><br><br><h1 id="概率类问题"><a href="#概率类问题" class="headerlink" title="概率类问题"></a>概率类问题</h1><h2 id="不等概率实现等概率"><a href="#不等概率实现等概率" class="headerlink" title="不等概率实现等概率"></a>不等概率实现等概率</h2><p><strong>问题：</strong></p><p>给定一个函数，有p0概率返回0，p1概率返回1，保证<code>p0+p1=1</code></p><p>利用给定函数，实现一个新的函数：使得有50%的概率返回0，50%的概率返回1</p><br><p><strong>思路：</strong></p><p>如果p0 &#x3D; 1，p1 &#x3D; 1或者p0 &#x3D; 0，p1 &#x3D; 0就重新来过</p><p>否则：出现p0 &#x3D; 1，p1 &#x3D; 0，就返回1</p><p>p0 &#x3D; 0，p1 &#x3D; 1，就返回0</p><br><br><h2 id="先抛硬币获胜的概率"><a href="#先抛硬币获胜的概率" class="headerlink" title="先抛硬币获胜的概率"></a>先抛硬币获胜的概率</h2><p><strong>题目</strong>：两个人轮流抛硬币，谁先抛出正面就获胜，先抛的人获胜的概率是多少</p><br><p><strong>思路</strong>：假设A先，B后</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">P</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">+</span>         <span class="token comment" spellcheck="true">// A直接取胜 </span>       <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">+</span>       <span class="token comment" spellcheck="true">// A1失败B1失败A2取胜</span>       <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">+</span>     <span class="token comment" spellcheck="true">// A1失败B1失败A2失败B2失败A3取胜</span>       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">P</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">7</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">^</span> n<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">/</span><span class="token number">3</span>    <span class="token function">P</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">+</span>     <span class="token comment" spellcheck="true">// A1失败B1取胜</span>       <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">+</span>     <span class="token comment" spellcheck="true">// A1失败B1失败A2失败B2取胜</span>       <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">+</span>  <span class="token comment" spellcheck="true">// A1失败B1失败A2失败B2失败A3失败B3取胜</span>       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">P</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">4</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">6</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">4</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">^</span> n<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><p>由此可见，<strong>先抛的人</strong>获胜的概率更大，为<code>2/3</code>  </p><br><br><h2 id="大小王在同一个人手上的概率"><a href="#大小王在同一个人手上的概率" class="headerlink" title="大小王在同一个人手上的概率"></a>大小王在同一个人手上的概率</h2><p><strong>问题：</strong></p><p>在斗地主中共有54张牌，地主20张，两个农民各17张牌</p><p>求大小王同时在一个人手上的概率</p><br><p><strong>思路：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp">P <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token number">54</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//这里的分子和分母都忽略了大小王交换的情况（等价于分子分母同时除以2）</span>  <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token number">54</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token number">17</span><span class="token operator">/</span><span class="token number">53</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">53</span><span class="token operator">*</span><span class="token number">27</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token number">32.29</span><span class="token operator">%</span><span class="token comment" spellcheck="true">/*分母的第一个式子是指两个农民各自手上拿到大小王的情况分母的第二个式子是指是地主拿到的情况，而地主又分为：    大小王在已分配的手牌中    大小王在额外分配的三张手牌中    大小王有一张在地主牌中，另一张在已分配的手牌中*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><br><h2 id="圆内锐角三角性的概率"><a href="#圆内锐角三角性的概率" class="headerlink" title="圆内锐角三角性的概率"></a>圆内锐角三角性的概率</h2><p><strong>问题：</strong></p><p>求圆上任取三个点组成锐角三角形的概率</p><br><p><strong>答案：</strong><code>1/4</code></p><p>如下图所示，假设圆半径为1。首先固定住A点，我们把A点作为三角形的第一个点</p><p>接下来在圆周取作为三角形第二个点的点C</p><p>点C可能在AB的左边，也可能在AB的右边</p><p>由于左右完全对称，因此不妨设点C在AB的左边</p><p><img src="/medias/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%99%BA%E5%8A%9B%E9%A2%98/%E5%9C%86%EF%BC%8C%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%8C%E6%A6%82%E7%8E%87.png"></p><p><img src="/medias/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%99%BA%E5%8A%9B%E9%A2%98/%E5%9C%86%EF%BC%8C%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%8C%E6%A6%82%E7%8E%87_02.png"></p><br><br><h2 id="火枪手决斗中，活下的概率"><a href="#火枪手决斗中，活下的概率" class="headerlink" title="火枪手决斗中，活下的概率"></a>火枪手决斗中，活下的概率</h2><p><strong>问题：</strong></p><p>彼此痛恨的甲、乙、丙三个枪手准备决斗</p><p>甲枪法最好，十发八中；乙枪法次之，十发六中；丙枪法最差，十发四中</p><p>如果三人同时开枪，并且每人每轮只发一枪</p><p>那么枪战后，谁活下来的机会大一些？</p><br><p><strong>思路：</strong></p><p>对于枪手甲来说，威胁最大的是枪手乙，他因此枪手甲会先射击枪手乙</p><p>对于枪手甲来说，威胁最大的是枪手甲，他因此枪手乙会先射击枪手甲</p><p>对于枪手丙来说，威胁最大的是枪手甲，他因此枪手丙会先射击枪手甲</p><br><p>因此在<strong>第一轮</strong>中：甲射乙，乙射甲，丙射甲</p><p>甲的活率为24%（<code>40% * 60%</code>）</p><p>乙的活率为20%（<code>100% - 80%</code>）</p><p>丙的活率为100%（无人射丙）</p><br><p>而在<strong>第二轮</strong>中，又分为以下情况：</p><p>情况一：甲活乙死（<code>24% X 80% = 19.2%</code>）</p><p>甲射丙，丙射甲：甲的活率为60%，丙的活率为20%</p><p>情况二：乙活甲死（<code>20% X 76% = 15.2%</code>）</p><p>乙射丙，丙射乙：乙的活率为60%，丙的活率为40%</p><p>情况三：甲乙同活（<code>24% X 20% = 4.8%</code>）</p><p>重复第一轮</p><p>情况4：甲乙同死（<code>76% X 80% = 60.8%</code>）</p><p>枪战结束</p><br><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//甲的活率为(19.2% X 60%) + (4.8% X 24%) = 12.672%</span><span class="token comment" spellcheck="true">//乙的活率为(15.2% X 60%) + (4.8% X 20%) = 10.08%</span><span class="token comment" spellcheck="true">//丙的活率为(19.2% X 20%) + (15.2% X 40%) + (4.8% X 100%) + (60.8% X 100%) = 75.52%</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由此得知实际上<strong>丙的存活率是最高的</strong></p><br><br><br><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="连续整数之和为1000的整数有多少组"><a href="#连续整数之和为1000的整数有多少组" class="headerlink" title="连续整数之和为1000的整数有多少组"></a>连续整数之和为1000的整数有多少组</h2><p><strong>思路：</strong></p><p>设有n个连续整数，最小的那个是a，按等差数列求和公式，这n个整数的和为<code>n * a + n * (n-1) / 2</code></p><p>即求方程<code>n * a + n * (n-1) / 2＝1000</code>的整数解</p><p>把方程变为<code>a = 1000 / n - (n - 1) / 2</code>，如果a是整数：</p><ul><li>要么n是奇数且n能整除1000（这样<code>1000 / n</code>和<code>(n - 1) / 2</code>都是整数）</li><li>要么n是偶数且<code>1000 / n</code>的小数部分为0.5，把1000分解为<code>2 * 2 * 2 * 5 * 5 * 5</code></li></ul><p>找出符合条件的数共有4个：<code>1、5、16、25</code></p><br><br><h2 id="二叉树的层数问题"><a href="#二叉树的层数问题" class="headerlink" title="二叉树的层数问题"></a>二叉树的层数问题</h2><p><strong>问题：</strong></p><p>求解层数为<code>n</code>的二叉树总共有多少种</p><br><p><strong>思路：</strong></p><p>分为满二叉树和非满二叉树，比如说二层的二叉树就有的<code>root + lchild</code>、<code>root + rchild</code>，<code>root + l + r</code>这3种 </p><p>零层的二叉树有1种</p><p>一层的二叉树有1种</p><p>二层的二叉树有<code>2 * (a0 * a1) + a1 * a1 = 3</code>种</p><p>三层的二叉树有<code>2 * (a0 * a2 + a1 * a2) + a2 * a2  = 21</code>种</p><p>四层的二叉树有<code>2 * (a0 * a3 + a1 * a3 + a2 * a3) + a3 * a3 = 546</code>种</p><p><code>N</code>层的二叉树有<code>2 * (a0 * an-1 + a1 * an-1 + ...) + an-1 * an-1</code>种</p><br><br><h2 id="跑步问题"><a href="#跑步问题" class="headerlink" title="跑步问题"></a>跑步问题</h2><p><strong>问题：</strong><br>小李早上8点20分在一个400米长的环形跑道上跑步，先是逆时钟跑一分钟，然后掉头顺时钟跑2分钟</p><p>然后又逆时钟3分钟，以此类推，当他跑到起点的时候正好准备掉头</p><p>当小李按逆时针方向跑到出发点，又恰好该往回跑时，他的练习正好停止。如果假设小李一直保持匀速，每分钟跑120米</p><p>请问小李锻炼了多久的时间</p><br><p><strong>思路：</strong></p><p>先逆时针跑x分钟，在顺时针跑x+1分钟，则实际路程便是顺时针跑1分钟</p><p>要让小李逆时针方向跑到出发点，又恰好该往回跑，则表明此时小李的有效跑步长度要是400米的倍数</p><p>即<code>-1 + 2 - 3 + 4 - 5 + 6....</code>，最后得到的结果要是10的倍数（因为<code>120 * 10 % 400 = 0</code>）</p><p>则刚好到19的时候，得到的结果是-10</p><p>因此小李的锻炼时间为<code>1 + 2 + 3 + ...+ 19 = 190</code>分钟</p><br><br><h2 id="掰巧克力问题"><a href="#掰巧克力问题" class="headerlink" title="掰巧克力问题"></a>掰巧克力问题</h2><p><strong>问题：</strong><code>N * M</code>块巧克力，每次掰一块的一行或一列，掰成<code>1 * 1</code>的巧克力需要多少次？</p><br><p><strong>思路：</strong></p><p>每次拿起一块巧克力，掰一下（无论横着还是竖着）都会变成两块</p><p>因为所有的巧克力共有<code>N * M</code>块，所以要掰<code>N * M - 1</code>次</p><p>-1是因为最开始的一块是不用算进去的</p><br><br><h2 id="24小时里面时针分针秒针可以重合几次"><a href="#24小时里面时针分针秒针可以重合几次" class="headerlink" title="24小时里面时针分针秒针可以重合几次"></a>24小时里面时针分针秒针可以重合几次</h2><p><strong>思路：</strong></p><p>24小时中时针走2圈，而分针走24圈，时针和分针重合<code>24-2=22</code>次</p><p>而只要时针和分针重合，秒针一定有机会重合，所以总共重合22次</p><br><br><br><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="https://www.nowcoder.com/discuss/974128" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/974128</a></p><p><a href="https://www.nowcoder.com/discuss/972078" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/972078</a></p><p><a href="https://www.nowcoder.com/discuss/968842" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/968842</a></p><p><code>InterviewGuide</code>第四版阿秀</p>]]></content>
      
      
      
        <tags>
            
            <tag> Interview Problems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题——764.最大加号标志</title>
      <link href="/2022/11/09/mei-ri-yi-ti-764-zui-da-jia-hao-biao-zhi/"/>
      <url>/2022/11/09/mei-ri-yi-ti-764-zui-da-jia-hao-biao-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h1><p>在一个 <code>n x n</code> 的矩阵 <code>grid</code> 中，除了在数组 <code>mines</code> 中给出的元素为 <code>0</code>，其他每个元素都为 <code>1</code>。<code>mines[i] = [xi, yi]</code>表示 <code>grid[xi][yi] == 0</code></p><p>返回 <code>grid</code> 中包含 <code>1</code> 的最大的 <strong>轴对齐</strong> 加号标志的阶数。如果未找到加号标志，则返回 <code>0</code> 。</p><p>一个 <code>k</code> 阶由 <code>1</code> 组成的 <strong>“轴对称”加号标志</strong> 具有中心网格 <code>grid[r][c] == 1</code> ，以及4个从中心向上、向下、向左、向右延伸，长度为 <code>k-1</code>，由 <code>1</code> 组成的臂。注意，只有加号标志的所有网格要求为 <code>1</code> ，别的网格可能为 <code>0</code> 也可能为 <code>1</code> 。</p><br><br><br><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>一开始</strong>想到的是<code>DFS</code>，即对于边界以外的每个点，</p><p>先判断当前数字是否为<code>1</code>，</p><p>接着往四个方向去探寻数字<code>1</code>的数量，</p><p>结果取四个值的最小值，最后再和<code>res</code>进行比较，取最大值</p><br><p><strong>但是</strong>后面发现这样会有很多重复的步骤（比如说某个点右边<code>1</code>的数量，是可以被下一个数复用的；不是说<code>DFS</code>不行，这里理解为空间换时间吧）</p><p>所以可以用动态规划来解决</p><p>对于每个点，都记录以该点作为其他点的上下左右四个方向时，<code>1</code>的数量是多少</p><p>这里可以用数据结构<code>record</code>来记录</p><p>最后依次遍历边界以外的每个点，求四个方向的最小值，接着和<code>res</code>进行比较，取最大值</p><br><p><strong>代码：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> record <span class="token punctuation">{</span>    <span class="token function">record</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">up</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">down</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> up<span class="token punctuation">;</span>    <span class="token keyword">int</span> down<span class="token punctuation">;</span>    <span class="token keyword">int</span> left<span class="token punctuation">;</span>    <span class="token keyword">int</span> right<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">orderOfLargestPlusSign</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> mines<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> mine<span class="token operator">:</span> mines<span class="token punctuation">)</span> <span class="token punctuation">{</span>            f<span class="token punctuation">[</span>mine<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>mine<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>record<span class="token operator">>></span> <span class="token function">records</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>record<span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> record<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> records<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>up <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> records<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>up <span class="token operator">=</span> records<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>up <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> records<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> records<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>left <span class="token operator">=</span> records<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>ty            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> records<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>down <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> records<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>down <span class="token operator">=</span> records<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>down <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> records<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> records<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>right <span class="token operator">=</span> records<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">||</span> j <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>INT_MAX<span class="token punctuation">,</span> records<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>up<span class="token punctuation">)</span><span class="token punctuation">;</span>                ans <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> records<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>down<span class="token punctuation">)</span><span class="token punctuation">;</span>                ans <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> records<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                ans <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> records<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> ans <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><br><br><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>这道题我一开始就是<code>DFS</code>去做的</p><p>后面是看了标签才意识到是动态规划</p><p>只能说题目做少了，很多题都没有意识到大概是啥方向的</p><br><p>另一方面，思路有了，<code>coding</code>的时候思绪被堵住了</p><p>说明代码也是写少了，需要每日一题来提高熟练度</p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题——1684.统计一致字符串的数目</title>
      <link href="/2022/11/08/mei-ri-yi-ti-1684-tong-ji-yi-zhi-zi-fu-chuan-de-shu-mu/"/>
      <url>/2022/11/08/mei-ri-yi-ti-1684-tong-ji-yi-zhi-zi-fu-chuan-de-shu-mu/</url>
      
        <content type="html"><![CDATA[<h1 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h1><p>给你一个由不同字符组成的字符串 <code>allowed</code> 和一个字符串数组 <code>words</code> 。如果一个字符串的每一个字符都在 <code>allowed</code> 中，就称这个字符串是<strong>一致字符串</strong>。</p><p>请你返回 <code>words</code> 数组中<strong>一致字符串</strong>的数目。</p> <br> <br> <br><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>直接<code>set</code>存储字符</p><p>再一一对照遍历即可</p><br><p>不过，看到官方给的一种解法：</p><p>因为这里要求的只有26个字母，所以可以用一个<code>int</code>整型的32位来标记是否有当前字母</p><p>不过缺点，就是会降低一点点代码的可读性吧hhhh</p><br><p><strong>代码：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//我的解法</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">countConsistentStrings</span><span class="token punctuation">(</span>string allowed<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> words<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unordered_set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> set_<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> a<span class="token operator">:</span> allowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>            set_<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> ans<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> word<span class="token operator">:</span> words<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> w<span class="token operator">:</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>set_<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token operator">--</span> ans<span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token operator">++</span> ans<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//官方最优解</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">countConsistentStrings</span><span class="token punctuation">(</span>string allowed<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> words<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> set_<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> a<span class="token operator">:</span> allowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>            set_ <span class="token operator">|</span><span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>a <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> ans<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> word<span class="token operator">:</span> words<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> w<span class="token operator">:</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>set_ <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>w <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token operator">--</span> ans<span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token operator">++</span> ans<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题——816.模糊坐标</title>
      <link href="/2022/11/07/mei-ri-yi-ti-816-mo-hu-zuo-biao/"/>
      <url>/2022/11/07/mei-ri-yi-ti-816-mo-hu-zuo-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h1><p>我们有一些二维坐标，如 <code>&quot;(1, 3)&quot;</code> 或 <code>&quot;(2, 0.5)&quot;</code>，然后我们移除所有逗号，小数点和空格，得到一个字符串S。返回所有可能的原始字符串到一个列表中。</p><p>原始的坐标表示法不会存在多余的零，所以不会出现类似于<code>&quot;00&quot;</code>, <code>&quot;0.0&quot;</code>, <code>&quot;0.00&quot;</code>, <code>&quot;1.0&quot;</code>, <code>&quot;001&quot;</code>, <code>&quot;00.01&quot;</code>或一些其他更小的数来表示坐标。此外，一个小数点前至少存在一个数，所以也不会出现<code>“.1”</code>形式的数字。</p><p>最后返回的列表可以是任意顺序的。而且注意返回的两个数字中间（逗号之后）都有一个空格。</p><br><br><br><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>一开始想到的就是<strong>DFS</strong>，将每次深搜分为以下几种情况：</p><p>1、当前坐标是最后一位，那就直接加上<code>)</code>即可</p><p>2、当前坐标不是最后一位</p><ul><li><p>可以尝试放数字到末尾</p></li><li><p>或是放小数点</p></li><li><p>或是放逗号</p></li></ul><p>但是发现，放逗号和小数点是有点难处理的（需要细分当前情况是否可以放小数点或是逗号；比如说逗号只能放一个、小数点各一个逗号放一个）</p><p>同时发现情况1有一点问题：如果最后的数字是<code>001</code>，或是<code>1.100</code>，就还需要额外的处理</p><br><br><p>因此修改了整体的框架思路：</p><p><strong>首先</strong>记录当前位置的前一个位置的数字（比如说前面是<code>1.001</code>，那么此时记录的就是<code>001</code>；或者说前面记录的是<code>, 002</code>，那么此时记录的就是<code>002</code>）</p><p>此刻下标<code>j</code>指向的就是<code>1.001</code>中的<code>.</code>，或是<code>, 002</code>中的<code> </code></p><br><p><strong>接着</strong>，先判断当前坐标是不是最后一位，如果是的话，就根据情况来判断是否要<code>push_back</code>字符（比如说整数，或是小数部分，是否有多余的0的情况；具体的判断方法见代码）</p><p><code>PS：</code>注意，这里必须要放入了一个逗号以后，才能放入到<code>ans</code>中</p><br><p><strong>然后</strong>，数字在什么情况下都是可以直接放的</p><br><p><strong>最后：</strong></p><p>如果是整数，就需要判断前面是否有多余的0</p><p>如果是小数，就要判断后面是否有多余的0，</p><p>上述一旦有多余的0，就<code>return</code></p><p>判断完后，再根据情况适当的添加逗号或小数点</p><p><code>PS：</code> <code>count</code>的作用是记录逗号的数量，<code>smallpoint</code>是记录小数点的数量（每次放置了逗号以后，都要重置小数点的数量）</p><br><p><strong>代码：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> ans<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> string temp<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">,</span> <span class="token keyword">int</span> smallpoint<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> temp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'.'</span> <span class="token operator">&amp;&amp;</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'('</span> <span class="token operator">&amp;&amp;</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">' '</span><span class="token punctuation">)</span> <span class="token operator">--</span> j<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'.'</span> <span class="token operator">&amp;&amp;</span> temp<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'0'</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>temp <span class="token operator">+</span> <span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>temp<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token operator">||</span> temp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span> <span class="token operator">==</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>temp <span class="token operator">+</span> <span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> temp <span class="token operator">+</span> s<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> count<span class="token punctuation">,</span> smallpoint<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'('</span> <span class="token operator">||</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> temp<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span> <span class="token operator">&amp;&amp;</span> temp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span> <span class="token operator">!=</span> j<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 整数部分前面有多余的0</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'.'</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>temp<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//    小数部分后面有多余的0</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> index <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> temp<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'.'</span><span class="token punctuation">)</span> <span class="token function">dfs</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> temp <span class="token operator">+</span> <span class="token string">", "</span><span class="token punctuation">,</span> index<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>smallpoint <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> temp<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">' '</span> <span class="token operator">&amp;&amp;</span> temp<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'('</span><span class="token punctuation">)</span> <span class="token function">dfs</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> temp <span class="token operator">+</span> <span class="token string">"."</span><span class="token punctuation">,</span> index<span class="token punctuation">,</span> count<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">ambiguousCoordinates</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">"("</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><br><br><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p><code>DFS</code>的状态机雀实是有点不太好处理，并且很多时候都是自己给数据，面向<code>bug</code>编程….</p><p>但总算是写出来了吧</p><p>后面看了看题解，发现很多人给出的思路就是：</p><p>将字符串中的数字分为两部分，各个部分用小数点隔开并校验合法性</p><p>最后来个双循环，用<code>(,)</code>将结果拼接，再将结果放入<code>ans</code>中</p><p>这种做法<code>coding</code>上雀实舒服</p><p>有点笨比了hhhhhhhhhhhh</p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解CPP之smart pointer</title>
      <link href="/2022/10/26/shen-ru-li-jie-cpp-zhi-smart-pointer/"/>
      <url>/2022/10/26/shen-ru-li-jie-cpp-zhi-smart-pointer/</url>
      
        <content type="html"><![CDATA[<h1 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>遵循共享所有权的概念，即不同的 shared_ptr 对象可以与相同的指针相关联</p><p>如果指向的资源没有任何一方需要的话，就会析构并释放资源</p><br><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>每个<code>shared_ptr</code>对象在会在栈上设立两个指针，分别指向堆上的两个数据（因此在X86-64位的系统中，其大小为<strong>16字节</strong>）</p><ul><li>指向对象的指针（具体的数据对象）</li><li>指向引用计数的指针（最初计数将为1；不可能是static存储）</li></ul><br><p>引用计数的增减</p><ul><li>当有新的<code>shared_ptr</code>创建，引用计数设置为1</li><li>当调用拷贝构造函数，引用计数加1</li><li>当<code>shared_ptr</code>超出作用域，引用计数减1</li><li>当调用<code>reset</code>函数时，首先会生成新对象，并将原指针的引用计数减1，最后再将新对象的指针交给当前指针</li><li>如果引用计数为0，就会析构对象数据</li></ul><br><p>因此当<code>shared_ptr</code>修改指向时，一方面要注意计数的增减，另一方面要注意对象的析构</p><br><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token comment" spellcheck="true">//头文件</span><span class="token comment" spellcheck="true">//创建shared_ptr</span><span class="token comment" spellcheck="true">//因为带有参数的 shared_ptr 构造函数是 explicit 类型的，所以不能像这样 std::shared_ptr&lt;int> p1 = new int(1); 隐式调用它的构造函数</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//两个指针指向同一个对象</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p3 <span class="token operator">=</span> p2<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//std::make_shared创建shared_ptr</span><span class="token comment" spellcheck="true">//std::make_shared 一次性为int对象和用于引用计数的数据都分配了内存，而new操作符只是为int分配了内存</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p1 <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建空对象</span><span class="token comment" spellcheck="true">// 返回shared_ptr的引用计数</span><span class="token keyword">int</span> count <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//分离原始指针</span>p1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使引用计数减一</span>p1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">34</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当前指针指向新的数据，原指针指向的数据引用计数减一，新数据的引用计数重置为1</span>p1 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 重置指针</span><span class="token comment" spellcheck="true">//shared_ptr可以当做普通指针，我们可以将*和->与shared_ptr对象一起使用，也可以指针间进行比较</span><span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token number">78</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//指针的*运算</span><span class="token keyword">if</span> <span class="token punctuation">(</span>p1 <span class="token operator">==</span> p2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//指针间的比较</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p1 and p2 are pointing to same pointer\n"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//三种不同的删除器</span>    <span class="token comment" spellcheck="true">//使用的背景：</span>    <span class="token comment" spellcheck="true">//需要添加自定义删除器的使用方式</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p3</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//仅用于演示自定义删除器（这里的delete不能满足需求，所以需要自定义删除器或shared_ptr&lt;int[]>）</span>    <span class="token comment" spellcheck="true">//指向数组的智能指针可以使用这种形式</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">p3</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//正确使用方式</span>    <span class="token comment" spellcheck="true">//函数作为删除器</span><span class="token keyword">void</span> <span class="token function">deleter</span><span class="token punctuation">(</span>Sample <span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"DELETER FUNCTION CALLED"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Sample<span class="token operator">></span> <span class="token function">p3</span><span class="token punctuation">(</span><span class="token keyword">new</span> Sample<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span> deleter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//函数对象作为删除器</span><span class="token keyword">class</span> <span class="token class-name">Deleter</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Sample <span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 重载()运算符</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"DELETER FUNCTION CALLED"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Sample<span class="token operator">></span> <span class="token function">p3</span><span class="token punctuation">(</span><span class="token keyword">new</span> Sample<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">Deleter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//Lambda表达式作为删除器</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Sample<span class="token operator">></span> <span class="token function">p4</span><span class="token punctuation">(</span><span class="token keyword">new</span> Sample<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Sample <span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">"DELETER FUNCTION CALLED"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//const和shared_ptr</span><span class="token keyword">const</span> shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等价于 T *const a，顶层const不能改变指针的值</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">></span> a<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等价于 const T* a，底层const不能改变指针所指对象的值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>创建<code>shared_ptr</code>对象而不分配任何值时，为空指针</p><ul><li>普通指针不分配空间的时候相当于一个野指针，而smart point则自动指向空值</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr3<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ptr3<span class="token punctuation">)</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Yes, ptr3 is empty"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ptr3 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr3 is empty"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ptr3 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr3 is empty"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>与普通指针相比，shared_ptr仅提供<code>-&gt;</code> 、<code>*</code>和<code>==</code>运算符，没有<code>+</code>、<code>-</code>、<code>++</code>、<code>--</code>、<code>[]</code>等运算符</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">struct</span> Sample <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">dummyFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"dummyFunction"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Sample<span class="token operator">></span> ptr <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Sample<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">dummyFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span>    ptr<span class="token operator">-</span><span class="token operator">></span><span class="token function">dummyFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// ok</span>    <span class="token comment" spellcheck="true">// ptr[0]->dummyFunction(); // error</span>    <span class="token comment" spellcheck="true">// ptr++;  // error</span>    <span class="token comment" spellcheck="true">// ptr--;  // error</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Sample<span class="token operator">></span> <span class="token function">ptr2</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> ptr2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// ok</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr and ptr2 are equal"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><p>使用不当导致死锁，从而出现内存泄漏</p><ul><li>解决办法：使用weak_ptr防止死锁</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//一段内存泄露的代码</span><span class="token keyword">struct</span> Son<span class="token punctuation">;</span><span class="token keyword">struct</span> Father　<span class="token punctuation">{</span>    shared_ptr<span class="token operator">&lt;</span>Son<span class="token operator">></span> son_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Son <span class="token punctuation">{</span>    shared_ptr<span class="token operator">&lt;</span>Father<span class="token operator">></span> father_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> father <span class="token operator">=</span> make_shared<span class="token operator">&lt;</span>Father<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> son <span class="token operator">=</span> make_shared<span class="token operator">&lt;</span>Son<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    father<span class="token operator">-</span><span class="token operator">></span>son_ <span class="token operator">=</span> son<span class="token punctuation">;</span>    son<span class="token operator">-</span><span class="token operator">></span>father_ <span class="token operator">=</span> father<span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h2><h3 id="不要使用raw-pointer构建smart-pointer"><a href="#不要使用raw-pointer构建smart-pointer" class="headerlink" title="不要使用raw pointer构建smart pointer"></a>不要使用raw pointer构建smart pointer</h3><p>会造成生命周期的错乱：可能一方的smart pointer把资源释放了，而另一方raw pointer认为资源正常</p><ul><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//会造成资源的二次释放</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr2<span class="token punctuation">{</span>p<span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"count ptr2:"</span> <span class="token operator">&lt;&lt;</span> ptr2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr1<span class="token punctuation">{</span>p<span class="token punctuation">}</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"count ptr1:"</span> <span class="token operator">&lt;&lt;</span> ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//这里的p和ptr2都是悬空指针；因为ptr1就把数据给析构了，那么ptr2再去析构，就会造成问题</span><span class="token comment" spellcheck="true">//同样是raw pointer造成的问题，和上面类似</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">pp</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span><span class="token operator">*</span>pp<span class="token punctuation">)</span> <span class="token operator">--</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token operator">++</span> <span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//此时，数据就会被删除掉了（因为在p1在{}中认为只有它自己拿到了这个数据，那么出来的时候就会把数据给销毁掉，造成的结果就是访问到未知的数据）</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//同样是将raw pointer放入smart point中，造成生命周期的错乱</span><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>name<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">name_</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">addToGroup</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>shared_ptr<span class="token operator">&lt;</span>Student<span class="token operator">>></span> <span class="token operator">&amp;</span>group<span class="token punctuation">)</span> <span class="token punctuation">{</span>        group<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>Student<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//error</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    string name_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><br><p>解决办法：杜绝使用raw pointer的做法；使用<code>enable_shared_from_this</code>解决类指针<code>this</code>放入<code>smart pointer</code>的问题</p><ul><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token operator">:</span> <span class="token keyword">public</span> std<span class="token operator">::</span>enable_shared_from_this<span class="token operator">&lt;</span>Student<span class="token operator">></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>name<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">name_</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">addToGroup</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>shared_ptr<span class="token operator">&lt;</span>Student<span class="token operator">>></span> <span class="token operator">&amp;</span>group<span class="token punctuation">)</span> <span class="token punctuation">{</span>        group<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    string name_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><br><h3 id="不要使用栈中的指针构建smart-pointer"><a href="#不要使用栈中的指针构建smart-pointer" class="headerlink" title="不要使用栈中的指针构建smart pointer"></a>不要使用栈中的指针构建smart pointer</h3><p>shared_ptr 默认的构造函数中使用的是<code>delete</code>来删除关联的指针，所以构造的时候也必须使用<code>new</code>出来的堆空间的指针</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//coredump</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当 shared_ptr 对象超出作用域调用析构函数delete指针&amp;x时会出错</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决办法：使用<code>make_shared()&lt;&gt;</code>创建 shared_ptr 对象，而不是使用默认构造函数创建</p><br><h3 id="不要随意用get-获取原始指针"><a href="#不要随意用get-获取原始指针" class="headerlink" title="不要随意用get()获取原始指针"></a>不要随意用get()获取原始指针</h3><ul><li>因为如果在 shared_ptr 析构之前手动调用了<code>delete</code>函数，同样会导致悬空指针</li><li>不要保存sp.get()的返回值，无论是保存为裸指针还是shared_ptr都是错误的，保存为裸指针不知什么时候就会变成空悬指针，保存为shared_ptr则产生了独立指针</li><li>不要delete sp.get()的返回值，会导致对一块内存delete两次的错误</li></ul><br><br><br><h1 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p><code>unique_ptr</code>是C++ 11提供的用于防止内存泄漏的智能指针中的一种实现，独享被管理对象指针所有权的智能指针</p><ul><li>unique_ptr对象始终是关联的原始指针的唯一所有者。我们无法复制unique_ptr对象，它只能移动（move）</li><li>由于每个unique_ptr对象都是原始指针的唯一所有者，因此在其析构函数中它直接删除关联的指针（所以unique_ptr的组成就单单是一个指针）</li></ul><p><code>unique_ptr</code>具有<code>-&gt;</code>和<code>*</code>运算符重载符，因此它可以像普通指针一样使用</p><br><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token comment" spellcheck="true">//  创建unique_ptr对象</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">taskPtr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//  或者以下方法</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">taskPtr</span><span class="token punctuation">(</span><span class="token keyword">new</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span><span class="token function">element_type</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//  std::make_unique&lt;>()是C++14引入的</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> taskPtr <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">34</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//  创建空指针</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> taskPtr<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//  因为smart pointer的构造函数时explicit，所以不能赋值构造</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> taskPtr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error</span><span class="token comment" spellcheck="true">//  构建数组对象</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">taskPtr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//  或者以下方法</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">taskPtr</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//  释放关联指针并释放原始指针的所有权，然后返回原始指针（不会delete原始指针）</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">taskPtr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">55</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> taskPtr<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//想操作原始指针一样操作smart pointer</span><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> taskPtr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>taskPtr <span class="token operator">||</span> taskPtr <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr1 is empty"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//  重置指针，delete其关联的指针，重置当前指针为空</span>taskPtr<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//  所有权的转移：unique_ptr不能复制，但是可以通过move进行移动（move后原指针变为空）</span><span class="token comment" spellcheck="true">//  因此unique_ptr不能用于函数参数的值传递，只能用引用传递（但是可以作为返回值使用）</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">taskPtr2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">55</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> taskPtr4 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>taskPtr2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//函数返回unique_ptr</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> up<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//指定删除器，https://blog.csdn.net/hp_cpp/article/details/103210135</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><br><br><h1 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>shared_ptr强引用导致循环引用，最后资源泄漏</p><ul><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">parent</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">children</span><span class="token punctuation">;</span> <span class="token keyword">typedef</span> shared_ptr<span class="token operator">&lt;</span>parent<span class="token operator">></span> parent_ptr<span class="token punctuation">;</span><span class="token keyword">typedef</span> shared_ptr<span class="token operator">&lt;</span>children<span class="token operator">></span> children_ptr<span class="token punctuation">;</span> <span class="token keyword">class</span> <span class="token class-name">parent</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token operator">~</span><span class="token function">parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"destroying parent"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//weak_ptr&lt;children>  children;</span>    children_ptr children<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">class</span> <span class="token class-name">children</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token operator">~</span><span class="token function">children</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"destroying children"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">public</span><span class="token operator">:</span>    parent_ptr parent<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//weak_ptr&lt;parent>  parent;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    parent_ptr <span class="token function">father</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    children_ptr <span class="token function">son</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">children</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     father <span class="token operator">-</span><span class="token operator">></span> children <span class="token operator">=</span> son<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> son<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    son <span class="token operator">-</span><span class="token operator">></span> parent <span class="token operator">=</span> father<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> father<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"begin test..."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"end test..."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><br><p>强引用：当被引用的对象活着的时候，这个引用也存在</p><p>弱引用：当引用的对象活的时候不一定存在 。仅仅是当它存在的时候的一个引用</p><ul><li>弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存</li></ul><br><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><ul><li>weak_ptr类型指针并不会影响所指堆内存空间的引用计数（弱引用）<ul><li>当weak_ptr类型指针的指向和某一shared_ptr指针相同时，weak_ptr指针并不会使所指堆内存的引用计数加1</li><li>当weak_ptr指针被释放时，之前所指堆内存的引用计数也不会因此而减1</li></ul></li><li>weak_ptr<strong>没有重载*和-&gt;运算符</strong>，因此weak_ptr类型指针只能访问某一shared_ptr指针指向的堆内存空间，无法对其进行修改</li><li>弱引用的存在周期一定要比主对象的存在周期要短（否则容易存在空悬指针的情况）</li></ul><br><h2 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h2><ul><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//  创建一个空的weak_ptr指针</span>std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> wp1<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//  用已有的指针创建</span><span class="token comment" spellcheck="true">//  若wp1为空指针，则wp2也为空指针</span><span class="token comment" spellcheck="true">//  反之，如果wp1指向某一shared_ptr指针拥有的堆内存，则wp2也指向该块存储空间（可以访问，但无所有权）</span>std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp2</span><span class="token punctuation">(</span>wp1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//  指向一个shared_ptr指针拥有的堆内存</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp3</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//  只能由weak_ptr和shared_ptr演变而来</span><span class="token comment" spellcheck="true">//可以用=赋值weak_ptr</span>std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> pb4 <span class="token operator">=</span> wp3<span class="token punctuation">;</span>std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> pb5 <span class="token operator">=</span> sp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将当前指针重置为空</span>pb5<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//查看当前引用对象的引用计数(weak_ptr是不计数的)</span><span class="token keyword">int</span> count <span class="token operator">=</span> pb5<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//因为没有重载*等符号，所以如果要判断当前指针是否为空，就得用expired()（返回true表示资源不存在了，返回false表示资源依然存在）</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p1<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"live!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//交换两个指针的指向</span>pb4<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>pb5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果当前weak_ptr已经过期，则该函数会返回一个空的shared_ptr；反之，该函数返回一个和当前weak_ptr指向相同的shared_ptr</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> co <span class="token operator">=</span> pb4<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><br><br><br><h1 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h1><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><ul><li><p>c++早期都是raw pointer，所以希望有一个smart pointer能够自动管理资源，不用手动释放</p></li><li><p>auto_ptr的缺点便是拷贝构造或者赋值的时候，auto_ptr会把原有的指针赋给对方，导致自身变为空指针，从而出现问题</p><ul><li>比如说在容器中，很难避免不对容器中的元素实现赋值传递，这样便会使容器中多个元素被置为空指针</li><li>再或者说，auto_ptr作为值传递的时候，auto_ptr就会把值传给函数，使得本身变为空指针，然后作为函数参数的指针就会在函数的周期中消失，不仅使得auto_ptr始终是一个空指针，还使得原来的对象被销毁</li></ul></li><li><p>由此引发了两种类型的指针：</p><ul><li>shared_ptr（值传递的时候会创建新的指针指向原来的值，而不会使得原来的指针变为空指针）</li><li>unique_ptr（不能用于值传递，只能用引用传递和move）</li></ul></li></ul><br><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//测试拷贝构造</span>    std<span class="token operator">::</span>auto_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>auto_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp2</span><span class="token punctuation">(</span>sp1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sp1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sp1 is not empty."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sp1 is empty."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sp2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sp2 is not empty."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sp2 is empty."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//测试赋值构造</span>    std<span class="token operator">::</span>auto_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp3</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>auto_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> sp4<span class="token punctuation">;</span>    sp4 <span class="token operator">=</span> sp3<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sp3<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sp3 is not empty."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sp3 is empty."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sp4<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sp4 is not empty."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sp4 is empty."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**sp1 is empty.sp2 is not empty.sp3 is empty.sp4 is not empty.**/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><br><br><br><h1 id="enable-shared-from-this"><a href="#enable-shared-from-this" class="headerlink" title="enable_shared_from_this"></a>enable_shared_from_this</h1><h2 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h2><ul><li><p>在实际开发中，有时需要在类中返回包裹当前对象的shared_ptr指针给外部使用</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token operator">:</span> <span class="token keyword">public</span> std<span class="token operator">::</span>enable_shared_from_this<span class="token operator">&lt;</span>A<span class="token operator">></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A constructor"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A destructor"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> <span class="token function">getSelf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用该函数可以返回一个包裹A对象的shared_ptr</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> <span class="token function">sp1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> sp2 <span class="token operator">=</span> sp1 <span class="token operator">-</span><span class="token operator">></span> <span class="token function">getSelf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use count: "</span> <span class="token operator">&lt;&lt;</span> sp1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><br><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><p>共享栈对象的 this 给智能指针对象导致coredump</p><ul><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    A a<span class="token punctuation">;</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> sp2 <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">getSelf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use count: "</span> <span class="token operator">&lt;&lt;</span> sp2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//coredump，因为smart pointer默认对象是存储在堆上的，而这里的a是在栈上存储的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><br><p>循环引用</p><ul><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token operator">:</span> <span class="token keyword">public</span> std<span class="token operator">::</span>enable_shared_from_this<span class="token operator">&lt;</span>A<span class="token operator">></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        m_i <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//注意:</span>        <span class="token comment" spellcheck="true">//比较好的做法是在构造函数里面调用shared_from_this()给m_SelfPtr赋值</span>        <span class="token comment" spellcheck="true">//但是很遗憾不能这么做,如果写在构造函数里面程序会直接崩溃</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A constructor"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        m_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A destructor"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        m_SelfPtr <span class="token operator">=</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span>                 m_i<span class="token punctuation">;</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span>  m_SelfPtr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> <span class="token function">spa</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        spa<span class="token operator">-</span><span class="token operator">></span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 这里出界的时候，spa指向的对象的引用计数由2变为1，导致的情况就是A的引用计数是因为A里面有一个指针指向自身，而里面指针要销毁就需要把A给销毁，造成了死锁</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><br><br><br><h1 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h1><h2 id="智能指针的大小"><a href="#智能指针的大小" class="headerlink" title="智能指针的大小"></a>智能指针的大小</h2><ul><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"size of shared_ptr："</span> <span class="token operator">&lt;&lt;</span>  <span class="token keyword">sizeof</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"size of unique_ptr："</span> <span class="token operator">&lt;&lt;</span>  <span class="token keyword">sizeof</span><span class="token punctuation">(</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"size of weak_ptr："</span> <span class="token operator">&lt;&lt;</span>  <span class="token keyword">sizeof</span><span class="token punctuation">(</span>std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"size of auto_ptr："</span> <span class="token operator">&lt;&lt;</span>  <span class="token keyword">sizeof</span><span class="token punctuation">(</span>std<span class="token operator">::</span>auto_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*size of shared_ptr：16size of unique_ptr：8size of weak_ptr：16size of auto_ptr：8*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><br><h2 id="手写shared-ptr"><a href="#手写shared-ptr" class="headerlink" title="手写shared_ptr"></a>手写shared_ptr</h2><ul><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Shared_mptr</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//空类构造，count，ptr均置空</span>    <span class="token function">Shared_mptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">ptr_</span><span class="token punctuation">(</span><span class="token punctuation">(</span>T <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//赋值构造，count返回int指针，必须new int，ptr指向值</span>    <span class="token function">Shared_mptr</span><span class="token punctuation">(</span>T <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">ptr_</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//拷贝构造，注意是&amp;引用，此处注意的一点是，count需要+1</span>    <span class="token function">Shared_mptr</span><span class="token punctuation">(</span>Shared_mptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">&amp;</span>other<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">++</span><span class="token operator">*</span>other<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">ptr_</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>ptr_<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//重载->返回T*类型</span>    T <span class="token operator">*</span><span class="token keyword">operator</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> ptr_<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//重载*返回T&amp;引用</span>    T <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span>ptr_<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//重载=，此处需要将源计数减一，并判断是否需要顺便析构源，然后将thiscount+1，注意最后返回*this</span>    Shared_mptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Shared_mptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">&amp;</span>other<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> <span class="token operator">&amp;</span>other<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token operator">++</span><span class="token operator">*</span>other<span class="token punctuation">.</span>count<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>ptr_ <span class="token operator">&amp;&amp;</span> <span class="token operator">--</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">delete</span> ptr_<span class="token punctuation">;</span>            <span class="token keyword">delete</span> count<span class="token punctuation">;</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete from ="</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>count <span class="token operator">=</span> other<span class="token punctuation">.</span>count<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>ptr_ <span class="token operator">=</span> other<span class="token punctuation">.</span>ptr_<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//析构，当ptr_存在且在此次析构后count==0，真正析构资源</span>    <span class="token operator">~</span><span class="token function">Shared_mptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr_ <span class="token operator">&amp;&amp;</span> <span class="token operator">--</span><span class="token operator">*</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">delete</span> ptr_<span class="token punctuation">;</span>            <span class="token keyword">delete</span> count<span class="token punctuation">;</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete from ~"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//返回count</span>    <span class="token keyword">int</span> <span class="token function">getRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">*</span>count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token operator">*</span>count<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//注意此处是count*，因为计数其实是同一个count，大家都以指针来操作；</span>    T <span class="token operator">*</span>ptr_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><br><h2 id="手写线程安全的shared-ptr"><a href="#手写线程安全的shared-ptr" class="headerlink" title="手写线程安全的shared_ptr"></a>手写线程安全的shared_ptr</h2><br><h2 id="手写unique-ptr"><a href="#手写unique-ptr" class="headerlink" title="手写unique_ptr"></a>手写unique_ptr</h2><ul><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">UniquePtr</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//构造函数</span>    <span class="token function">UniquePtr</span><span class="token punctuation">(</span>T <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">m_pResource</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//析构函数</span>    <span class="token operator">~</span><span class="token function">UniquePtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">del</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//先删除源对象，而后复制</span>    <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span>T <span class="token operator">*</span>pResource<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">del</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m_pResource <span class="token operator">=</span> pResource<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//交给</span>    T<span class="token operator">*</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        T <span class="token operator">*</span>tmp <span class="token operator">=</span> m_pResource<span class="token punctuation">;</span>        m_pResource <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    T<span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> m_pResource<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">operator</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> m_pResource <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    T <span class="token operator">*</span><span class="token keyword">operator</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> m_pResource<span class="token punctuation">;</span> <span class="token punctuation">}</span>    T <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span>m_pResource<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">del</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m_pResource <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">delete</span> m_pResource<span class="token punctuation">;</span>        m_pResource <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">UniquePtr</span><span class="token punctuation">(</span>UniquePtr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">&amp;</span>other<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    UniquePtr <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> UniquePtr <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    T <span class="token operator">*</span>m_pResource<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><br><h2 id="unique-ptr和shared-ptr的转化"><a href="#unique-ptr和shared-ptr的转化" class="headerlink" title="unique_ptr和shared_ptr的转化"></a>unique_ptr和shared_ptr的转化</h2><ul><li><p>unique_ptr是可以转换为shared_ptr的，因为unique_ptr的语义是唯一拥有ownership，那只要对他执行move操作就能把ownership转移出去给shared_ptr</p><ul><li><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> a <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> b <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li><li><p>shared_ptr是不可以转化为unique_ptr的，因为shared_ptr的对象会被很多人拥有，不好直接转为unique_ptr</p></li></ul><br><br><br><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/150555165" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/150555165</a></li><li><a href="https://www.zhihu.com/question/319277442/answer/1517987598" target="_blank" rel="noopener">https://www.zhihu.com/question/319277442/answer/1517987598</a></li><li><a href="https://zhuanlan.zhihu.com/p/532215950" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/532215950</a></li><li><a href="https://zhuanlan.zhihu.com/p/416289479%EF%BC%88shared_ptr%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%89" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/416289479（shared_ptr是否线程安全）</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Google File System</title>
      <link href="/2022/10/24/the-google-file-system/"/>
      <url>/2022/10/24/the-google-file-system/</url>
      
        <content type="html"><![CDATA[<p>gfs为google内部的文件系统，其开源实现为hdfs，大数据领域标准的开源实现</p><p>GFS是一个存储非结构化数据的存储系统，和bigtable（列存储，存储结构化数据，关系模型，表结构）是相对应的</p><p>GFS只存储数据，不关心数据的结构和内容是什么；GFS里面只存储字节码，不关心具体的数据是什么 </p><p>可能我们只是需要顺序的读取文件的数据，并不需要什么额外的操作</p><p>某些场景下，就是不需要sql去对数据进行查看，单纯的只是想要对数据进行读取</p><p>而GFS是很多组件的基础，比如说HBASE等kv数据库，它们的底层就是GFS</p><p>三种结构：列存储，结构化数据，文件系统存储非结构化数据</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>大规模可拓展容错的分布式文件系统</p><p>大规模：TB级的文件大小</p><p>拓展：10台能够存入1TB，100台能够存入10TB，水平拓展</p><p>容错：100台机器，坏了30台机器，剩下的70台照样能够提供服务，外界无感知，系统内部的错误不会被传播出去</p><p>能够运行在廉价的服务器上（有磁盘有网络，就能够运行在上面；或者是虚拟机，只要有磁盘网络即可）</p><p>因此这种能够运行在廉价服务器上的系统，极大的降低了研发成本</p><p>任何技术的演进都需要极大的降低成本（无论时间还是金钱）研发成本，服务器的成本开销</p><br><p>google发现，很多时候业务的需求都是在文件的末尾追加数据（9成以上的需求），也有随机读写的情况，但很少</p><p>极少数有删除修改的需求；大部分都是顺序的将数据写到文件中</p><p>如果能够支持高性能的顺序写和顺序读的话，就可以cover掉90%的需求</p><p>因此支持在文件的尾部数据进行写入（也正是这一需求，导致了api设计上的变化）</p><p>而一般的随机写和随机读也是支持的，但不保证性能上的可靠，同时对于随机写也不能保证一致性</p><p>而该系统是多机的，所以势必遇到分布式的一致性问题（可能会读取到脏数据，被删除的数据，也可能读到多个客户端读取写入时的脏数据，反正就是会读到不符合预期的数据）</p><p>但是会保证最终的一致性，即每个数据至少会被写入到一个副本中</p><p>但GFS降低了一致性的预期</p><br><br><br><h1 id="设计概述"><a href="#设计概述" class="headerlink" title="设计概述"></a>设计概述</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>运行在普通的机器上，机器的失效是常态（全失败和全正常的概率都是很低的，因此至少出现一台机器失败的概率就会很高）</p><p>大文件是普遍存在的（九成九的都是大文件，十几兆的几百兆的都有；存储列表信息），小文件也是存在的（比如一些id的存储）（大文件是主导的）</p><p>大规模的顺序读写是普遍存在的，但是随机读写也是存在的</p><p>也存在多个生产者对同一个大文件进行顺序写的操作</p><p><strong>吞吐优先于延迟</strong>：使用该系统的业务方大部分不是和在线系统相关联的，而是离线分析类型的系统，不会对计算的响应时间有所要求，而是对吞吐量有所要求：因为数据量很大，所以希望在单位时间内处理大量的数据，即把网络带宽打满</p><p>而对于延迟，对单个请求的处理速度和处理时间是没有要求的，所以不是那么的在乎延迟，反而更在会一次性能处理多少的数据，即吞吐</p><p>比如说有一百个任务，会强调在多少时间内完成所有任务，而不是完成单个任务需要多少时间</p><p>因此针对的是离线系统，而不是在线系统</p><p>更加注重一秒钟能够处理到底多少个数据，而不再会处理单个数据需要多少秒</p><p>并不是说延迟不重要了，而是认为能够把网络的吞吐量给打满，每秒处理更多的数据，这是比单个延迟更加重要的事情</p><br><br><h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><p>需要像linux系统一样，是可以分层组织目录的</p><p>对文件的操作，增加数据，删除数据，打开文件，关闭文件，读写文件，顺序读，尾部追加数据（弱化了对文件api的操作）</p><p>还可以获取一些文件的元数据</p><p>快照：拷贝</p><br><br><br><h1 id="Master节点的操作"><a href="#Master节点的操作" class="headerlink" title="Master节点的操作"></a>Master节点的操作</h1><p>整个GFS分为组件，master和chunk等几个组件</p><p>其中chunk节点主要是用来存储数据的，因此很多核心逻辑都是master节点实现的</p><p>比如说master节点需要执行所有的名称空间操作，管理整个系统里所有chunk的副本</p><p>能够决定chunk的存储位置，负责新的chunk和它副本</p><p>协调各种各样的系统活动以保证Chunk被完全复制， 在所有的 Chunk服务器之间的进⾏负载均衡，回收不再使⽤的存储空间</p><h2 id="名称空间管理和锁"><a href="#名称空间管理和锁" class="headerlink" title="名称空间管理和锁"></a>名称空间管理和锁</h2><p>类似linux下的文件目录，一个一个文件夹进行嵌套，类似数状结构；可以组成一个path</p><p>需要支持并发操作，因此需要对路径节点上读锁，对文件节点上写锁</p><p>文件目录被组织成一个多叉树</p><p>可以创建和删除文件夹，移动文件夹</p><p>用同一个map，key存放目录名，value存放子目录</p><br><br><h2 id="副本的位置"><a href="#副本的位置" class="headerlink" title="副本的位置"></a>副本的位置</h2><p>如何规划不同副本到底应该存放在哪个机房</p><p>在磁盘利用率低、最近创建次数、放置距离三者的权衡</p><br><br><h2 id="创建，重新复制，重新负载均衡"><a href="#创建，重新复制，重新负载均衡" class="headerlink" title="创建，重新复制，重新负载均衡"></a>创建，重新复制，重新负载均衡</h2><br><br><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>如果一个副本写入失败了，master会继续让chunk写入副本数据</p><p>但是之前写入失败了的数据，是不会被删除掉的（因为GFS为了写入性能的提高，只进行写入追加的操作，不进行删除操作）</p><p>因此就会存在垃圾文件</p><p>另一方面，磁盘也可能出现损坏的情况，比如说寄存器的零和一发生了跳变，导致数据丢失，造成了副本的失效</p><br><br><br><h1 id="容错与诊断"><a href="#容错与诊断" class="headerlink" title="容错与诊断"></a>容错与诊断</h1><p>一方面是运行的时候保证可用性</p><p>另一方面是如果运行的时候失效了，运维的时候进行服务诊断</p><p>三个方面解释高可用：（这也是运行时的可用性）</p><br><p>方面一：快速恢复（如果集群不可用了，可以在短时间内恢复集群）</p><p>其实就是检查点的快速重启</p><p>一般来说很多chunkserver的状态信息都是维护在master节点上的，如果master节点挂了，就会造成系统上信息的丢失</p><p>而master都是讲数据存储到内存中的</p><p>为了进程崩溃或者内存失效，也会去写一个类似redolog的操作日志，到磁盘上，是以紧追加的形式写上去的</p><p>比如一般信息的更新，租约的更新等等的信息，都会更新到日志上</p><p>同时，不仅要把redolog写到本地磁盘，还要发送给多台其他的机器（影子机器，副本服务器）</p><p>而日志会逐渐变多，导致状态恢复的时候需要大量的时间</p><p>同时，你比如说在一年内做的数据日志就有100GB，难道还需要从头对这100GB的日志进行恢复操作吗，这是很浪费时间精力的</p><p>因此可以参考redis的RDB机制，实现一个写时复制：fork一个新的进程，将此时的数据以一种序列化的机制写入到磁盘中，得到一种快速恢复的快照</p><p>然后就可以把这个检查点之间的数据日志全部给删除了</p><p>这样的话，master节点的恢复，只需要找到最近的checkpoint节点，并执行后面对应的日志，即可快速恢复</p><p>因此又有了checkpoint机制</p><br><p>方面二：冗余存储（如果副本丢失了，那么可以通过多余的副本对数据进行恢复）</p><p>chunk节点的复制之前说过了</p><p>而master节点的复制，master之间存在主从关系</p><p>比如说可能存在主master会挂掉，这个时候就需要副master升为主master节点</p><p>所以副master需要同步主master节点的数据</p><br><p>方面三：数据完整性（能够侦擦到数据中字节级别上的错误；一般通过checksum进行判断）</p><p>读写数据的时候都会去校验一下当前数据计算得到的校验和，与checksum是否一致</p><p>大概机制：每次写入数据的时候，会将数据按照一定的大小，比如64kb或是128kb的大小，对写入的数据计算一个校验和，并存储起来</p><p>而每次读取数据的时候，就会将读取到的数据先算一个校验和，再与已有的校验和进行比较，看看是否相同，</p><p>如果不相同，就会给客户端报错</p><p>这样做的目的就是，看看在这个存储的过程中，底层的存储介质是否会损坏具体的数据内容，从而保证GFS的可靠性</p><p>另一个方面（诊断工具）：</p><p>能够打印各类rpc的日志</p><br><br><br><h1 id="结论与反思"><a href="#结论与反思" class="headerlink" title="结论与反思"></a>结论与反思</h1><p>GFS更像是一个技术文档</p><p>如果我们想要在工作中推进我们的工作的话，需要做的一点就是</p><p>一上来不要先看代码，而是要做数据分析，观察已有系统中是否有尚未解决的问题</p><p>通过监控指标，发现已有的问题，从数据指标中发现问题</p><p>把问题的痛点给列出来以后，再基于这些痛点</p><p>给出一些假设（比如说GFS一上来就说组件的失效是一种常态，所以要更加注重容错）</p><p>比如说我要做的事情，就是用于服务哪些场景的，说明具体的场景</p><p>说明系统的定位，以及当前改进的意义</p><p>紧接着是设计系统的接口，需要从用户的角度来分析如何使用这些接口以及使用场景</p><p>再者就是剖析系统中的每个组件，深入解决每个组件中的问题，分析已有的问题</p><p>这些事情都做好以后，就需要做数据分析，将前后的指标进行对比</p><p>最后总结与回顾</p><br><br><br><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="https://www.bilibili.com/video/BV1rw411R7rH/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1rw411R7rH/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Paper </tag>
            
            <tag> Distributed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解CPP之type conversion</title>
      <link href="/2022/10/23/shen-ru-li-jie-cpp-zhi-type-conversion/"/>
      <url>/2022/10/23/shen-ru-li-jie-cpp-zhi-type-conversion/</url>
      
        <content type="html"><![CDATA[<h1 id="backround"><a href="#backround" class="headerlink" title="backround"></a>backround</h1><p><strong>基类对象转换为派生类对象，是不安全的</strong></p><ul><li><p>派生类是包含于基类的，即基类的“体积”是小于派生类的</p></li><li><p>如果一个指向基类的指针强转为指向派生类的指针（该指针始终指向基类，只是指针类型变了），再通过该指针调用派生类的特有方法或者数据</p></li><li><p>就会访问到未知的数据，从而导致崩溃</p></li><li><p>所以这种转换在<code>dynamic_cast</code>中就会报错</p></li></ul><br><p><strong>派生类对象转换为基类对象，是安全的</strong></p><ul><li>理由同上，派生类是包含于基类的，因此对方法或数据的使用，不会造成越界</li></ul><br><p><strong>派生类指针只能指向派生类，基类指针可以指向基类或派生类</strong></p><br><p><strong>type conversion针对的是指针和引用</strong></p><ul><li>引用可以理解为指针的语法糖</li></ul><br><br><br><h1 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul><li>等价于C里面的强制转换，可以将<code>non-const</code>对象转为<code>const</code>对象</li><li>用于基本数据类型之间的转换（例如<code>int</code>转换为<code>char</code>）</li><li>把空指针转换为目标类型的空指针</li><li>把任何类型的表达式转换成<code>void</code>类型</li><li>也可以用于类对象之间的转换（但没有动态类型检查，所以不安全）</li></ul><p>格式：<code>static_cast&lt;type-id&gt;(expression);</code></p><br><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>更加明显，能够一眼看出转换为什么类型</p><p>更加安全</p><br><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>没有运行时类型检查来保证转换的安全性（<code>dynamic_cast</code>）</p><p>不能用于在不同类型指针之间的转换</p><p>不能用于整型和指针之间的的转换</p><p>不能用于不同类型的引用之间的转化</p><p><strong>不能去除掉已有对象的const或volatile，或者__unaligned属性</strong></p><br><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以理解为C里面强制转换的平替，但又有一些局限性</p><br><br><br><h1 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h1><h2 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h2><ul><li>将基类的指针或引用安全地转换为派生类的指针或引用（前提：该基类指针指向的是派生类，同时<strong>基类必须有虚函数</strong>）</li><li>或是将派生类的指针或引用安全地转换为基类的指针或引用（基类不需要有虚函数）</li></ul><p>格式：<code>dynamic_cast &lt;type-id&gt;(expression)</code>，其中<code>type-id</code>可以是类指针，类引用或<code>void*</code>，<code>expression</code>也要是对应的类型</p><br><p>若对指针进行<code>dynamic_cast</code>，失败返回<code>nullptr</code>，成功返回正常cast后的对象指针</p><p>若对引用进行<code>dynamic_cast</code>，失败抛出一个<strong>异常</strong>，成功返回正常cast后的对象引用</p><br><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;assert.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 父类</span><span class="token keyword">struct</span> Tfather <span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"father's f()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 子类</span><span class="token keyword">struct</span> Tson <span class="token operator">:</span> <span class="token keyword">public</span> Tfather <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"son's f()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 子类独有的成员</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Tfather father<span class="token punctuation">;</span>    Tson son<span class="token punctuation">;</span>    son<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>    Tfather <span class="token operator">*</span>pf<span class="token punctuation">;</span>    Tson <span class="token operator">*</span>ps<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//上行转换：没有问题</span>    ps <span class="token operator">=</span> <span class="token operator">&amp;</span>son<span class="token punctuation">;</span>    pf <span class="token operator">=</span> <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>Tfather <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>ps<span class="token punctuation">)</span><span class="token punctuation">;</span>    pf<span class="token operator">-</span><span class="token operator">></span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//下行转换（pf实际指向子类对象）：没有问题</span>    pf <span class="token operator">=</span> <span class="token operator">&amp;</span>son<span class="token punctuation">;</span>    ps <span class="token operator">=</span> <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>Tson <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>pf<span class="token punctuation">)</span><span class="token punctuation">;</span>    ps<span class="token operator">-</span><span class="token operator">></span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> ps<span class="token operator">-</span><span class="token operator">></span>data <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 访问子类独有成员有效</span>    <span class="token comment" spellcheck="true">//下行转换（pf实际指向父类对象）：含有不安全操作，dynamic_cast则返回nullptr（而static_cast则会无视）</span>    pf <span class="token operator">=</span> <span class="token operator">&amp;</span>father<span class="token punctuation">;</span>    ps <span class="token operator">=</span> <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>Tson <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>pf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>ps <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 违背断言，阻止以下不安全操作</span>    ps<span class="token operator">-</span><span class="token operator">></span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> ps<span class="token operator">-</span><span class="token operator">></span>data <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不安全操作，对象实例根本没有data成员</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>主要用于类之间的转换</p><p>上行转换（派生类转换为基类），和<code>static_cast</code>等效</p><p>下行转换（基类转换为派生类），<code>dynamic_cast</code>具有类型检查功能，更加安全</p><p>相比<code>static_cast</code>会更加耗时，因为<code>dynamic_cast</code>会在运行时进行类型检查来保证转换的安全性</p><br><br><br><h1 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h1><h2 id="用途-2"><a href="#用途-2" class="headerlink" title="用途"></a>用途</h2><ul><li><p>可以将整型转换为指针，也可以把指针转换为数组，或是将指针和引⽤之间进⾏转换</p></li><li><p>从底层对数据进⾏重新解释；依赖具体的平台，可移植性差</p></li><li><p>等价于C里面的强制转换</p></li></ul><p>格式：<code>reinterpret_cast&lt;type-id&gt;(expression);</code>，<code>type-id</code>必须是一个指针、引用、算术类型、函数指针或者成员指针，用于类型之间进行强制转换</p><br><br><br><h1 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h1><h2 id="用途-3"><a href="#用途-3" class="headerlink" title="用途"></a>用途</h2><ul><li>给已有对象添加<code>const</code>或删除<code>const</code>，或是<code>volstile</code></li><li>是唯一一个可以操作常量的转换符</li><li>常量指针（或引用）被转化为非常量指针（或引用），并且仍然指向原来的对象</li><li>一般用于修改底层指针，如<code>const char *p</code>形式</li></ul><p>格式：<code>const_cast &lt;type-id&gt; (expression);</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MapReduce: Simplified Data Processing on Large Clusters</title>
      <link href="/2022/10/23/mapreduce-simplified-data-processing-on-large-clusters/"/>
      <url>/2022/10/23/mapreduce-simplified-data-processing-on-large-clusters/</url>
      
        <content type="html"><![CDATA[<h1 id="mapreduce的背景"><a href="#mapreduce的背景" class="headerlink" title="mapreduce的背景"></a>mapreduce的背景</h1><p>随着业务的增长，待处理的数据集越来越多，单机无法在规定时间内对海量数据进行处理</p><p>因此需要同时使用多台机器对数据进行处理</p><p>而大规模的数据处理，需要同时应对<strong>多机并行协同，网络通信，处理错误，提高执行效率</strong>等问题</p><p>但这些问题会严重的降低开发效率（业务的处理方不仅需要对原有业务进行分析处理，还需要对基础架构出现的问题进行维护），耗时耗力</p><p>因此<strong>Jeff Dean</strong>设计了一种新的编程模型 <strong>MapReduce</strong></p><p>是为了编写在普通机器上运行的大规模并行数据处理程序而抽象出来的编程模型</p><p>为解决<strong>多机并行协同，网络通信，处理错误，提高执行效率</strong> 等通用性问题的一个编程框架</p><br><br><br><h1 id="mapreduce的定义"><a href="#mapreduce的定义" class="headerlink" title="mapreduce的定义"></a>mapreduce的定义</h1><p><img src="/medias/MapReduce-Simplified-Data-Processing-on-Large-Clusters/map%E5%92%8Creduce.png"></p><p>最早来自于对Lisp语言中map&#x2F;reduce原语的借鉴</p><p>经过谷歌大量重复的编写数据处理类的程序，发现所有数据处理的程序都有类似的过程：</p><blockquote><p>将一组输入的数据应用map函数返回一个k&#x2F;v对的结构作为中间数据集，并将具有相同key的数据输入到一个reduce函数中执行，最终返回处理后的结果。</p></blockquote><p>这种计算框架的优点是非常利于并行化：<code>map</code>的过程可以同时在多个机器上运行，<code>reduce</code>的过程也是一样</p><p>所有的依赖和协调的过程都被隐藏于<code>map</code>与<code>reduce</code>函数的数据分发之间（<code>reduce</code>需要的数据，需要先经过<code>map</code>过程）</p><p>有一点细节：<strong>map和reduce都是可以各自并行执行，但reduce执行的前提条件是所有的map函数执行完毕</strong></p><br><p>但<code>mapreduce</code>想要落地，就必须要考虑工程上的永恒问题：<strong>可用性</strong>与<strong>性能</strong></p><p>大规模的机器失效是一种必然现象，因此不能因为某个<code>map</code>任务的失效而导致整体的崩溃</p><p>所以对于大规模分布式程序来说 能够应对局部性失败的容错性与性能同等重要</p><p>这是一个必要的问题，<strong>分布式的容错性本质上就是如何在不可靠的硬件之上构建可靠的软件</strong></p><br><p>简而言之，一个成熟的工业级实现<code>MapReduce</code>就是一个<strong>利用普通机器组成的大规模计算集群进行并行的,高容错,高性能的数据处理函数框架</strong></p><br><br><br><h1 id="mapreduce的应用场景"><a href="#mapreduce的应用场景" class="headerlink" title="mapreduce的应用场景"></a>mapreduce的应用场景</h1><p><strong>分布式Grep</strong>（分布式正则匹配），<strong>URL访问频次统计</strong>，<strong>倒转Web链接图</strong>，<strong>每个主机的关键词向量</strong>，<strong>倒排索引</strong>，<strong>分布式排序</strong></p><br><br><br><h1 id="mapreduce的实现"><a href="#mapreduce的实现" class="headerlink" title="mapreduce的实现"></a>mapreduce的实现</h1><p><img src="/medias/MapReduce-Simplified-Data-Processing-on-Large-Clusters/mapreduce%E7%9A%84%E5%AE%9E%E7%8E%B0.svg"></p><p>步骤一：将用户给定的数据文件按照一定的大小切分为M块（每块的大小从16MB到64MB，用户可自定义大小）</p><ul><li>然后<code>MapReduce</code>库会在集群的若干台机器上启动程序的多个副本</li><li><code>MapReduce</code>库的各个副本有一个特殊的节点——主节点，其它的则为工作节点</li><li>主节点用于将任务分配个各个工作节点</li></ul><p>步骤二：被分配<code>map</code>任务的工作节点读取对应的输入区块内容</p><ul><li>从输入数据中读取kv对，并传给map函数</li><li>由map函数生成的kv对都缓存在内存中</li></ul><p>步骤三：缓存在内存中的数据会被周期性的由划分函数分成R块，并被写入本地磁盘</p><ul><li>数据在本地磁盘的位置会被传回给主节点</li><li>后续主节点会将这些位置再传给reduce工作节点</li></ul><p>步骤四：map任务完成后，reduce工作节点通过主节点获取了数据的位置后，会调用RPC去磁盘读取对应数据</p><ul><li>当reduce工作节点读取完数据后，会将这些数据按key值进行排序，这样相同key值的kv对就会被排列在一起<ul><li>为啥要排序：因为Reduce操作的本质就是对相同的key聚合为一个list，再传入给reduce函数去执行，为了实现这种聚合，就需要将数据排序</li></ul></li><li>如果数据太多了，就需要外部排序</li></ul><p>步骤五：reduce工作节点遍历排序好的中间数据，并将遇到的每个中间key和与它关联的一组中间value传递给用户的reduce函数</p><ul><li>reduce函数会将输出写入由reduce划分过程划分出来的最终输出文件的末尾</li></ul><p>步骤六：当所有的map和reduce任务都完成后，主节点唤醒用户程序</p><br><p>工程实现上的一些细节</p><p>主节点会维护多个数据结构，会存储记录每个map和reduce任务的状态（空闲、处理中、完成），和每台工作机器的ID（对应非空闲的任务）</p><p>同时，主节点是将map任务产生的中间文件的位置传递给reduce任务的通道，所以需要存储每个已完成的map任务产生的R个中间文件的位置和大小</p><p>map节点的任务：读取kv对，执行map函数，输出kv对</p><p>reduce节点的任务：先将kv对按照k值进行排序，并相同k值的value聚合为list，再交给reduce函数去执行，最后输出kv对</p><br><br><br><h1 id="mapreduce的容错"><a href="#mapreduce的容错" class="headerlink" title="mapreduce的容错"></a>mapreduce的容错</h1><p>假设一台机器发生故障的概率为0.001，现在有一万台机器，那么这一万台机器同时正常工作的概率为$$0.999^{1000}$$</p><p>即0.00004517335，所以非常需要对机器的故障进行容错处理</p><h2 id="map节点的容错"><a href="#map节点的容错" class="headerlink" title="map节点的容错"></a>map节点的容错</h2><p>主节点通过周期性的ping-pong心跳机制感知map节点的状态，如果心跳超时认为节点失败</p><p>并将当前worker上的map task传递给其他worker节点完成，同时记录已经完成的任务的状态</p><br><h2 id="reduce节点的容错"><a href="#reduce节点的容错" class="headerlink" title="reduce节点的容错"></a>reduce节点的容错</h2><p>reduce产出的文件是一个持久性的文件，存在副作用（<strong>不是很明白有啥副作用</strong>）</p><p>因此每次reduce被重新分配后要重命名一个新的文件，防止与损坏的文件冲突</p><br><h2 id="主节点的容错"><a href="#主节点的容错" class="headerlink" title="主节点的容错"></a>主节点的容错</h2><p>对于任务执行的元数据产生的中间态可以保持在一个恢复点文件中</p><p>当节点崩溃重启后，可以从最近的一个恢复点重新执行mapreduce任务（有点类似mysql中的checkpoint机制）</p><br><h2 id="其他容错"><a href="#其他容错" class="headerlink" title="其他容错"></a>其他容错</h2><p>所有的持久化操作都会有一定程度上的副作用</p><ul><li>比如写入数据写到一半，任务失败，然后重写数据，会导致数据的冗余写入</li><li>同时可能会误判任务失败；主节点开启了一个新任务执行，同时存在两个任务写同一个文件</li></ul><p>解决方案：</p><p>保证map与reduce产生的文件在执行过程中先存储在临时文件中（以时间戳命名）</p><p>等到提交文件时，将其原子的重命名为最终文件（linux 内核中 重命名操作是有原子性的保证的）</p><br><br><br><h1 id="mapreduce的优化和技巧"><a href="#mapreduce的优化和技巧" class="headerlink" title="mapreduce的优化和技巧"></a>mapreduce的优化和技巧</h1><h2 id="利用局部性原理"><a href="#利用局部性原理" class="headerlink" title="利用局部性原理"></a>利用局部性原理</h2><p>分布式系统中网络带宽非常昂贵，因此需要尽量减少数据在网络中的传输</p><p>因此，可以将map任务分配给那些本地就有输入文件的机器节点上，减少数据的传输</p><p>同时利用流处理思想优化shuffle过程：</p><ul><li>当一个map任务完成后通知main进程后，main进程立即通知reduce任务拉取其中一份文件</li><li>而不必等到所有map任务全部执行完毕后进行网络传输，以此提高了并行性</li></ul><br><h2 id="任务的粒度"><a href="#任务的粒度" class="headerlink" title="任务的粒度"></a>任务的粒度</h2><p>应该配置多少个任务执行map和reduce？</p><p>一些经验性的配置是：</p><ul><li>map任务通常为输入文件总大小除以64M的值（这源于底层的分布式文件系统是以64m为一个chuck进行存储的，即GFS）</li><li>reduce的数量通常是map任务的一半</li><li>同时，为了发挥机器本身的多核特性，一台机器上可以指定多个map和reduce任务来执行，通常是任务总数的百分之一</li></ul><br><h2 id="备用任务"><a href="#备用任务" class="headerlink" title="备用任务"></a>备用任务</h2><p>可能出现长尾延迟的情况，即某些任务执行的时间过长，从而拖累整个任务的执行时长</p><p>解决办法：</p><ul><li>当仅剩下1%的任务时，可以启动备用任务，即同时在两个节点上执行相同的任务</li><li>这样只要其中一个先返回即可结束整个任务，同时释放未完成的任务所占用的资源</li></ul><br><h2 id="划分函数"><a href="#划分函数" class="headerlink" title="划分函数"></a>划分函数</h2><p>一般对于数据的划分，都是按照key的值进行划分排序到对应的中间文件中</p><p>而从工程经验上看，完全可以根据具体的业务需求进行划分</p><p>比如说可以将一个主机下的文件划分到一起，或是相关的定制划分方法</p><br><h2 id="顺序保证"><a href="#顺序保证" class="headerlink" title="顺序保证"></a>顺序保证</h2><p>有时我们需要支持对数据文件按key进行随机访问，或者有序输出，并且为了减少reduce任务的负担</p><p>输出的每个map任务的中间文件都是保证按key递增有序的</p><br><h2 id="合并函数"><a href="#合并函数" class="headerlink" title="合并函数"></a>合并函数</h2><p>map后得到的同一种key的kv对会有很多，比如说词频统计中，某些谓词的频率就很高</p><p>解决办法：预处理，在shuffle之前对其进行一次reduce操作，将这种&lt;are,1&gt;进行合并变为&lt;are,100000&gt;，减少需要传输数据的大小节省网络带宽</p><br><h2 id="输入和输出类型"><a href="#输入和输出类型" class="headerlink" title="输入和输出类型"></a>输入和输出类型</h2><p>有时map 、reduce 函数的输入类型并不是纯文本的，这种情况下如果能输入输出结构化类型是一种理想的情况</p><p>这需要在map、reduce函数之前实现一个类型适配器的组件，同时也可以实现read接口</p><p>不仅仅从文件中读取数据，也可以从数据库等数据源来读取</p><br><h2 id="略过坏记录"><a href="#略过坏记录" class="headerlink" title="略过坏记录"></a>略过坏记录</h2><p>可能数据集中有错误的记录，因此我们的mapreduce框架就需要跳过这些错误，并捕获执行时的异常</p><p>每个map任务要捕获异常，通过安装信号的方式，在程序退出之前执行安装的信息函数把执行到的文件的行号offset等信息发送给主节点。</p><p>主节点在下次调度的时候，将这些offset处的记录作为黑名单列表传递给新的map任务，执行时会对此处的记录跳过执行</p><br><h2 id="本地执行"><a href="#本地执行" class="headerlink" title="本地执行"></a>本地执行</h2><p>为了方便调试对应的mapreduce程序，mapreduce提供单机多进程的实现可以有效的进行本地debug发现问题</p><br><h2 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a>状态信息</h2><p>分布式系统的可观测性尤为重要,  通过在ping-pong过程中将每个worker节点的工作状态进行上报，存储在main进程中</p><p>并提供可访问的网页来展示系统运行的信息，从而实现可解释性</p><br><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>如何在map reduce的处理进行埋点统计？以实现用户自定义的指标监控?  </p><p>需要创建一个原子计数器的对象，由用户在map 和 reduce的函数中在发生某些事件时对其进行累加</p><p>并通过ping-pong的心跳中将数据携带回main进程累加进去，但要注意每次消息的幂等性来保证不会导致重复累加或者少累加了计数的情况</p><br><br><br><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="https://hardcore.feishu.cn/docs/doccnxwr1i2y3Ak3WXmFlWLaCbh" target="_blank" rel="noopener">https://hardcore.feishu.cn/docs/doccnxwr1i2y3Ak3WXmFlWLaCbh</a></p><p><a href="https://hardcore.feishu.cn/docs/doccn1XcAYOjDLG7PtY3DIh0q4d#" target="_blank" rel="noopener">https://hardcore.feishu.cn/docs/doccn1XcAYOjDLG7PtY3DIh0q4d#</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Paper </tag>
            
            <tag> Distributed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解CPP之auto,decltype,move,forward</title>
      <link href="/2022/10/22/shen-ru-li-jie-cpp-zhi-auto-decltype-move-forward/"/>
      <url>/2022/10/22/shen-ru-li-jie-cpp-zhi-auto-decltype-move-forward/</url>
      
        <content type="html"><![CDATA[<h1 id="left-value"><a href="#left-value" class="headerlink" title="left value"></a>left value</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>其实<code>left value</code>并没有很好的定义去说明，一种被普遍认同的观点便是<strong>在内存的表达式，能够用内置&amp;进行取地址</strong>的值</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//错误的观点1：等号右边的是右值，左边的是左值</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//a是左值，3是右值</span><span class="token keyword">int</span> b<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//b是左值</span>b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//a在等号右边，但a是左值,可以取地址</span><span class="token comment" spellcheck="true">//错误的观点2：不能取地址的（放寄存器中值）是右值</span><span class="token comment" spellcheck="true">// 字符串字面量没有名字，是左值，</span><span class="token comment" spellcheck="true">// 我们可以这样直接原始取地址</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h2><p>能够指向左值，不能指向右值的就是左值引用</p><ul><li><p>例外：const左值引用可以指向右值（涉及到const的底层实现，它新建了一个值给其引用）</p></li><li><p>const左值引用不会修改指向值，因为可以指向右值</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> arrs<span class="token punctuation">;</span>arrs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//因为push_back传入的参数是就是const value_type&amp; val</span><span class="token comment" spellcheck="true">//push_back的原型(加上const后既可以接受左值，也可以接受右值，方便使用)</span><span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//void push_back(value_type&amp; val); // 这种做法的缺点，只能接收左值，不能接收右值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>可以理解为<code>c++</code>的<strong>语法糖</strong>，更加方便的使用指针</p><br><h2 id="左值（举例）"><a href="#左值（举例）" class="headerlink" title="左值（举例）"></a>左值（举例）</h2><p>函数名和变量名</p><p>返回左值引用的函数调用</p><p>内置的前++与前–，如：<code>++a</code></p><p><strong>变量类型是右值引用的表达式</strong>，如：<code>TestClassA&amp;&amp; ra = TestClassA(1000);</code>，ra这里是左值内置*解引用的表达式，如：<code>*pkValue</code></p><p><strong>字符串字面值”abcd”</strong></p><br><br><br><h1 id="right-value"><a href="#right-value" class="headerlink" title="right value"></a>right value</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>不能取地址的没有名字的，临时的，位于等号右边的</p><p>更多的是一种值的表达</p><br><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>右值引用可以指向右值，不可以指向左值（如需指向左值，要用move）</p><ul><li>本质上是将一个右值提升为左值（延长右值的生命周期）</li></ul><p>右值引用既可以是<strong>左值</strong>（<code>int a = std::move(1);</code>，其中的<code>a</code>是左值），也可以是<strong>右值</strong>（<code>std::move(1)</code>，没有名字，便是右值）</p><p>作为函数形参时，右值引用更灵活。虽然const左值引用也可以做到左右值都接受，但它无法修改，有一定局限性</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 形参是个右值引用</span><span class="token keyword">void</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> right_value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    right_value <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a是个左值</span>    <span class="token keyword">int</span> <span class="token operator">&amp;</span>ref_a_left <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ref_a_left是个左值引用</span>    <span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>ref_a_right <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ref_a_right是个右值引用</span>     <span class="token function">change</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 编译不过，a是左值，change参数要求右值</span>    <span class="token function">change</span><span class="token punctuation">(</span>ref_a_left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 编译不过，左值引用ref_a_left本身也是个左值</span>    <span class="token function">change</span><span class="token punctuation">(</span>ref_a_right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 编译不过，右值引用ref_a_right本身也是个左值</span>         <span class="token function">change</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 编译通过</span>    <span class="token function">change</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>ref_a_right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 编译通过</span>    <span class="token function">change</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>ref_a_left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 编译通过</span>     <span class="token function">change</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当然可以直接接右值，编译通过</span>         cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>ref_a_left <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>ref_a_right<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 打印这三个左值的地址，都是一样的</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="纯右值"><a href="#纯右值" class="headerlink" title="纯右值"></a>纯右值</h2><p>运算表达式产生的临时变量、不和对象关联的原始字面量、非引用返回的临时变量、lambda表达式等都是纯右值</p><p>一般有：</p><ul><li>除字符串字面值外的字面值</li><li>返回非引用类型的函数调用</li><li>后置自增自减表达式i++，i–</li><li>算术表达式（a+b，a*b，a&amp;&amp;b，a&#x3D;&#x3D;b等）</li><li>取地址表达式等（&amp;a）</li></ul><br><h2 id="将亡值"><a href="#将亡值" class="headerlink" title="将亡值"></a>将亡值</h2><p>通常指将要被移动的对象、T&amp;&amp;函数的返回值、std::move函数的返回值、转换为T&amp;&amp;类型转换函数的返回值</p><p>可以理解为<strong>即将要销毁的值</strong>（说是将要，是因为后续有人会将其接收），通过“盗取”其它变量内存空间方式获取的值</p><p>在确保其它变量不再被使用或者即将被销毁时，可以避免内存空间的释放和分配，延长变量值的生命周期</p><p>常用来完成<strong>移动构造</strong>或者<strong>移动赋值</strong>的特殊任务</p><br><h2 id="右值（举例）"><a href="#右值（举例）" class="headerlink" title="右值（举例）"></a>右值（举例）</h2><p>非字符串的字面量以及枚举项，如：<code>nullptr</code>，<code>true</code></p><p>后置自增（减）是纯右值，如：<code>a--</code></p><p>内置的算术，逻辑，比较表达式，如：<code>a+b</code>，<code>a&amp;b</code>，<code>a||b</code>, <code>a&lt;b</code></p><p>内置取地址表达式，this指针，如:<code>&amp;a</code></p><p>lamda表达式，如：<code>[](int a){ return 2*a; }</code></p><p>转型为非引用的表达式，如：<code>static_cast&lt;double&gt;(fValue)</code>，<code>(float)42</code></p><p>转型为右值引用的表达式，如：<code>static_cast&lt;double&amp;&amp;&gt;(fValue)</code>，<code>std::move(x)</code></p><p>左值转右值引用</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//可以将左值转为右值，再进行右引用</span>TestClassA <span class="token function">kTA2</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用std::move转为右值引用</span>TestClassA<span class="token operator">&amp;&amp;</span> c3 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>kTA2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用static_cast转为右值引用</span>TestClassA<span class="token operator">&amp;&amp;</span> c4 <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>TestClassA<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>kTA2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用C风格强转为右值引用</span>TestClassA<span class="token operator">&amp;&amp;</span> c5 <span class="token operator">=</span> <span class="token punctuation">(</span>TestClassA<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span>kTA2<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用std::forwad&lt;T&amp;&amp;>为右值引用</span>TestClassA<span class="token operator">&amp;&amp;</span> c6 <span class="token operator">=</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>TestClassA<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>kTA2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><br><br><h1 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h1><p>程序编译的时候进行推导</p><br><h2 id="推导规则"><a href="#推导规则" class="headerlink" title="推导规则"></a>推导规则</h2><p>1、指针或引用（指左值引用）</p><ul><li>凡是以引用或指针来接收参数的，都直接忽略原来是否是引用</li><li>而像const和指针的，原封不动的匹配进去</li></ul><p>2、万能引用</p><ul><li>如果传入的是左值，那T和paramtype直接变为左值引用（传进来的就是T的类型和const）</li><li>如果传入的是右值，就根据类型推导出T的类型，paramType就是T&amp;&amp;</li></ul><p>3、既非指针也非引用</p><ul><li>直接忽略其引用部分，const部分和volatile对象</li><li>传进来的都当做是值传递，无论原来是不是const，都回归原来的类型</li><li>例外：如果是const修饰的引用或指针，const会因此保留(const仅会在按值形参处被忽略）</li></ul><p>4、<code>std::initializer</code></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//第三种情况，推导为int</span><span class="token keyword">const</span> <span class="token keyword">auto</span> cx <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//第三种情况，推导为const int</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//第一种情况，推导为const int&amp;</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> uref1 <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//第二种情况，传入的左值都变为左值引用，即int&amp;，左值引用</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> uref2 <span class="token operator">=</span> cx<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//第二种情况，左值，const int&amp;，左值引用</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> uref3 <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//第二种情况，右值，就直接推导，即int&amp;&amp;，右值引用</span><span class="token keyword">const</span> <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">":::"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// const char[]</span><span class="token keyword">auto</span> arr1 <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//const char*</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> arr2 <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//const char(&amp;)[]</span><span class="token keyword">auto</span> func1 <span class="token operator">=</span> someFunc<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// void(*)(int, double)</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> func2 <span class="token operator">=</span> someFunc<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// void(&amp;)(int, double)</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> range<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//原容器中数据的拷贝</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> x <span class="token operator">:</span> range<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//原容器中数据的引用</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> x<span class="token operator">:</span> range<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 对原容器中的数据，只读</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> x <span class="token operator">:</span> range<span class="token punctuation">)</span>    <span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> result <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// auto&amp;&amp; 意味着后边要转发</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>auto</code> ：拷贝</li><li><code>auto&amp;</code> ：左值引用，只能接左值和常量右值）</li><li><code>auto&amp;&amp;</code> ：万能引用，能接左值和右值</li><li><code>const auto&amp;</code> ：左值引用，能接左值和右值；只读</li><li><code>const auto&amp;&amp;</code> ：常量右值引用，只能接右值；<strong>基本没用</strong>，基本可被 <code>const auto&amp;</code> 替代（比 <code>const auto&amp;</code> 多一个语义：一定得是右值。然而这没什么用，因为你都不对其进行修改，是左还是右没什么影响）</li></ul><br><br><br><h1 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h1><p>在cpp11中，decltype的主要用途大概就在于声明那些返回值型别依赖于形参型别的函数模板</p><p>即decltype可以推导出括号里面的对象的类型，并用于其他的对象</p><br><br><br><h1 id="forward"><a href="#forward" class="headerlink" title="forward"></a>forward</h1><p><strong>作用：会将传入的值，按照T原本的类型返回</strong></p><p>原理：利用<strong>引用折叠</strong>的特性</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// T为模板类型，param为参数</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有一个疑惑：为什么用的时候只要把T放进去就行了？</p><p>猜测：用户传入的信息推导后的类型会存入T中，但是我们用的都是解析后的T（即param）</p><p>导致我们直接使用param的时候，param都是左值，从而无法确定到底是左值引用还是右值引用（所以需要forward）</p><br><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/// remove_reference</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">></span><span class="token keyword">struct</span> remove_reference<span class="token punctuation">{</span> <span class="token keyword">typedef</span> _Tp   type<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">></span><span class="token keyword">struct</span> remove_reference<span class="token operator">&lt;</span>_Tp<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">{</span> <span class="token keyword">typedef</span> _Tp   type<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">></span><span class="token keyword">struct</span> remove_reference <span class="token operator">&lt;</span> _Tp<span class="token operator">&amp;&amp;</span> <span class="token operator">></span><span class="token punctuation">{</span> <span class="token keyword">typedef</span> _Tp   type<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 处理左值作为左引用或者右引用</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">></span><span class="token keyword">constexpr</span> _Tp<span class="token operator">&amp;&amp;</span><span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">typename</span> std<span class="token operator">::</span>remove_reference<span class="token operator">&lt;</span>_Tp<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">&amp;</span> __t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Tp<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>__t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 处理右值作为右引用</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">></span><span class="token keyword">constexpr</span> _Tp<span class="token operator">&amp;&amp;</span><span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">typename</span> std<span class="token operator">::</span>remove_reference<span class="token operator">&lt;</span>_Tp<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">&amp;&amp;</span> __t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span>    <span class="token keyword">static_assert</span><span class="token punctuation">(</span><span class="token operator">!</span>std<span class="token operator">::</span>is_lvalue_reference<span class="token operator">&lt;</span>_Tp<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span> <span class="token string">"template argument"</span>        <span class="token string">" substituting _Tp is an lvalue reference type"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Tp<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>__t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><br><br><h1 id="move"><a href="#move" class="headerlink" title="move"></a>move</h1><p>作用：<strong>将对象通过static_cast强转为右值</strong>（语义：不再需要当前变量）</p><br><p>为什么说<code>move</code>能够提高性能？</p><ul><li><code>move</code>将对象强转为右值，接着赋值的时候会触发移动构造函数，而移动构造函数的语义就是原有的对象是不需要的，从而实现浅拷贝，提高性能</li><li>换言之，能不能提高性能完全取决于是否有高效的移动构造函数（像int，double类型就不行了）</li></ul><br><p>move是不会改变原有数据的const属性（static_cast不会修改const属性）</p><br><p>比如</p><ul><li><code>bb</code> 的类型是 <code>Foo&amp;</code>，<code>move</code> 之后变为 <code>Foo&amp;&amp;</code>，会调用移动赋值函数</li><li><code>cc</code> 的类型是 <code>const Foo</code>，<code>move</code> 之后变为 <code>const Foo&amp;&amp;</code>，会调用拷贝赋值函数</li><li><code>bb</code> 的类型是 <code>const Foo&amp;</code>，<code>move</code> 之后变为 <code>const Foo&amp;&amp;</code>，会调用拷贝赋值函数</li></ul><br><p>只能说在某个特定的实现中，移动后的对象会变为空，但是c++标准没有规定被移动后的对象为空，所以使用标准库的程序不应当依赖有这些行为的代码</p><p>比如说int的move，原来的对象还是没有改变值；而string经过move之后就会变为nullptr，unique_ptr经过move之后变为nullptr</p><br><h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// clang中的实现</span><span class="token comment" spellcheck="true">/**  *  @brief  Convert a value to an rvalue.  *  @param  __t  A thing of arbitrary type.  *  @return The parameter cast to an rvalue-reference to allow moving it.*/</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">></span>_GLIBCXX_NODISCARD<span class="token keyword">constexpr</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>remove_reference<span class="token operator">&lt;</span>_Tp<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">&amp;&amp;</span> <span class="token function">move</span><span class="token punctuation">(</span>_Tp<span class="token operator">&amp;&amp;</span> __t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> std<span class="token operator">::</span>remove_reference<span class="token operator">&lt;</span>_Tp<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>__t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// STRUCT TEMPLATE remove_reference</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Ty</span><span class="token operator">></span><span class="token keyword">struct</span> remove_reference <span class="token punctuation">{</span>    <span class="token keyword">using</span> type                 <span class="token operator">=</span> _Ty<span class="token punctuation">;</span>    <span class="token keyword">using</span> _Const_thru_ref_type <span class="token operator">=</span> <span class="token keyword">const</span> _Ty<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Ty</span><span class="token operator">></span><span class="token keyword">struct</span> remove_reference<span class="token operator">&lt;</span>_Ty<span class="token operator">&amp;</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> type                 <span class="token operator">=</span> _Ty<span class="token punctuation">;</span>    <span class="token keyword">using</span> _Const_thru_ref_type <span class="token operator">=</span> <span class="token keyword">const</span> _Ty<span class="token operator">&amp;</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Ty</span><span class="token operator">></span><span class="token keyword">struct</span> remove_reference<span class="token operator">&lt;</span>_Ty<span class="token operator">&amp;&amp;</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> type                 <span class="token operator">=</span> _Ty<span class="token punctuation">;</span>    <span class="token keyword">using</span> _Const_thru_ref_type <span class="token operator">=</span> <span class="token keyword">const</span> _Ty<span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><br><br><h1 id="application"><a href="#application" class="headerlink" title="application"></a>application</h1><h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><p>场景</p><p>经常会对一个类对象进行拷贝，而如果原有的类对象不再需要了，那么是不是可以把被拷贝者的数据移动，从而避免深拷贝</p><p>即：有了移动语义，更加容易实现浅拷贝</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Array</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Array</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">size_</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>size_<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">// 深拷贝构造</span>    <span class="token function">Array</span><span class="token punctuation">(</span><span class="token keyword">const</span> Array<span class="token operator">&amp;</span> temp_array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">// 深拷贝赋值</span>    Array<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Array<span class="token operator">&amp;</span> temp_array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// 优雅的实现浅拷贝，从而避免深拷贝</span>    <span class="token function">Array</span><span class="token punctuation">(</span>Array<span class="token operator">&amp;&amp;</span> temp_array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        data_ <span class="token operator">=</span> temp_array<span class="token punctuation">.</span>data_<span class="token punctuation">;</span>        size_ <span class="token operator">=</span> temp_array<span class="token punctuation">.</span>size_<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 为防止temp_array析构时delete data，提前置空其data_      </span>        temp_array<span class="token punctuation">.</span>data_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> data_<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token operator">*</span>data_<span class="token punctuation">;</span>    <span class="token keyword">int</span> size_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 例1：Array用法</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Array a<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 做一些操作</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token comment" spellcheck="true">// 左值a，用std::move转化为右值</span>    Array <span class="token function">b</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="万能引用（引用折叠）"><a href="#万能引用（引用折叠）" class="headerlink" title="万能引用（引用折叠）"></a>万能引用（引用折叠）</h2><p><strong>如果任一引用为左值引用，则结果为左值引用。否则（即两个都是右值引用），结果为右值引用</strong></p><ul><li>T&amp; &amp; 折叠成 T&amp;</li><li>T&amp; &amp;&amp; 折叠成 T&amp;</li><li>T&amp;&amp; &amp; 折叠成 T&amp;</li><li>T&amp;&amp; &amp;&amp; 折叠成 T&amp;&amp;</li></ul><p><strong>所有引用折叠，最后都代表一个引用：左值引用或右值引用</strong></p><br><p>规则：</p><p>万能限定必须是函数模板，可以模板参数是单个，也可以是多个模板参数，形式为<strong>T&amp;&amp;</strong></p><p>万能引用可以接受左值，也可以接受右值</p><p>万能引用的T不能被再修饰，否则转为普通右值引用，不能被cv修饰限定</p><p><strong>只存在于模板推导和完美转发中</strong>（比如<code>auto&amp;&amp;</code>以及模板函数中的<code>T&amp;&amp;</code>）</p><br><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//引用折叠的写法</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//x是左值，T的类型是int&amp;，param折叠为int&amp;</span><span class="token keyword">const</span> <span class="token keyword">int</span> cx <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//cx是左值，T的类型是const int&amp;，param是const int&amp;</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//rx是左值引用，T的类型是const int&amp;，param是const int&amp;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//27是右值，T的类型是int，param折叠为int&amp;&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><p>一个具体的应用场景:</p><p>需要一个函数能够同时接收左值和右值，并根据不同的类型转发给不同版本的函数</p><p>而如果直接用万能引用+左右值函数重载，使用的param都是左值，从而无法判断是左值引用还是右值引用</p><ul><li>param可以被初始化为左值引用或者右值引用，但如果在函数内部要将param传给其它函数，此时的param会被当做左值</li></ul><br><p>解决办法：</p><p>模板中的 T 保存着传递进来的实参的信息，我们可以利用 T 的信息来强制类型转换我们的 param 使它和实参的类型一致</p><p>所以可以使用万能引用 + forward，即利用T的信息实现转发</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 接收左值的函数 f()</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f(T &amp;)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 接收右值的函数f()</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f(T &amp;&amp;)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 万能引用，转发接收到的参数 param</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">PrintType</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// f(param);  // 修改前的版本：只会调用void f(T&amp; t)</span>    <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 修改后的版本：可以正确区分</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">PrintType</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//传入左值</span>    <span class="token function">PrintType</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//传入右值，结果是最后用到的还是左值的版本</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><br><br><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/50816420" target="_blank" rel="noopener">引用折叠和完美转发</a></li><li><a href="https://zhuanlan.zhihu.com/p/335994370" target="_blank" rel="noopener">一文读懂C++右值引用和std::move</a></li><li><a href="https://zhuanlan.zhihu.com/p/137662465" target="_blank" rel="noopener">左值引用、右值引用、移动语义、完美转发，你知道的不知道的都在这里</a></li><li><a href="https://zhuanlan.zhihu.com/p/402251966" target="_blank" rel="noopener">谈谈C++的左值右值，左右引用，移动语意及完美转发</a></li><li><a href="https://mp.weixin.qq.com/s/_9-0iNUw6KHTF3a-vSMCmg" target="_blank" rel="noopener">【Modern C++】深入理解左值、右值</a></li><li><a href="https://www.jianshu.com/p/4538483a1d8a" target="_blank" rel="noopener">C++11 中的左值、右值和将亡值</a></li><li><a href="https://cloud.tencent.com/developer/article/1561681" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1561681</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL源码剖析之map</title>
      <link href="/2022/10/22/stl-yuan-ma-pou-xi-zhi-map/"/>
      <url>/2022/10/22/stl-yuan-ma-pou-xi-zhi-map/</url>
      
        <content type="html"><![CDATA[<h1 id="STL中的红黑树"><a href="#STL中的红黑树" class="headerlink" title="STL中的红黑树"></a>STL中的红黑树</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p><code>RB-tree</code>不仅是一个二叉搜索树，而且必须满足以下规则：</p><p>1、每个节点不是红色就是黑色</p><p>2、根节点是黑色</p><p>3、如果节点为红，其子节点必须为黑</p><p>4、任一节点到NULL（树尾端）的任何路径，所含的黑色节点数必须相同</p><p><img src="/medias/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bmap/RB-tree.png"></p><br><h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><p>to do part</p><br><h2 id="RB-tree的节点设计"><a href="#RB-tree的节点设计" class="headerlink" title="RB-tree的节点设计"></a>RB-tree的节点设计</h2><p><code>_rb_tree_node_base</code>存放<code>color</code>，<code>parent</code>，<code>left</code>，<code>right</code>等数据，同时实现了<code>minimum</code>和<code>maxinum</code>函数</p><p><code>_rb_tree_node</code>继承了<code>_rb_tree_node_base</code>，同时存放<code>value_field</code>节点值</p><p><img src="/medias/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bmap/RB-tree%E7%9A%84%E8%8A%82%E7%82%B9%E8%AE%BE%E8%AE%A1.png"></p><br><h2 id="RB-tree的迭代器设计"><a href="#RB-tree的迭代器设计" class="headerlink" title="RB-tree的迭代器设计"></a>RB-tree的迭代器设计</h2><p><code>_rb_tree_base_itreator</code>存放<code>_rb_tree_node</code>，同时实现了<code>increment</code>和<code>decrement</code>函数</p><p><code>_rb_tree_itreator</code>继承了<code>_rb_tree_base_itreator</code>，同时重载了<code>*，-&gt;，++，--</code>等运算符</p><p><img src="/medias/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bmap/RB-tree%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BE%E8%AE%A1.png"></p><p><code>RB-tree</code>的迭代器属于双向迭代器，但不具备随机定位能力</p><br><h2 id="RB-tree的数据结构"><a href="#RB-tree的数据结构" class="headerlink" title="RB-tree的数据结构"></a>RB-tree的数据结构</h2><p><img src="/medias/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bmap/RB-tree%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p><br><h2 id="RB-tree的元素操作"><a href="#RB-tree的元素操作" class="headerlink" title="RB-tree的元素操作"></a>RB-tree的元素操作</h2><br><br><br><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><code>map</code>的特性是，所有元素都会根据元素的键值自动被排序，<code>map</code>的所有元素都是<code>pair</code>，同时拥有实值（<code>value</code>）和键值（<code>key</code>）</p><p><code>pair</code>的第一个元素被视为键值，第二元素被视为实值</p><p><img src="/medias/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bmap/map%E4%B8%ADpair%E7%9A%84%E8%AE%BE%E8%AE%A1.png"></p><p><code>map</code>不允许两个元素拥有相同的键值</p><p>底层是<code>RB-tree</code>实现的，所以插入删除查找都是$O(logn)$</p><br><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>对map中的元素进行操作时，之前原有元素的迭代器不会因此失效</p><p>map的iterators只能修改pair的实值，不能修改其键值</p><ul><li>因此map iterators既不是一种constant iterators，也不是一种mutable iterators</li></ul><br><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><img src="/medias/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bmap/map%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p><br><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> maps<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//插入若干元素</span>    maps<span class="token punctuation">[</span><span class="token string">"jack"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    maps<span class="token punctuation">[</span><span class="token string">"jane"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    maps<span class="token punctuation">[</span><span class="token string">"july"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//以pair形式插入</span>    pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token string">"david"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    maps<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//迭代输出元素</span>    map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator iter <span class="token operator">=</span> maps<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> maps<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>iter<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> iter<span class="token operator">-</span><span class="token operator">></span>first <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> iter<span class="token operator">-</span><span class="token operator">></span>second <span class="token operator">&lt;&lt;</span> <span class="token string">"--"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// david 4--jack 1--jane 2--july 3--</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//使用subscipt操作取实值</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> maps<span class="token punctuation">[</span><span class="token string">"july"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3</span>    <span class="token comment" spellcheck="true">//查找某key</span>    iter <span class="token operator">=</span> maps<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"jane"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>iter <span class="token operator">!=</span> maps<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> iter<span class="token operator">-</span><span class="token operator">></span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span>    <span class="token comment" spellcheck="true">//修改实值</span>    iter<span class="token operator">-</span><span class="token operator">></span>second <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> num2 <span class="token operator">=</span> maps<span class="token punctuation">[</span><span class="token string">"jane"</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 100</span>    cout <span class="token operator">&lt;&lt;</span> num2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 几种插入数据的方式</span>    std<span class="token operator">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token operator">></span> mapStudent<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1) 用insert函数插入pair数据</span>    mapStudent<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"student_one"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2) 用insert函数插入value_type数据</span>    mapStudent<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token operator">::</span><span class="token function">value_type</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"student_one"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3) 在insert函数中使用make_pair()函数</span>    mapStudent<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"student_one"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 4) 用数组方式插入数据</span>    mapStudent<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"student_one"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//删除元素</span>    map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> map1<span class="token punctuation">;</span>    <span class="token keyword">auto</span> i <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">eraset</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//自定义类型放入map中</span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> a1<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> a1<span class="token punctuation">.</span>i <span class="token operator">&lt;</span> <span class="token keyword">this</span> <span class="token operator">-</span><span class="token operator">></span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    map<span class="token operator">&lt;</span>A<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> map2<span class="token punctuation">;</span>     A a1<span class="token punctuation">,</span> a2<span class="token punctuation">;</span>    map2<span class="token punctuation">[</span>a1<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="at、-和find的区别"><a href="#at、-和find的区别" class="headerlink" title="at、[]和find的区别"></a>at、[]和find的区别</h2><p>[]</p><ul><li>将关键码作为下标去执行查找，并返回对应的值</li><li>如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项插入这个map</li><li>所以不能通过[]判断元素是否在容器中</li></ul><p>find函数</p><ul><li>用关键码执行查找，找到了返回该位置的迭代器</li><li>如果不存在这个关键码，就返回尾迭代器</li><li>速度快，map的find是二分查找的版本</li></ul><p>at</p><ul><li>将关键码作为下标去执行查找，并返回对应的值</li><li>如果不存在就会报错</li></ul><br><br><br><h1 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h1><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>unordered_map中的bucket所维护的list是其自己定义的由hashtable_node数据结构组成的linked-list</p><p>bucket聚合体本身使用vector进行存储（<strong>所以说本质是数组</strong>）</p><p>hashtable的迭代器只提供前进操作，不提供后退操作</p><p>在hashtable设计bucket的数量上，其内置了28个质数[53, 97, 193,…,429496729]，在创建hashtable时，会根据存入的元素个数选择大于等于元素个数的质数作为hashtable的容量（vector的长度），其中每个bucket 所维护的linked-list长度也等于hashtable的容量。如果插入hashtable的元素个数超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的buckets vector，重新计算元素在新hashtable的位置</p><p>什么时候扩容：当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值—即当 前数组的长度乘以加载因子的值的时候，就要自动扩容啦</p><p><img src="/medias/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bmap/%E6%8B%89%E9%93%BE%E6%B3%95%E5%AE%9E%E7%8E%B0hashtable.png"></p><p>unordered_map是基于<strong>hash_table</strong>实现，一般是由一个大vector，vector元素节点可挂接链表来解决冲突来实现。hash_table最大的优点，就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间；而代价仅仅是消耗比较多的内存。然而在当前可利用内存越来越多的情况下，用空间换时间的做法是值得的</p><p>hash_table节点的定义</p><ul><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Vaule</span><span class="token operator">></span><span class="token keyword">struct</span> __hashtable_node <span class="token punctuation">{</span>    __hashtable_node<span class="token operator">*</span> next<span class="token punctuation">;</span>    Value val<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><br><h2 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h2><p><img src="/medias/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bmap/hashtable%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8.png"></p><p>hashtable的迭代器没有后退操作，hashtable也没有定义所谓的逆向迭代器</p><br><h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><p><img src="/medias/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bmap/hashtable%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p><p><img src="/medias/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bmap/hashtable%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0.png"></p><br><h2 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//自定义类型放入unordered_map中</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> my_key <span class="token punctuation">{</span>    <span class="token keyword">int</span>    num<span class="token punctuation">;</span>    string name<span class="token punctuation">;</span>    <span class="token function">my_key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">my_key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">my_key</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> string b<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">num</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">name</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> my_key <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>num <span class="token operator">==</span> t<span class="token punctuation">.</span>num<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> myHashFuc <span class="token punctuation">{</span>    std<span class="token operator">::</span>size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> my_key <span class="token operator">&amp;</span>key<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> std<span class="token operator">::</span>hash<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    unordered_map <span class="token operator">&lt;</span>my_key<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token punctuation">,</span> myHashFuc<span class="token operator">></span> mmp<span class="token punctuation">;</span>    my_key <span class="token function">myuin</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"bob"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mmp<span class="token punctuation">[</span>myuin<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>     cout <span class="token operator">&lt;&lt;</span> mmp<span class="token punctuation">[</span>myuin<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于unordered_map是采用哈希实现的，对于系统的类型int, string等，都已经定义好了hash函数，所以如果我们引入新的自定义类型的话，系统并不知道如何去计算我们引入的自定义类型的hash值，所以我们就需要自己定义hash函数，告诉系统用这种方式去计算我们引入的自定义类型的hash值</p><p>除了自定义哈希函数外，系统计算了hash值后，还需要判断是否冲突，对于默认的类型，系统都知道怎样去判断是否相等，但不知道怎样去判断我们引入的自定义类型是否相等，所以需要我们重载&#x3D;&#x3D;号，告诉系统用这种方式去判断2个键是否相等</p><br><h2 id="为什么bucket的数量都是质数"><a href="#为什么bucket的数量都是质数" class="headerlink" title="为什么bucket的数量都是质数"></a>为什么bucket的数量都是质数</h2><p>因为我们在hashtable的定义中，hash函数使用的是标准的求模函数，因此这样定义桶数有利于元素各个桶之间的均匀分布</p><p>如果说是合数，那么只要是和桶的数量有相同公约数的，比如说桶数为4，数字8，12，16都一定会被放到同一个桶0里面，就会造成hash冲突</p><p>那么这时候hashtable的性能将取决于到底有多少元素能够和桶数有公约数，这对hashtable尽量使各个桶之间的元素数近似相等的原则违背</p><p>因此如果对于合数，放入的元素有一定的规律性，就会很容易造成极端情况的出现</p><p>另外，hashtable相比于RB-tree的一个优势就在于RB-tree虽然平均查找时间是对数时间，但是这是在假设数据均匀分布的基础之上的，而hashtable也有平均对数时间上的性能，且这种表现是以统计为基础，不需依赖元素输入的随机性。</p><br><br><br><h1 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h1><img src="/medias/STL源码剖析之map/multimap.png" style="zoom:150%;"><br><br><br><h1 id="map和unordered-map的对比"><a href="#map和unordered-map的对比" class="headerlink" title="map和unordered_map的对比"></a>map和unordered_map的对比</h1><h2 id="map-1"><a href="#map-1" class="headerlink" title="map"></a>map</h2><ul><li><p>底层实现是红黑树，所以可以支持键值的自动排序，所以在查询和维护的时间和空间复杂度上都为$O(logn)$</p><ul><li>内部元素有序</li></ul></li><li><p>但是空间占用比较大，因为每个节点要保持父节点、孩子节点及颜色的信息</p></li><li><p>相比哈希表，没有了rehash的过程</p></li></ul><br><h2 id="unordered-map-1"><a href="#unordered-map-1" class="headerlink" title="unordered_map"></a>unordered_map</h2><ul><li>底层机制是哈希表，通过hash函数计算元素位置，查询时间复杂度为O(1)<ul><li>内部元素无序</li></ul></li><li>维护时间与bucket桶所维护的list长度有关</li><li>但是建立hash表耗时较大，同时rehash耗时较大</li></ul><br><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>map适用于有序数据的应用场景，unordered_map适用于高效查询的应用场景</li><li>map 底层数据结构为红黑树，有序，不重复</li><li>multimap 底层数据结构为红黑树，有序，可重复</li><li>unordered_map 底层数据结构为hash表，无序，不重复</li><li>unordered_multimap 底层数据结构为hash表，无序，可重复</li></ul><br><br><br><h1 id="to-do-list"><a href="#to-do-list" class="headerlink" title="to do list"></a>to do list</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzkyMjIxMzIxNA==&amp;mid=2247483656&amp;idx=1&amp;sn=a204fedfbf2cf7f2023979c56b756c8a&amp;scene=19#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzkyMjIxMzIxNA==&amp;mid=2247483656&amp;idx=1&amp;sn=a204fedfbf2cf7f2023979c56b756c8a&amp;scene=19#wechat_redirect</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzkyMjIxMzIxNA==&amp;mid=2247483848&amp;idx=1&amp;sn=d459a04730a4e56653452eae9f71d424&amp;scene=19#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzkyMjIxMzIxNA==&amp;mid=2247483848&amp;idx=1&amp;sn=d459a04730a4e56653452eae9f71d424&amp;scene=19#wechat_redirect</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL源码剖析之deque</title>
      <link href="/2022/10/21/stl-yuan-ma-pou-xi-zhi-deque/"/>
      <url>/2022/10/21/stl-yuan-ma-pou-xi-zhi-deque/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>是一种<strong>双向开口的连续线性空间，可以在头尾两端分别做元素的插入和删除</strong></p><ul><li>允许O（1）时间内对头端进行元素的插入或移除操作</li></ul><p>没有容量的概念，因为它是以动态的分段连续空间合成，随时可以增加一段新的空间并连接起来</p><ul><li><p>一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端</p></li><li><p>因此非必要不使用deque，如果要对deque进行排序，就要先把deque复制到vector上，将vector排序，再复制会deque</p></li></ul><p>deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的借口，</p><p>避开了“重新配置、复制、释放”的轮回，代价则是复杂的迭代器架构</p><br><br><br><h1 id="deque实现"><a href="#deque实现" class="headerlink" title="deque实现"></a>deque实现</h1><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p><strong>在64位机器、g++10.3下，deque::iterator的大小为32</strong></p><p><img src="/medias/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bdeque/deque%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><p>deque的迭代器总共有四个指针：</p><ul><li><p><code>cur</code>（指向当前元素在buffer中的位置）</p></li><li><p><code>first</code>（指向当前buffer的头部）</p></li><li><p><code>last</code>（指向当前buffer的尾部）</p></li><li><p><code>node</code>（指向当前的缓冲区对应的迭代器在中控器上的位置）</p></li></ul><p><img src="/medias/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bdeque/deque%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%BA%90%E7%A0%81.png"></p><br><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p><strong>在64位机器、g++10.3下，deque的大小为80</strong></p><p>deque采用一块所谓的map（不是map容器）作为<strong>主控</strong></p><p>这里所谓map是一小块连续空间，其中每个元素（称为节点node）都是指针，指向另一段（较大的）连续线性空间，称为<strong>缓冲区</strong></p><p>缓冲区才是deque的储存空间主体，SGI STL 允许我们指定缓冲区大小，默认值0表示将使用512bytes缓冲区</p><p><img src="/medias/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bdeque/deque%E4%B8%AD%E4%B8%AD%E6%8E%A7%E5%99%A8%E3%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E7%9B%B8%E4%BA%92%E5%85%B3%E7%B3%BB.png"></p><p>deque主要由四个部分组成：</p><ul><li><p><code>start</code>（头iterator，指向deque的第一个元素）32字节</p></li><li><p><code>finish</code>（尾iterator，指向deque最后一个元素的下一个节点）32字节</p></li><li><p><code>pointer</code>（map_pointer；map是一块连续的内存空间，上面存放的是指向buffer的指针；所以map_pointer是指向该数组的一个指针；也就是<code>T**</code>类型）8字节</p></li><li><p><code>map_size</code>（size_type，map中继器的大小，表示map内有多少个指针）8字节</p></li></ul><br><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><img src="/medias/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bdeque/deque%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p><br><br><br><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><h2 id="deque的构造"><a href="#deque的构造" class="headerlink" title="deque的构造"></a>deque的构造</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//构造函数的四种方式</span>deque<span class="token operator">&lt;</span>string<span class="token operator">></span> words1<span class="token punctuation">{</span><span class="token string">"the"</span><span class="token punctuation">,</span> <span class="token string">"is"</span><span class="token punctuation">,</span> <span class="token string">"deque"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>deque<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">words2</span><span class="token punctuation">(</span>words1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>deque<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">words3</span><span class="token punctuation">(</span>words1<span class="token punctuation">)</span><span class="token punctuation">;</span>deque<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">words4</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"YES"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="deque的迭代器"><a href="#deque的迭代器" class="headerlink" title="deque的迭代器"></a>deque的迭代器</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//iterator正向迭代器，+1是向右边走</span><span class="token keyword">for</span> <span class="token punctuation">(</span>deque<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">::</span>iterator it <span class="token operator">=</span> w<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> w<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span> it<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//reverse_iterator反向迭代器，+1向左走</span><span class="token keyword">for</span> <span class="token punctuation">(</span>deque<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">::</span>reverse_iterator it <span class="token operator">=</span> w<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> w<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span> it<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="deque的常用函数"><a href="#deque的常用函数" class="headerlink" title="deque的常用函数"></a>deque的常用函数</h2><pre class="line-numbers language-cpp"><code class="language-cpp">word4<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取第一个元素</span>word4<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回最后一个元素</span>word4<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回容器的大小</span>word4<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"NO"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//把元素放入末尾</span>word4<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//移除最后一个元素</span>word4<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span><span class="token string">"SS"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//把元素放到头部</span>word4<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//移除第一个元素</span>word4<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//判断是否为空</span><span class="token comment" spellcheck="true">//erast 移除元素</span>words4<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>words4<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//移除某个位置的元素</span>words1<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>words1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> words1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//移除某个区间的元素</span><span class="token comment" spellcheck="true">//max_size</span><span class="token comment" spellcheck="true">//shrink_to_fit</span><span class="token comment" spellcheck="true">//at</span><span class="token comment" spellcheck="true">//assign</span><span class="token comment" spellcheck="true">//emplace_back</span><span class="token comment" spellcheck="true">//emplace_front</span><span class="token comment" spellcheck="true">//swap</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><br><br><h1 id="API的使用"><a href="#API的使用" class="headerlink" title="API的使用"></a>API的使用</h1><h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//作用：将元素插入到指定的位置上</span>words<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> words4<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words4<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//第一个参数是位置，后面是要插入的容器的内容</span>words<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"strat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指定位置插入元素</span>words<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"IS"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//位置，重复次数，重复的数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于deque是可以两端进行扩充的，插入元素又会引入元素移动问题，进而带来拷贝构造的开销</p><p>所以在插入时首先进行判断插入位置距离首位哪边比较短，移动距离较短的一边，最大化的减少开销</p><p><img src="/medias/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bdeque/deque%E7%9A%84insert_01.png"></p><p><img src="/medias/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bdeque/deque%E7%9A%84insert_02.png"></p><br><br><br><h1 id="to-do-list"><a href="#to-do-list" class="headerlink" title="to do list"></a>to do list</h1><ul><li><a href="https://blog.csdn.net/CHYabc123456hh/article/details/121449313" target="_blank" rel="noopener">https://blog.csdn.net/CHYabc123456hh/article/details/121449313</a></li><li><a href="https://blog.csdn.net/qq_15041569/article/details/110943325" target="_blank" rel="noopener">https://blog.csdn.net/qq_15041569/article/details/110943325</a></li><li>侯捷的视频</li><li>《STL源码剖析》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> deque </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL源码剖析之vector</title>
      <link href="/2022/10/20/stl-yuan-ma-pou-xi-zhi-vector/"/>
      <url>/2022/10/20/stl-yuan-ma-pou-xi-zhi-vector/</url>
      
        <content type="html"><![CDATA[<h1 id="vector实现"><a href="#vector实现" class="headerlink" title="vector实现"></a>vector实现</h1><p><img src="/medias/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bvector/vector%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><p>vector中有<strong>三个指针</strong>：指向使用空间的头（<code>start</code>）和尾（<code>finish</code>），以及可用空间的尾（<code>end_of_storage</code>）</p><p>可用空间：为了降低空间配置的速度成本，vector实际配置的大小可能比客户端需求量大一些（即<code>capacity &gt;= size</code>）</p><p>默认的空间分配器是<code>alloc</code></p><br><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>vector的数据（三个迭代器）是存储在栈上的，迭代器指向的数组是存放在堆上的</p><p><img src="/medias/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bvector/vector%E7%9A%84%E5%AE%9A%E4%B9%89.png"></p><p>为什么不能把数据放到栈上</p><ul><li>栈上是不能动态扩容的，要实现动态扩容只能是堆</li><li>同时栈的空间宝贵且有限，不能无限存放元素</li></ul><p>为什么end要在最后一个元素再后面的一个位置</p><ul><li>当没有元素的时候，begin和end指向一起，方便判空</li></ul><br><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>vector的<strong>迭代器本质上就是一个指针，指向元素T</strong></p><ul><li>迭代器也可以用[]运算符进行访问：b[i]等价于<code>*(b + i)</code></li></ul><br><br><br><h1 id="vector扩容"><a href="#vector扩容" class="headerlink" title="vector扩容"></a>vector扩容</h1><h2 id="为什么是成倍扩容"><a href="#为什么是成倍扩容" class="headerlink" title="为什么是成倍扩容"></a>为什么是成倍扩容</h2><p>如果是等差扩容</p><p>假定每次扩容<code>m</code>个元素，总的元素个数是<code>n</code>，则需要扩容<code>n/m</code>次<br>$$<br>\sum^{n&#x2F;m}_{i &#x3D; 1}m*i&#x3D;\frac{ (n+m) * n } { 2 * m}\<br>$$</p><p>扩容的时间复杂度平均到每个元素上就是<code>O(n)</code></p><br><p>而如果是成倍扩容</p><p>假定有 <code>n</code> 个元素,倍增因子为 <code>m</code></p><p>那么完成这 <code>n</code> 个元素进行<code>push_back</code>操作，需要重新分配内存的次数大约为<code>logm(n)</code></p><p>第<code>i</code>次重新分配将会导致复制<code>m^i</code>（也就是当前的<code>vector</code>大小）个旧空间中元素</p><p>因此<code>n</code>次 <code>push_back</code>操作所花费的总时间约为 <code>n*m/(m - 1)</code><br>$$<br>\sum^{log_{m}{n}}_{i &#x3D; 1}m^i&#x3D;\frac{n*m}{m-1}\<br>$$</p><p>扩容的时间复杂度平均到每个元素上就是<code>O(1)</code>（发现m为2时，时间复杂度最小，所以一般是2倍扩容）</p><br><br><h2 id="为什么是2倍（gcc）或者1-5倍（msvc）扩容"><a href="#为什么是2倍（gcc）或者1-5倍（msvc）扩容" class="headerlink" title="为什么是2倍（gcc）或者1.5倍（msvc）扩容"></a>为什么是2倍（gcc）或者1.5倍（msvc）扩容</h2><p>理想的分配方案：是在第n次扩容时能复用之前n-1次释放的空间</p><ul><li>而当m&#x3D;2的时候每次扩容的大小都会大于前面释放掉的所有的空间</li><li>按照小于2倍方式扩容，多次扩容之后就可以复用之前释放的空间了</li><li>而超过2倍，就会导致空间的浪费，并且无法完美的使用到前面已经释放掉的内存</li></ul><p>总结</p><ul><li>使用2倍扩容时，每次扩容后的新内存大小必定大于前面的总和</li><li>使用1.5倍扩容时，在数次扩容后，就可以重用之前的内存空间</li></ul><br><br><br><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><h2 id="vector的构造"><a href="#vector的构造" class="headerlink" title="vector的构造"></a>vector的构造</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//vector的四种构造方式</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">i1</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"hi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span> i2<span class="token punctuation">{</span><span class="token string">"why"</span><span class="token punctuation">,</span> <span class="token string">"always"</span><span class="token punctuation">,</span> <span class="token string">"me"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">i3</span><span class="token punctuation">(</span>i2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i3<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>stirng<span class="token operator">></span> <span class="token function">i4</span><span class="token punctuation">(</span>i3<span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保证得到的元素都是0</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 二者等价</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> i5<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> i6 <span class="token operator">=</span> i5<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// operator= 赋值运算符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="vector的迭代器"><a href="#vector的迭代器" class="headerlink" title="vector的迭代器"></a>vector的迭代器</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// begin返回指向容器的第一个元素的迭代器，end返回指向容器尾端的迭代器</span><span class="token keyword">for</span> <span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>reverse_iterator it <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span> it<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// rbegin返回一个指向容器最后一个元素的反向迭代器，rend返回一个指向容器前端的反向迭代器（反向迭代器+1会往前面移动）</span><span class="token keyword">for</span> <span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>reverse_iterator it <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span> it<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="vector的常用函数"><a href="#vector的常用函数" class="headerlink" title="vector的常用函数"></a>vector的常用函数</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//容器第一个元素</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> i6<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//容器最后一个元素</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> i6<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//容器为空则返回true，否则为false</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> i6<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//容器中的元素个数</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> i6<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//容器可容纳的元素最大数量</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> i6<span class="token punctuation">.</span><span class="token function">max_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//容器的容量</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> i6<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><br><br><h1 id="API的使用"><a href="#API的使用" class="headerlink" title="API的使用"></a>API的使用</h1><h2 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h2><p>作用：将容器的size修改为size1</p><ul><li>如果size1比当前的size大，那么size就会变为size1（如果capacity比size1小，capacity也会变为size1；否则capacity不变）<ul><li>扩容多出的部分值为0</li></ul></li><li>如果size1比当前的size小，那么size就会变为size1（capacity不变）</li></ul><p>总结：capacity只会变大或不变，不会变小</p><p><br><br></p><h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><p>作用：返回数据数组的指针</p><pre class="line-numbers language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><br><br></p><h2 id="push-back"><a href="#push-back" class="headerlink" title="push_back"></a>push_back</h2><p>作用：将对象放到vector中</p><p>时间复杂度分析（参考扩容，时间复杂度为<code>O(n)</code>）</p><br><p>实现原理</p><p>首先检查是否有备用空间，如果有就直接在备用空间上构造元素，并调整迭代器finish</p><p><img src="/medias/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bvector/push_back.png" alt="push_back"></p><p>PS：<strong>为什么还要独立开一个insert_aux函数</strong>：因为可能其他的函数（insert）也会用到插入元素的功能，所以进行抽象封装</p><br><p>如果没有可用空间，就扩大原有的vector（重新配置、移动数据、释放原空间）</p><p><img src="/medias/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bvector/insert_aux.png" alt="insert_aux"></p><p>PS：<strong>一旦空间重新分配，指向原vector的所有的迭代器都会失效</strong></p><p>所以最好以数组下标作为记录，而不是迭代器作为记录</p><p><br><br></p><h2 id="emplace-back"><a href="#emplace-back" class="headerlink" title="emplace_back"></a>emplace_back</h2><p>作用：将对象放到vector中，在容器末尾就地构造元素（在末尾添加元素）</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Test"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~Test"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">const</span> Test <span class="token operator">&amp;</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Test copy"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">const</span> Test <span class="token operator">&amp;&amp;</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Test move"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Test age"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Test<span class="token operator">></span> v<span class="token punctuation">;</span>    Test tt<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"----------"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/////////////////////////////////////////////////传入左值</span>    <span class="token comment" spellcheck="true">// v.push_back(tt);//调用的是拷贝构造函数</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"----------"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// v.emplace_back(tt);//调用的是拷贝构造函数</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"----------"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/////////////////////////////////////////////////传入右值</span>    <span class="token comment" spellcheck="true">// v.emplace_back(Test(12));</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"----------"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*    Test age    Test move（没有move构造函数，就会调用copy构造函数）    ~Test    ~Test // 程序结束的析构    传右值：这里调用了一次构造函数（先在外面构造一个临时对象，执行完这句话后析构），一次移动构造函数（在emplace_back里面），所以有两次析构，构造了两个对象    */</span>        <span class="token comment" spellcheck="true">// v.push_back(Test(12));</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"----------"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*    Test age    Test move（没有move构造函数，就会调用copy构造函数）    ~Test    ~Test // 程序结束的析构    传右值：这里调用了一次构造函数（先在外面构造一个临时对象，执行完这句话后析构），一次移动构造函数（在push_back里面），所以有两次析构，构造了两个对象    */</span>        <span class="token comment" spellcheck="true">// v.emplace_back(12);</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"----------"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*    Test age    ~Test//程序结束的析构    传右值：这里调用了一次含参的构造函数    */</span>        <span class="token comment" spellcheck="true">// v.push_back(12);</span>    <span class="token comment" spellcheck="true">/*    Test age    Test move（没有move构造函数，就会调用copy构造函数）    ~Test    ~Test//程序结束的析构    传右值：这里调用了一次构造函数（先在外面构造一个临时对象，执行完这句话后析构），一次移动构造函数（在push_back里面），所以有两次析构，所以有两次析构，构造了两个对象    */</span>        <span class="token comment" spellcheck="true">// 结论：</span>    <span class="token comment" spellcheck="true">// 传左值：两者都是一样的：调用一次构造函数，再调用一次拷贝构造函数</span>    <span class="token comment" spellcheck="true">// 传右值：如果是已经构造好的右值，比如说Test(12)，那么二者是相同的；但是如果没构造好，比如12，需要调用有参构造函数，那么emplace_pack效率更高一些</span>        <span class="token comment" spellcheck="true">//从另一个角度来看，说明push_back真的会构建一个临时对象（</span>    vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span> ret<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ret.push_back(1,1)//会报错，因为没有构造一个临时对象</span>    ret<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//不会报错，因为构成了一个pair对象</span>    ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//不会报错，因为直接在容器的尾部创建对象</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><p>总结</p><p>push_back</p><ul><li>对于右值，如果是已经构造好了的，就直接调用move或copy函数（优先调用move）；如果还没构造好（例如传入12，需要调用有参构造函数，隐性的转换为该类对象），那就先构造出对象，然后再调用move或copy函数（优先调用move）</li><li>对于左值，拷贝构造</li></ul><p>emplace_back</p><ul><li>对于右值， 如果是已经构造好了的，就直接调用move或copy函数（优先调用move）；如果还没构造好，<strong>就直接原地调用有参构造函数</strong></li><li>对于左值，拷贝构造</li></ul><br><p>emplace_back使用上的一个<strong>坑</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> a<span class="token punctuation">;</span>        a<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里会报错</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解释：</p><ul><li><p>因为对于push_back来说，查看源代码发现它接收的是一个具体的value_type，即是固定的类型</p></li><li><p>再看看有关vector的构造，它没有写explicit，所以{1,2}可以隐式转换为vector<int></int></p></li><li><p>而对于emplace_back，它的源代码是一个模板函数，造成的结果就是所提供的参数{1,2}会做模板参数类型匹配，不会主动强转std::initializer_list<int>，需要你显式构造，或者用auto先推导一遍</int></p></li><li><p>但是这里模板推到不出来类型，所以就会报错</p></li><li><p><img src="/medias/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bvector/push%E5%92%8Cemplace_back_01.png"></p></li><li><p><img src="/medias/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bvector/push%E5%92%8Cemplace_back_02.png"></p></li><li><p>这里的value_type是typeof，即为T，可以理解为已经固定了的类型</p></li><li><p>参考：<a href="https://www.zhihu.com/question/438004429" target="_blank" rel="noopener">https://www.zhihu.com/question/438004429</a></p></li></ul><br><br><h2 id="shrink-to-fit"><a href="#shrink-to-fit" class="headerlink" title="shrink_to_fit"></a>shrink_to_fit</h2><p>作用：把capacity减小到size；可能使得现有的迭代器失效</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    f<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> f<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//20</span>    f<span class="token punctuation">.</span><span class="token function">shrink_to_fit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> f<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//11</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><br><br></p><h2 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h2><p>作用：删除内容，不改变容量大小（即size会发生变化，capacity不变）</p><br><p>语法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//删除指定位置的元素，返回值是一个迭代器，指向删除元素的下一个元素</span>iterator <span class="token function">erase</span><span class="token punctuation">(</span>iterator _Where<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//删除从 _First开始到 _Lsat位置的元素，返回值也是一个迭代器，指向最后一个删除元素的下一个位置</span>iterator <span class="token function">erase</span><span class="token punctuation">(</span>iterator _First<span class="token punctuation">,</span> iterator _Last<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// erase的应用</span>i6<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>i6<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//删除单个元素</span>i6<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>i6<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> i6<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//删除指定区间的元素</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><p>返回值：被删除元素后一个元素的迭代器（被删除元素的迭代器其实不会失效，而是指向被删除元素的下一个位置元素）</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 删除一个vector中所有等于2的数字的正确做法</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> count<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> iter<span class="token operator">=</span>count<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter<span class="token operator">!=</span>count<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token operator">*</span>iter<span class="token punctuation">)</span> <span class="token punctuation">{</span>        iter <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>iter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token operator">++</span> iter<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>erase实质是将迭代器后面的元素全部复制一遍，接着往前移动一个位置</p><p>因此当前位置的迭代器会指向原iter的后一位数字（所以其实是将后一部分的元素覆盖了前面部分的元素，比如说长为9的数组，删除掉前面5个数字，但当前下标为7和8位置的数据是不变的）</p><p>看了一下源码实现，如果是删除最后一个元素的话，就只会移动最后一个迭代器（end）</p><br><br><h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><p>作用：清空容器中所有的元素（只改变size，不改变capacity）；所以clear是不会释放容器的内存</p><br><p>时间复杂度分析</p><p>根据数据类型的不同，时间复杂度也会不同</p><ul><li>如果容器中是POD或基本数据，那由于该元素没有析构函数，加之vector内部连续存储的特性，编译器的实现是可以在<code>O(1)</code>完成<code>clear()</code>的</li><li>而如果是自定义数据，或者list或vector等类型，就要逐个去析构，时间复杂度就会到<code>O(n)</code></li></ul><br><p>因此，clear在某些时候时间复杂度是很高的</p><ul><li>在工程实践中，我们要思考是否每次都需要及时的clear掉一个容器</li><li>比如在后台服务中，有些容器类型的变量在符合某些条件下要进行clear()，后续逻辑中判断容器是空的，就不在用之进行某些逻辑（比如遍历它，进行某种操作）</li><li>其实也可以用一个bool标记来存储后续是否需要遍历该容器，待到本次请求的响应返回给client之后，再来清理这个容器也不迟</li></ul><br><br><h2 id="pop-back"><a href="#pop-back" class="headerlink" title="pop_back"></a>pop_back</h2><p>作用：删除最后一个元素（size发生变化，capacity不变）</p><br><br><h2 id="at和"><a href="#at和" class="headerlink" title="at和[]"></a>at和[]</h2><p>作用：二者是等价的，即也可以用at对对应下标的数值赋值</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// at(索引)</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> i6<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>i6<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//等价于i6[1]</span><span class="token comment" spellcheck="true">//at的源码</span>    reference    <span class="token function">at</span><span class="token punctuation">(</span>size_type __n<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">_M_range_check</span><span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">[</span>__n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// operator[]，返回第几个值</span>i6<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[]的越界访问是不会报错</p><ul><li>每次访问都需要判断越界，是非常损耗性能的</li><li>因此越界访问到什么数据都是未知的</li></ul><br><p>而at的越界访问是会报错的</p><ul><li>at会检查是否越界</li><li>同时，at的参数时size_t，放入负数的话会被转为整数</li></ul><br><br><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// assign</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> i5<span class="token punctuation">;</span>i5<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 第一个参数是数字，第二个参数是变量，即数量*变量</span>i5<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>i4<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i4<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 也可以用迭代器</span>i5<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 还可以用initializer_list</span><span class="token comment" spellcheck="true">// resize重设容器大小以容纳count个元素</span>i6<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// insert的三种形式</span>i6<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>i6<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//在begin的位置添加一个10的元素</span>i6<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>i6<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//在begin的位置添加10个值为10的元素</span>i6<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>i6<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> i5<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i5<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//把另一个容器的元素插入到指定位置</span><span class="token comment" spellcheck="true">// swap交换两个容器的内容</span>i6<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>i5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// emplace在指定位置添加元素</span>i6<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>i6<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><br><br><h1 id="trick"><a href="#trick" class="headerlink" title="trick"></a>trick</h1><h2 id="删除首个元素"><a href="#删除首个元素" class="headerlink" title="删除首个元素"></a>删除首个元素</h2><pre class="line-numbers language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">v1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>v1<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br><br><h2 id="释放空间"><a href="#释放空间" class="headerlink" title="释放空间"></a>释放空间</h2><p>背景：一般情况下vector的内存占用空间只增不减</p><p>比如一开始分配了10000个字节，然后erase掉后面9999个，留下一个有效元素</p><p>但是内存占用仍为10,000个（并且所有内存空间是在vector析构时候才能被系统回收）</p><p>clear()可以清空所有元素，但vector所占用的内存空间不变，无法保证内存的回收</p><p>所以如果想要清空vector所占用的内存，就用swap</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> f<span class="token punctuation">;</span>        f1<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//vector&lt;int>().swap(f1); // 或者这样</span>            <span class="token comment" spellcheck="true">// 这样不行，因为swap的参数是T&amp;，不能传递匿名对象</span>    <span class="token comment" spellcheck="true">//f1.swap(vector&lt;int>());</span>    cout <span class="token operator">&lt;&lt;</span> f1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> vector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep into DynamicProgming</title>
      <link href="/2022/10/10/deep-into-dynamicprogming/"/>
      <url>/2022/10/10/deep-into-dynamicprogming/</url>
      
        <content type="html"><![CDATA[<h1 id="路径问题（Path-Problem）"><a href="#路径问题（Path-Problem）" class="headerlink" title="路径问题（Path Problem）"></a>路径问题（Path Problem）</h1><h2 id="62、不同路径"><a href="#62、不同路径" class="headerlink" title="62、不同路径"></a>62、不同路径</h2><p>二维数组记录状态，通过滚动数组优化可以变为一维数组</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">uniquePaths</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="63、不同路径II"><a href="#63、不同路径II" class="headerlink" title="63、不同路径II"></a>63、不同路径II</h2><p>路上有障碍物，需要避开障碍物统计路线数量</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">uniquePathsWithObstacles</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> obstacleGrid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> obstacleGrid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> obstacleGrid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//最左边的竖线的一条路，只能一直往下走，所以为1</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>obstacleGrid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>obstacleGrid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> obstacleGrid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="64、最小路径和"><a href="#64、最小路径和" class="headerlink" title="64、最小路径和"></a>64、最小路径和</h2><p>统计到达目标点的最小路径和；也是二维数组，滚动优化后变为一维数组</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minPathSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//另一种优化为一维数组的方法</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minPathSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="120、最小三角路径和"><a href="#120、最小三角路径和" class="headerlink" title="120、最小三角路径和"></a>120、最小三角路径和</h2><p>杨辉三角；滚动数组优化</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minimumTotal</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> triangle<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> triangle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> triangle<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> triangle<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> triangle<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>dp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="221、最大正方形"><a href="#221、最大正方形" class="headerlink" title="221、最大正方形"></a>221、最大正方形</h2><p>用滚动数组优化（注意滚动数组要重置状态）</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maximalSquare</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                    res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res <span class="token operator">*</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//滚动数组优化</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maximalSquare</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> second <span class="token operator">=</span> i <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">,</span> first <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> second<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>second<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>second<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>second<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>first<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>first<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                    res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>second<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res <span class="token operator">*</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="416、分割等和子集"><a href="#416、分割等和子集" class="headerlink" title="416、分割等和子集"></a>416、分割等和子集</h2><p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等</p><p>这套题和最小三角路径和几乎是一模一样的dp思路，但是难就难在，很难将问题转换为路径问题…（而且由此也推出了滚动数组优化的两种情况）</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">canPartition</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        sum <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token punctuation">(</span>sum <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>              <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> sum<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">|</span><span class="token operator">=</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">|</span><span class="token operator">=</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>sum<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 滚动数组优化</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">canPartition</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        sum <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">f</span><span class="token punctuation">(</span>sum <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> sum<span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    f<span class="token punctuation">[</span>j <span class="token operator">+</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">|</span><span class="token operator">=</span> f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token punctuation">[</span>sum<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><br><br><h1 id="Coins-Problem"><a href="#Coins-Problem" class="headerlink" title="Coins Problem"></a>Coins Problem</h1><h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><ul><li><p>jd：最少需要多少硬币凑出amount</p></li><li><p>这里很关键的一步就是dp数组的初始化流程，将每个属性都设为INT_MAX</p></li><li><p>本质上就是<strong>完全背包问题</strong></p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> amount<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> coin<span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> coin <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span> <span class="token operator">!=</span> INT_MAX<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">==</span> INT_MAX <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="零钱兑换II"><a href="#零钱兑换II" class="headerlink" title="零钱兑换II"></a>零钱兑换II</h2><ul><li><p>jd：凑出amount有多少种方法</p></li><li><p>这里的坑点：循环的顺序和I是反过来的，需要注意（假设这里的数量5是由1112凑成的，就会只有这一种方法，但是如果改变循环顺序，即变为对于每个i，遍历所有的硬币，这样就会造成重复了）</p></li><li><p>PS：</p><ul><li>对于零钱兑换I来说，问的是硬币数量，要取得amount总值的硬币，就要假设枚举最后一次拿的是哪一种硬币，然后从中选出数量最少的</li><li>对于零钱兑换II来说，问的是有多少种方法，如果继续沿用上面的方法，就会出现问题</li><li>比如说硬币4和硬币5组成了amount值9，那么要得到9，枚举这两枚硬币的话，就会出现两种方法，而实际上都是同一种的</li><li>所以要改变循环思路，即改变最后子问题的问法（即此时的子问题不是当前解）</li><li>正确的子问题应该是在已经组成amount的方法中，出现了新的一种类型的硬币的时候，再用这种新的硬币组成amount，会有多少种方法</li><li>所以要逐枚逐枚的将硬币放入组成amount的方法中</li></ul></li><li><p>简答：求方法数的话，思路应该是，在只拿当前那么多的硬币的情况下，有多少种方法，然后再逐枚逐枚往后推</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token keyword">int</span> amount<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> coin<span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> coin<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> amount<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="Stock-Problem"><a href="#Stock-Problem" class="headerlink" title="Stock Problem"></a>Stock Problem</h1><h2 id="买卖股票的最佳时机I"><a href="#买卖股票的最佳时机I" class="headerlink" title="买卖股票的最佳时机I"></a>买卖股票的最佳时机I</h2><ul><li><p>jd：只能买卖一次股票（同 剑指 Offer 63. 股票的最大利润）</p></li><li><p>只要找到前面最低点，和这个点以后的最高点的差值即可</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> minn <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> price<span class="token operator">:</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>            minn <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>minn<span class="token punctuation">,</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> price <span class="token operator">-</span> minn<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a>买卖股票的最佳时机II</h2><ul><li><p>jd：能无限次的买卖股票</p></li><li><p>只要当前的价格大于昨天的，就卖股票拿钱</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="买卖股票的最佳时机III"><a href="#买卖股票的最佳时机III" class="headerlink" title="买卖股票的最佳时机III"></a>买卖股票的最佳时机III</h2><ul><li><p>jd：最多能买卖两次股票</p></li><li><p>每天可以分为两种状态：</p><ul><li>没股票 &#x3D; max（昨天没股票，昨天有股票今天卖股票）</li><li>有股票 &#x3D; max（昨天有股票，昨天没股票今天买股票）</li></ul></li><li><p>再结合最多能买卖两次股票，就变为：</p><ul><li>没股票 &#x3D; max（昨天没股票（处于同一笔交易中），昨天有股票今天卖股票（处于同一笔交易））</li><li>有股票 &#x3D; max（昨天有股票（处于同一笔交易中），昨天没股票今天买股票（进入新一笔交易中））</li></ul></li><li><p>所以这里就把分为两个数组sell和hold，第一个下标表示当前的天数是多少，第二个表示当前是第几个交易阶段</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*表示当前持有股票，这里必须要设置为INT_MIN，因为对于i=1的时候，此时对应的是prices中的0，那么要持有股票的话，就只能当前买股票，不能用前一天的数据        而当天买股票会导致值为负数，为了防止这一点，就设为INT_MIN，使得当天要股票的话，就必须当天买，不能推到昨天*/</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">hold</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> INT_MIN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*当前没股票*/</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">sell</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/*第i天有股票，要么是第i-1天没有股票，第i天买的；要么是第i-1天有股票*/</span>                hold<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>hold<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> sell<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/*第i天没有股票，要么是第i-1天有股票，然后第i天卖出的；要么是第i-1天就没有股票*/</span>                sell<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>sell<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> hold<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sell<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//滚动数组优化</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sell1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sell2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> hold1 <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> hold2 <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sell1 <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>sell1<span class="token punctuation">,</span> hold1 <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            hold1 <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>hold1<span class="token punctuation">,</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sell2 <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>sell2<span class="token punctuation">,</span> hold2 <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            hold2 <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>hold2<span class="token punctuation">,</span> sell1 <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token keyword">return</span> sell2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>这里有个很坑的地方，就有点难以理解：</p><ul><li>其实当j等于2的时候，真的不代表它经过了两次交易，有可能是前一段中价格实在太低了，就没有买股票，所以值就是0（这里数组初始化的时候就有了），当出现合适的时候就买了股票，记录为第二笔交易</li><li>而我们这里对于每一天，都记载了当前是第一笔交易或是第二笔交易的情况，所以算得上是考虑周全了</li></ul></li><li><p>这里我对dp的一个感悟就是，将问题变为一个一个子问题，然后从最后一步看是否符合dp模型，即最优解是否符合状态转移这个过程</p></li></ul><h2 id="买卖股票的最佳时机IV"><a href="#买卖股票的最佳时机IV" class="headerlink" title="买卖股票的最佳时机IV"></a>买卖股票的最佳时机IV</h2><ul><li><p>jd：最多能买卖k次股票</p></li><li><p>和上面的情况一模一样了属于是…..</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*表示当前持有股票，这里必须要设置为INT_MIN，因为对于i=1的时候，此时对应的是prices中的0，那么要持有股票的话，就只能当前买股票，不能用前一天的数据        而当天买股票会导致值为负数，为了防止这一点，就设为INT_MIN，使得当天要股票的话，就必须当天买，不能推到昨天*/</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">hold</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> INT_MIN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*当前没有股票*/</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">sell</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/*第i天有股票，要么是第i-1天没有股票，第i天买的；要么是第i-1天有股票*/</span>                hold<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>hold<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> sell<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/*第i天没有股票，要么是第i-1天有股票，然后第i天卖出的；要么是第i-1天就没有股票*/</span>                sell<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>sell<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> hold<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sell<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//滚动数组优化</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">hold</span><span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> INT_MIN<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sell</span><span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> mid <span class="token operator">=</span> hold<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                hold<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>hold<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> sell<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                sell<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>sell<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sell<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a>最佳买卖股票时机含冷冻期</h2><ul><li><p>jd：能无限买卖股票，但是卖出股票的第二天是不能买入股票的（即冷冻期为1天）</p></li><li><p>参考股票模型，然后魔改一下，注意init即可</p></li><li><p>拓展：如果冷冻期是2天，3天，那也是一样的</p></li><li><p>PS：</p><ul><li>股票问题最难优化的部分其实是，要找到方程到底是依赖于那几个变量，其次是如何调整更新各个变量的顺序</li><li>比如说本题，每次更新都只需要当前位置的前两个位置的sell，当前位置的前一个hold</li><li>所以就可以确认只需要sell1，sell2和hold三个变量，接着就是要确认更新顺序了</li><li>发现当前的hold需要的是前一个hold和sell1；当前的sell2需要的是前一个hold和前一个sell2；当前的sell1需要的是前一个sell2</li><li>即可知，需要一个中间变量来存放前一个sell2，然后再更新sell2（不能先更新hold，因为这里需要前一个hold），再就是更新hold，最后用中间变量更新sell1</li></ul></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*判断边界情况*/</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/*init数组*/</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sell</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">hold</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*最开始持有的话，就是第一天股票的价格，不过这里可以不用初始化，因为后面的遍历时不看这个的.....*/</span>        hold<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*第二天买的话就看谁的价格更低一点*/</span>        hold<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*第二天卖的话，看有无利润喽*/</span>        sell<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> prices<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sell<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>sell<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> hold<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/*如果今天有股票的话，要么昨天有，要个过了冷冻期再才能买股票*/</span>            hold<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>hold<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> sell<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sell<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//滚动数组优化</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> sell1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sell2 <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> prices<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> hold <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> sell2<span class="token punctuation">;</span>            sell2 <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>sell2<span class="token punctuation">,</span> hold <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            hold <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>hold<span class="token punctuation">,</span> sell1 <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sell1 <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sell2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a>买卖股票的最佳时机含手续费</h2><ul><li><p>jd：可以无限买卖股票，但买卖股票有手续费</p></li><li><p>太经典的模型了…..</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">,</span> <span class="token keyword">int</span> fee<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sell</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">hold</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sell<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>sell<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> hold<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> fee<span class="token punctuation">)</span><span class="token punctuation">;</span>            hold<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>hold<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> sell<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sell<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//发现sell和hold只依赖前面一个，所以可以滚动数组优化</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">,</span> <span class="token keyword">int</span> fee<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> sell <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> hold <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sell <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>sell<span class="token punctuation">,</span> hold <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> fee<span class="token punctuation">)</span><span class="token punctuation">;</span>            hold <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>hold<span class="token punctuation">,</span> sell <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sell<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h2><ul><li><p>PS：我觉得这道题和股票问题很像，是因为这两类题的状态都是由前一个状态和另一个状态推导过来的</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProduct</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">fmax</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">fmin</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            fmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">max</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> fmax<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> fmin<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            fmin<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> fmax<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> fmin<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>fmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="环状最大两段子段和"><a href="#环状最大两段子段和" class="headerlink" title="环状最大两段子段和"></a>环状最大两段子段和</h2><ul><li><p>吉比特笔试，洛谷P1121</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">hold</span><span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> INT_MIN<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sell</span><span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> mid <span class="token operator">=</span> hold<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                hold<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>hold<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> sell<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                sell<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>sell<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sell<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">solve</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arrs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> arrs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">counts</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            counts<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> counts<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> arrs<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> counts<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> arrs<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    Solution s1<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> s1<span class="token punctuation">.</span><span class="token function">solve</span><span class="token punctuation">(</span>arrs<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="Knapsack-Problem"><a href="#Knapsack-Problem" class="headerlink" title="Knapsack Problem"></a>Knapsack Problem</h1><h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><ul><li><p>jd：</p><ul><li>有<code>N</code>件物品和一个容量是<code>V</code>的背包。每件物品<strong>只能使用一次</strong>（所以是01背包），第<code>i</code>件物品的体积是<code>vi</code>，价值是<code>wi</code></li><li>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大</li><li>输出最大价值</li></ul></li><li><p>因为只能拿一次，所以在一维数组的时候<strong>必须要倒序</strong></p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">zero_one_back_problem</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> weight<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> weight<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> capacity<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> weight<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> weight<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> value<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>                <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//滚动数组优化</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">zero_one_back_problem</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> weight<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> weight<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> capacity<span class="token punctuation">;</span> j <span class="token operator">>=</span> weight<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">--</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> weight<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> value<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>                <span class="token keyword">return</span> dp<span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><ul><li><p>jd：</p><ul><li>有<code>N</code>种物品和一个容量是<code>V</code>的背包，每种物品<strong>都有无限件可用</strong>（所以是完全背包问题），第<code>i</code>种物品的体积是<code>vi</code>，价值是 wi</li><li>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大</li><li>输出最大价值</li></ul></li><li><p>因为是无限次数的，所以不需要倒序</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">intirely_back_problem</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> weight<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> weight<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> capacity<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> weight<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> weight<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> value<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>                <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//滚动数组优化</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">intirely_back_problem</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> weight<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> weight<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> capacity<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> weight<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> weight<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> value<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>                <span class="token keyword">return</span> dp<span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="House-Robber"><a href="#House-Robber" class="headerlink" title="House Robber"></a>House Robber</h1><h2 id="打家劫舍I"><a href="#打家劫舍I" class="headerlink" title="打家劫舍I"></a>打家劫舍I</h2><ul><li><p>jd：相邻的房屋被偷会自动报警</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//滚动数组优化</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> dp<span class="token punctuation">{</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">max</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">-</span> i <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">-</span> n <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="打家劫舍II"><a href="#打家劫舍II" class="headerlink" title="打家劫舍II"></a>打家劫舍II</h2><ul><li><p>jd：房子是环绕一圈的，其他条件同I</p></li><li><p>复盘一下使用二进制滚动数组时的一个错误(这里其实最好不要用二进制，因为，我们不知道begin是奇数还是偶数，这会导致我们后面遍历i%2的时候不好处理，比如说begin如果是奇数，那begin一开始就要放到1的位置；如果begin是偶数的话，那begin一开始就要放到0的位置，这样在最后求解的时候就会很麻烦，因为不知道到底应该取dp[0]还是取dp[1])</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">solve</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">solve</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">solve</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> first <span class="token operator">=</span> nums<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">,</span> second <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>begin <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> begin <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> second<span class="token punctuation">;</span>            second <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>first <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> second<span class="token punctuation">)</span><span class="token punctuation">;</span>            first <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> second<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="打家劫舍III"><a href="#打家劫舍III" class="headerlink" title="打家劫舍III"></a>打家劫舍III</h2><ul><li><p>jd：</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) {} *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">TreeStatus</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token keyword">int</span> select<span class="token punctuation">;</span>        <span class="token keyword">int</span> buselect<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>        TreeStatus res <span class="token operator">=</span> <span class="token function">solve</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>select<span class="token punctuation">,</span> res<span class="token punctuation">.</span>buselect<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        TreeStatus <span class="token function">solve</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        TreeStatus left <span class="token operator">=</span> <span class="token function">solve</span><span class="token punctuation">(</span>root <span class="token operator">-</span><span class="token operator">></span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeStatus right <span class="token operator">=</span> <span class="token function">solve</span><span class="token punctuation">(</span>root <span class="token operator">-</span><span class="token operator">></span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>root <span class="token operator">-</span><span class="token operator">></span> val <span class="token operator">+</span> left<span class="token punctuation">.</span>buselect <span class="token operator">+</span> right<span class="token punctuation">.</span>buselect<span class="token punctuation">,</span> <span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>select<span class="token punctuation">,</span> left<span class="token punctuation">.</span>buselect<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">max</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span>select<span class="token punctuation">,</span> right<span class="token punctuation">.</span>buselect<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="区间型dp"><a href="#区间型dp" class="headerlink" title="区间型dp"></a>区间型dp</h1><ul><li>单词拆分</li></ul><h2 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h2><ul><li><p>jd：寻找最长重复的子数组</p></li><li><p>和子序列有点像，但是不是一类题，因为数组和序列有本质的区别的..</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findLength</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>                res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h2><ul><li><p>jd：查询回文串的数量</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">countSubstrings</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">+</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                res <span class="token operator">+</span><span class="token operator">=</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="剑指offer-II-020-回文子字符串的个数"><a href="#剑指offer-II-020-回文子字符串的个数" class="headerlink" title="剑指offer II 020.回文子字符串的个数"></a>剑指offer II 020.回文子字符串的个数</h2><ul><li>和回文子串一样（不过有一个更优的做法）</li></ul><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><ul><li><p>jd：寻找字串中最长的回文子串</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        string res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">-</span> i<span class="token punctuation">;</span> <span class="token operator">++</span> j <span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>j <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>j <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> dp<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// res = (res.size() >= dp[j][j + i]) ? res : s.substr(j, i + 1);//用了这句话就会超时....</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><ul><li><p>jd：返回最长回文子序列的长度</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">longestPalindromeSubseq</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token number">2</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> j<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> f<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a>戳气球</h2><ul><li><p>jd：</p></li><li><p>经典的区间型dp</p></li><li><p>PS：dp数组的两个边界不参与计算的</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxCoins</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">-</span> i<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j <span class="token operator">+</span> i<span class="token punctuation">;</span> <span class="token operator">++</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">+</span> f<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="序列型dp"><a href="#序列型dp" class="headerlink" title="序列型dp"></a>序列型dp</h1><ul><li>正则表达式</li><li><strong>编辑距离</strong></li><li>交错字符串</li></ul><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><ul><li><p>jd：</p></li><li><p>经典的序列dp，注意一下数组的初始化</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">longestCommonSubsequence</span><span class="token punctuation">(</span>string text1<span class="token punctuation">,</span> string text2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> text1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> text2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>text1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> text2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//优化为滚动数组</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">longestCommonSubsequence</span><span class="token punctuation">(</span>string text1<span class="token punctuation">,</span> string text2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> text1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> text2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> now <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> old <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            now <span class="token operator">=</span> i <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span>            old <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> now<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>old<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>text1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> text2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>old<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//  优化至一维数组</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">longestCommonSubsequence</span><span class="token punctuation">(</span>string text1<span class="token punctuation">,</span> string text2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> text1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> text2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> pre <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> temp <span class="token operator">=</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>text1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> text2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>pre <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                pre <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h1><ul><li>接雨水</li><li>俄罗斯套娃信封问题</li><li>鸡蛋掉落</li><li>剑指offer n个骰子的点数</li><li>不同的二叉搜索树</li></ul><h2 id="解码问题"><a href="#解码问题" class="headerlink" title="解码问题"></a>解码问题</h2><ul><li><p>jd：</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numDecodings</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//滚动数组优化</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numDecodings</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> dp1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> dp2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                temp <span class="token operator">+</span><span class="token operator">=</span> dp2<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">27</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                temp <span class="token operator">+</span><span class="token operator">=</span> dp1<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            dp1 <span class="token operator">=</span> dp2<span class="token punctuation">;</span>            dp2 <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h2><ul><li><p>jd：</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">integerBreak</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">max</span><span class="token punctuation">(</span>j <span class="token operator">*</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> j <span class="token operator">*</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//数学方法优化</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">integerBreak</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token function">max</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token function">max</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="最大子序列和"><a href="#最大子序列和" class="headerlink" title="最大子序列和"></a>最大子序列和</h2><ul><li><p>同剑指offer 42.连续子数组的最大和</p></li><li><p>简单题，但是思路却很巧妙</p></li><li><p>先初始化dp为第一个元素</p></li><li><p>对于后面的每一个元素，如果我当前的dp是正的话，那我就加上当前的数；否则dp就变为当前的数（这一步非常的关键，可以认为是一种贪心的做法，因为dp为正的时候，它可以搏一搏更大的数，因为后面如果是正的，就更大了；如果负的，那么首先res已经记录了max值，其次，加上负的，有可能后面还会有更大的数。这无疑是一种贪心了）</p></li><li><p>然后将此时的dp和res进行比较，res去max</p></li><li><p>最后遍历完所有的元素后，return res</p></li></ul><h2 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h2><ul><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//递归写法</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> n<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//滚动数组</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> first <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> second <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> second<span class="token punctuation">;</span>            second <span class="token operator">+</span><span class="token operator">=</span> first<span class="token punctuation">;</span>            first <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> second<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><ul><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用数组能够提高cpu cache的s</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h2><ul><li><p>jd：</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numSquares</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">*</span> j <span class="token operator">&lt;=</span> i<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> j <span class="token operator">*</span> j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="不同二叉搜索树"><a href="#不同二叉搜索树" class="headerlink" title="不同二叉搜索树"></a>不同二叉搜索树</h2><ul><li><p>jd：</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> n<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h2><ul><li><p>jd：这道题经典之处在于它的数学上的推导，非常值得品味</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 二维dp</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> diff <span class="token operator">=</span> sum <span class="token operator">-</span> target<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> diff <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> neg <span class="token operator">=</span> diff <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>neg <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> now <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> old <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i <span class="token punctuation">)</span> <span class="token punctuation">{</span>            now <span class="token operator">=</span> i <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span>            old <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> now<span class="token punctuation">;</span>            <span class="token keyword">int</span> num <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> neg<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>old<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> dp<span class="token punctuation">[</span>old<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> num<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>neg<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 压缩dp</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> diff <span class="token operator">=</span> sum <span class="token operator">-</span> target<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> diff <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> neg <span class="token operator">=</span> diff <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>neg <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> neg<span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>neg<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="丑数II"><a href="#丑数II" class="headerlink" title="丑数II"></a>丑数II</h2><ul><li><p>jd:</p></li><li><p>其实也不能算是dp，但是当前每次位置数量的更新都是要依靠前面的数字的，就勉强算是dp吧</p></li><li><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">nthUglyNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 该方法的证明过程复杂，直接背题目就行了</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> p2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> p3 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> p5 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> num2 <span class="token operator">=</span> dp<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> num3 <span class="token operator">=</span> dp<span class="token punctuation">[</span>p3<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">,</span> num5 <span class="token operator">=</span> dp<span class="token punctuation">[</span>p5<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token function">min</span><span class="token punctuation">(</span>num2<span class="token punctuation">,</span> num3<span class="token punctuation">)</span><span class="token punctuation">,</span> num5<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> num2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token operator">++</span> p2<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> num3<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token operator">++</span> p3<span class="token punctuation">;</span>            <span class="token punctuation">}</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> num5<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token operator">++</span> p5<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="掷骰子的N种方法"><a href="#掷骰子的N种方法" class="headerlink" title="掷骰子的N种方法"></a>掷骰子的N种方法</h2><h2 id="组合总和-Ⅳ"><a href="#组合总和-Ⅳ" class="headerlink" title="组合总和 Ⅳ"></a>组合总和 Ⅳ</h2><h2 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h2><h2 id="最后一块石头的重量-II"><a href="#最后一块石头的重量-II" class="headerlink" title="最后一块石头的重量 II"></a>最后一块石头的重量 II</h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>题目如果涉及到区间的，马上想到区间型动态规划</p><ul><li>解：首先是确定区间i-j，然后在i-j里面选择数字k，查看i-k和k+1-j的情况，然后把状态转移给i-j</li><li>注意要控制好循环的边界，同时做好dp数组的初始化</li></ul></li><li><p>而区间型的dp，看看是否可以用背包问题来优化一下</p><ul><li>例如单词拆分，用区间是可以做出来，但是时间空间的效率都太慢了</li><li>所以思考一下对于0-i之间的字母，如果可以用dictionary组合出来，必然存在j，使得j-i之间为一个在dictionary里面的单词</li><li>而要保证0-i之间为true，就要保证后面是一个单词，并且前面也要是true</li><li>这就是最早的硬币问题啦</li></ul></li><li><p>而股票问题给我们最大的启示就是</p><ul><li>首先，要找到正确的状态去转移，题目往往会给很多无用的信息</li><li>如果状态的维数太高，考虑是不是要降维换成数组来表示（如三维数组变为sold和hold两个数组）</li></ul></li><li><p>dp的几个关键点</p><ul><li>将问题转换为子问题，由此实现状态的步步转移（比如说最后一步的结果，是由前面的那几步推导过来的）</li><li>写出状态转移方程</li><li>初始化数组（这一步很重要，这会直接导致后续的bug）</li><li>得到结果，然后查看是否能够使用滚动数组进行优化，即降维处理</li></ul></li></ul><h1 id="滚动数组优化"><a href="#滚动数组优化" class="headerlink" title="滚动数组优化"></a>滚动数组优化</h1><ul><li>思路：可以用first和second，或者temp来实现，或者使用二进制来实现</li><li>PS：其实能用数组就用数组，因为这样会减少cache miss，提高效率（不过打家劫舍II就不能用二进制数组，坑很大）</li><li>例题：<ul><li>62、不同路径</li><li>63、不同路径II</li><li>64、最小路径和</li><li>120、最小三角路径和</li><li>198、打家劫舍</li><li>213、打家劫舍II（这里只能用第一种方法来实现滚动数组，小心坑）</li></ul></li><li>滚动数组优化的一个要点：每次计算之后，都要重置一遍前面的几个滚动变量<ul><li>比如解码问题中的滚动变量，计算完后，第一个变量应该是下一个变量的前两个变量，第二个变量和第三个变量都是下一个变量的前一个变量</li></ul></li><li>什么时候滚动数组是一维数组，什么时候是二维数组<ul><li>一般来说，大多数的滚动数组到最后都可以优化到一维数组的情况（如果需要更新后同一行的数据和上一行当前位置的数据，就从左往右循环；否则需要只上一行的数据和当前行的数据，就从右往左循环）</li><li>那些不能优化到一维数组的要么就是优化后代码的可读性太差，要么就是状态方程需要上下两行数组来更新状态，导致不能用一维（比如说有一个二维数组，更新方式是从右往左循环的，新的dp[1] [j]既需要dp[0] [j-k]也需要dp[1] [j-k]，那么此时就不能优化到一维数组了，因为一维数组会把原来的dp[0] [j-k]给cover掉）</li><li>当然，大部分的dp要的只是上一行的数据，需要上两行的着实罕见喵</li></ul></li></ul><h1 id="dp数组初始化"><a href="#dp数组初始化" class="headerlink" title="dp数组初始化"></a>dp数组初始化</h1><ul><li>数组的下标从1开始能够解决很多边界问题</li><li>求最大或者最小的时候，数组初始化最好反方向设置，比如说求最小的xx时，就init为INT_MAX</li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul><li>将问题分解为子问题，比如说要达到最后一个目标，需要得到哪几个目标</li><li>由子问题写出状态转移方程</li><li>用循环遍历出方程</li><li>初始化dp数组</li><li>想办法优化，比如说滚动数组</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> DynamicProgming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep into BinaryTree</title>
      <link href="/2022/10/10/deep-into-binarytree/"/>
      <url>/2022/10/10/deep-into-binarytree/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的基本性质"><a href="#二叉树的基本性质" class="headerlink" title="二叉树的基本性质"></a>二叉树的基本性质</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>二叉搜索树的基本性质，二叉树前中后序遍历的特性，完全二叉树的性质</li><li>从前，中遍历或中，后遍历能够推出二叉树</li><li>关于节点数量的规律：设非空二叉树中度为0、1和2的结点个数分别为n0、n1和n2，则有 <strong>n0 &#x3D; n2 + 1</strong><ul><li>即叶子结点比二分支结点多一个</li></ul></li></ul><br><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>100、相同的树（两边dfs）</p><p>101、对称二叉树（两边dfs）</p><p>104、二叉树的最大深度（dfs）</p><p><strong>124</strong>、二叉树的最大路径和</p><ul><li>最大路径和的两种情况：<ul><li>1、从当前节点出发，只走左子树或右子树</li><li>2、从左子树的某一处出发，经过当前节点，然后到达右子树的某一处</li></ul></li><li>问题就转化为如何用同一套代码能够将这两种情况都包含，或是说二者的共同点在哪儿</li><li>思路：为什么会出现只走左&#x2F;右子树，是因为走左&#x2F;右子树只能得到小于等于0的结果；因此得到一个思路，在寻找最大路径和的时候，左子树给出的结果应该是<code>max(0,dfs(root -&gt; left))</code></li><li>整体逻辑：设置全局变量maxn，设最开始的<code>maxn为root -&gt; val</code>（如果nullptr就返回0）</li><li>分别对各个点进行左右遍历，得到<code>left = max(0, dfs(root -&gt; left))</code>和<code>right = max(0, dfs(root -&gt; right))</code></li><li>然后，得到<code>max1 = left + right + root -&gt; val</code>，<code>maxn = max(max1, maxn)</code>，最后，当前函数需要返回<code>root -&gt; val + max(left, right)</code>（因为当前节点又会被上一层给调用）</li><li>这种逐层递归的好处，是可以枚举每个节点遇到上述情况时候的取值，从而得到全体最大值</li></ul><p>236、二叉树的最近公共祖先</p><ul><li>先判断当前的节点是不是目标节点之一（或者是不是nullptr），如果是就直接返回</li><li>否则就判断左边和右边，如果左边是空的，那就证明必然是右边，反之也是一样</li><li>如果两边都不是空的话，就代表两个节点在当前节点的两侧，直接返回当前节点</li></ul><p>257、二叉树的所有路径（字符串+经典的dfs）</p><p>572、另一棵树的子树（子树的定义）</p><ul><li>子树的定义：对于一个节点，二者都是null，ok；原树有、新树没有，或者原树没有，新树有，error</li></ul><p><strong>543</strong>、二叉树的直径</p><ul><li>二叉树的最长直径的两种情况<ul><li>1、从当前节点出发，只走左子树或右子树</li><li>2、从左子树的某一处出发，经过当前节点，然后到达右子树的某一处</li></ul></li><li>和687，124都是一模一样的套路</li></ul><p>617、合并二叉树（DFS，需要注意空节点）</p><p>653、两数之和 IV（输入BST）（剑指offerII 56 二叉搜索树中两个结点之和）：哈希表+前序遍历即可</p><p>671、二叉树中第二小的节点（读题仔细，dfs解决，老套路了）</p><p><strong>687</strong>、最长同值路径</p><ul><li>二叉树的最长同值路径的两种情况<ul><li>第一种：从该点出发，只走左子树或右子树</li><li>第二种：从左子树的某一处出发，经过该节点，然后到达右子树的某一处</li></ul></li><li>和543，124都是一模一样的套路</li><li>需要注意一点的是，要传入上一个结点的number，通过当前的root-&gt;val和number来判断要返回的是0还是其他的</li></ul><p>814、二叉树剪枝（自底向上的遍历，和之前一道题很像，忘了是那一道，后续看看）</p><ul><li>剑指offer II 047.二叉树剪枝（一模一样的）</li></ul><p>951、翻转等价二叉树（感觉和验证两个二叉树是否相等一样，都是比较左右节点的题目）</p><p>剑指offer 26 树的子结构</p><ul><li>对于每个点都判断是否为目标二叉树</li><li>一定要注意树的子结构和树的子树是不一样的：</li><li>如果是子树，就必须要求两棵树上所有的结点都要能够对上（原树为空，目标树必须为空；原树有结点，目标树也得有结点）（目标树为空，原树必须也为空；目标书有节点，原树必须也有结点）</li><li>如果是子结构，只要目标树有的原树都有，就行了（原树为空，目标树必须为空；原树有结点，目标树可以没有结点）（如果目标树为空，那么原来的树有没有结点都无所谓；如果目标树有结点，原树必须也有结点）</li></ul><br><br><br><h1 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ul><li>树的层序遍历，即广度优先搜索；或者在层序遍历的时候，添加一些其他的操作</li></ul><br><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul><li>建立一个queue，最开始将第一个root点放入队列，进行我们想要的操作（求最大值、平均值、最左边的数）</li><li>注意此时一开始是用一个node记录此时的queue.front()，接着把这个点从队列中pop</li><li>操作完后，就把该点的左右结点给放入队列中；递归循环上述操作</li><li>踩坑：for循环中要用一个size记录初始队列的大小，因为随着后续的元素不断放入，size会改变的<ul><li>或者从后往前遍历也是可以的</li></ul></li></ul><br><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p>102、二叉树的层序遍历（层序遍历）</p><p>103、二叉树的锯齿形层序遍历（层序遍历；根据深度反转数组）</p><p>111、二叉树的最小深度（用层序遍历记录floor；也可以用递归求解）</p><p>199、二叉树的右视图（层序遍历；每次只取最后一个数）</p><p>222、完全二叉树的节点个数（层序遍历；遇到nullptr就break）</p><p>429、N叉树的层序遍历（层序遍历）</p><p>513、找树左下角的值（层序遍历，记录每次出现的第一个值）</p><p>515、在每个树行中找最大值（层序遍历；记录行max）</p><p>637、二叉树的层平均值（层序遍历；求avg）</p><p>662、二叉树的最大宽度（用两个队列来实现层序遍历；或者用一个新的结构体Node，同时记录节点的val和节点的指针，放入左节点就是* 2，放入右节点就是 *2 + 1；最后注意防越界，用unsigned long long即可）</p><p>958、二叉树的完全性检验（层序遍历；根据完全二叉树的性质，一旦遇到nullptr，后面就不应该有节点了，否则就不是完全二叉树；用一个flag来表示是否遇到了nullptr）</p><p>1609、奇偶树（层序遍历；根据奇偶做不同的处理）</p><p>面试题 04.03、 特定深度节点链表（层序遍历生成链表）</p><p>剑指offer 32、从上到下打印二叉树（层序遍历）</p><p>剑指offer II 044.二叉树每层的最大值</p><p>剑指offer II 045.二叉树最底层最左边的值</p><p>剑指offer II 046.二叉树的右侧视图</p><br><br><br><h1 id="前中后序遍历"><a href="#前中后序遍历" class="headerlink" title="前中后序遍历"></a>前中后序遍历</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><ul><li>需要对树进行根左右，左根右，左右根的遍历，并且在每次遍历的时候添加其他操作</li></ul><br><h2 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h2><ul><li>遍历一般有两种方式来实现，第一种是递归，第二种是用栈模拟递归（挖坑：第三种遍历mirror遍历不会）</li></ul><br><h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h2><p>94、二叉树的中序遍历（递归&#x2F;非递归版）</p><p>98、验证二叉搜索树</p><ul><li>这道题是用到了二叉搜索树的性质+中序遍历。即对于每棵树，根节点是大于左子树的节点的，右子树的节点是大于根节点的</li><li>然后联想到中序遍历是左根右的，所以就一方面维护一个pre节点，另一方面左根右的遍历，走完左子树，pre就变为左子树中的最大值（即左子树的右子树其中一个值），和根节点比较；走完根节点，pre就变为根节点，和右子树的左子树的最小值（即右子树的左子树其中一个值）进行比较）</li><li>这就是中序遍历的高深之处，始终维护着pre为一部分的最大值</li><li>这道题的做法无非就是中序遍历的变种（第一种是每次遍历都维护前面一个节点，第二种是递归得到全部的数组，第三种是stack维护前一个节点）</li></ul><p>105、从前序遍历与中序遍历构造二叉树</p><ul><li>模板题</li><li>关于右边界的问题，是否要取到右边界都是可以选择的，关键是你怎么写（我的做法中右边界是不可取值的）</li></ul><p>106、从中序遍历与后序遍历构造二叉树</p><ul><li>同105一样的思路，类似的题还有剑指 offer07</li></ul><p>144、二叉树的前序遍历（递归&#x2F;非递归版）</p><p>145、二叉树的后序遍历（递归&#x2F;非递归版；非递归实现思路，后序遍历是左右根，那么就相当于是根右左反过来，所以只要求得根右左，反转后便是结果）</p><p>589、N叉树的前序遍历（递归&#x2F;非递归版）</p><p>590、N叉树的后序遍历（递归&#x2F;非递归版）</p><p>872、叶子相似的树（非常巧妙地中序遍历输出叶子，然后对比）</p><p>剑指 offer36（<strong>挖坑</strong>）</p><p>原创题：二叉树的下一个节点（中序遍历；如果有右子树，就往右子树下面找，否则就往上找）</p><br><br><br><h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><ul><li>二叉搜索树的性质：中序遍历得到的数组是依次递增的，右左根得到的数组是依次递减的，当前节点的数字是大于左边而小于右边的</li></ul><br><h2 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h2><ul><li>中序遍历或者是右左根遍历，都可以用递归或stack来实现</li></ul><br><h2 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h2><p>95、不同的二叉搜索树 II（用递归分别求出左右两个子树，然后用两层循环嵌套生成二叉树）</p><p>98、验证二叉搜索树（利用二叉搜索树的性质，中序遍历的递归和非递归版，或者把中序遍历一遍二叉树，然后逐个逐个看是否大于前一个）</p><p>99、恢复二叉树（也是利用二叉树搜索树和中序遍历的性质，但是其中利用r1和r2的方法真的很绝，建议好好看看）</p><p>108、将有序数组转换为二叉搜索树（经典传递数组和数组边界，然后递归）</p><p>109、有序链表转换二叉搜索树（经典利用二叉搜索树的性质，取中间数作为节点，然后递归left和right）</p><p>230、二叉搜索树中第k小的元素</p><ul><li>中序遍历，每次得到元素的时候修改k，当k为0的时候return</li><li>或者dfs，本质上也是中序遍历</li></ul><p>235、二叉搜索树的最近公共祖先</p><ul><li>通过大小判断接下来遍历那一边的子树</li></ul><p>450、删除二叉树中的节点（非常经典的题目，既可以把左子树接到右子树的最左边的节点上，也可以把右子树接到左子树最右边的节点上）</p><p>530、二叉搜索树的最小绝对差（二叉搜索树的性质，中序遍历）</p><p>538、把二叉搜索树转换为累加树（1038.把二叉搜索树转换为累加树，剑指offer II 054.所有大于等于节点的值之和）</p><ul><li>这道题的思路很巧妙：用的是<strong>反向的中序遍历</strong>，先遍历右边，再处理root，最后遍历左边（其中还用了一个全局变量来维护右子节点的最大值）</li><li>思路和实现上都比较简单，但是很难想到如此的巧妙</li><li>而我的思路：<ul><li>对于一个节点本身来说，右子节点是用来给自身赋值的，所以，如果能往右边走，当前的值就是右边，就继续递归下去</li><li>如果不能，那就继承父类给的base（具体参考代码）</li><li>而对于左节点，如果左节点不能走，那以本节点为根节点的树的最大值就是root-&gt;val</li><li>如果能走，那就返回递归的左节点</li></ul></li></ul><p>669、修建二叉搜索树（利用二叉搜索树的性质，如果当前的值小于low，就把左子树砍掉，返回右子树；如果当前的值大于high，就把右子树砍掉，返回左子树）</p><p>701、二叉搜索树中的插入操作（二叉搜索树的性质）</p><p>783、二叉搜索树节点最小距离（同上）</p><p>897、递增顺序搜索树（利用二叉搜索树性质中序遍历建树）</p><p>938、二叉搜索树的范围和（利用二叉搜索树性质）</p><p>剑指offer 54、 二叉搜索树的第k大节点</p><ul><li>非递归的做法（右左根依次遍历，得到便是依次递减的数列，同时更新k值，递减到0为止）</li><li>递归的做法（递归实现右左根遍历）</li><li>本质上就是倒过来的先序遍历</li></ul><p>剑指offer 33、二叉搜索树的后序遍历</p><ul><li><p>经典传递数组边界：（我的做法）</p><ul><li><p>对于一个二叉搜索树的后序遍历来说，左右根，所以从最后一个结点往前会存在一部分B，使得B中所有的元素都大于根节点</p><p>，剩下的部分A则存在所有的元素都小于根节点，由此可以调整数组的边界，使用递归可以实现判断</p></li></ul></li><li><p>正规的做法是：</p><ul><li><strong>埋坑</strong>（第二种做法确实看不懂….）</li></ul></li></ul><p>剑指offer 36、二叉搜索树与双向链表</p><ul><li>这道题背就完事了</li><li>这道题需要好好的看一遍题解去思考消化</li></ul><p>面试题04.02、最小高度树（利用二叉搜索树性质，每次去数组中间的值作为节点的值）</p><br><br><br><h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p>110、平衡二叉树（<strong>自底向上</strong>的思考，如果当前的树不是，那上面的树也不是了，就往上走即可）</p><ul><li>这里有个小trick，就是如果当前节点确定了不是平衡二叉树，那么就返回-1</li></ul><br><br><br><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>96、不同的二叉搜索树（动态规划，每次都枚举左边可能有多少个，右边可能有多少个，然后相乘得到结果）</p><p>112、路径总和（经典dfs，发现targetsum为0，并且是叶子节点，就返回）</p><p>113、路径总和II（经典dfs，需要注意的就是每次放入元素后，在退出函数的时候要把元素pop_back；理解上就是，你左边走完了，当然要退回一步，然后让右边继续往下走）</p><p>114、二叉树展开为链表（这里可以延伸一下变为中序遍历，变为后序遍历的时候该咋写）</p><p>116、填充每个节点的下一个右侧节点指针</p><ul><li>对于每个点，用solve（dfs函数）不断的递归</li></ul><p>117、填充每个节点的下一个右侧节点指针II</p><ul><li>依次遍历每一层，然后记录每个点的前一个点nodepre，让nodepre的next指向自己，然后再把自己变为nodepre</li></ul><p>129、求根节点到叶节点数字之和（经典dfs）</p><ul><li>镜像：剑指offer II 049.从根节点到叶节点的路径数字之和</li><li>可以选择用一个res记录总和，也可以每次都将相加后返回</li></ul><p>226、翻转二叉树（模拟）</p><p>剑指offer27 二叉树的镜像</p><ul><li>可以使用一个节点来实现翻转</li></ul><p>404、左叶子之和</p><ul><li>方法一：用flag来判断是不是左节点</li><li>方法二：对于每个节点，都判断他的左节点，然后相加</li></ul><p>543、二叉树的直径</p><ul><li>遍历每个节点，每次的最大值都是左值加上右值（最大值用全局变量来维护）</li></ul><p>863、二叉树中所有距离为 K 的结点</p><ul><li>用哈希表实现dfs，真的巧妙啊！！！！！</li></ul><p>993、二叉树的堂兄弟节点</p><ul><li>比较层数和父母即可</li></ul><p>剑指offer 34 二叉树中和为某一值得路径</p><ul><li>dfs+记录状态</li></ul><p>字节面试题：二叉树中任意两节点之间的最短路径（给定两点，求它们之间的最短路径）</p><ul><li>思路：先找到两个点的最近公共祖先，然后再用dfs就该祖先到两点距离，最后相加</li></ul><p>nowcoder经典笔试题</p><ul><li>找到二叉树中的最大搜索二叉子树</li></ul><br><br><br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>深搜 -&gt; dfs递归</li><li>广搜 -&gt; 层序遍历队列</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> BinaryTree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep into Sort</title>
      <link href="/2022/10/09/deep-into-sort/"/>
      <url>/2022/10/09/deep-into-sort/</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序（QuickSort）"><a href="#快速排序（QuickSort）" class="headerlink" title="快速排序（QuickSort）"></a>快速排序（QuickSort）</h1><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归版本（非稳定版）"><a href="#递归版本（非稳定版）" class="headerlink" title="递归版本（非稳定版）"></a>递归版本（非稳定版）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*arr为需要排序的数组，left为左边界，right为右边界*/</span><span class="token keyword">void</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*当前只有一个数（或边界left>right）的时候，就不需要排序了*/</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*选取位于最左边的数作为排序的标准，i从左边开始，j从右边开始*/</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">=</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// int temp = nums[rand() % (right - left) + left];//可以rand的选值</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*从左边开始，寻找大于等于temp的数*/</span>        <span class="token keyword">do</span> i <span class="token operator">++</span> <span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*从右边开始，寻找小于等于temp的数*/</span>        <span class="token keyword">do</span> j <span class="token operator">--</span> <span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*交换数字*/</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/*对左边的部分进行快排*/</span>    <span class="token function">quick_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*对右边的部分进行快排*/</span>    <span class="token function">quick_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><p>1、一次完整的遍历后，<code>arr[j]</code>和<code>temp</code>的关系</p><ul><li><code>arr[j] &lt;= temp</code></li><li>为什么选取j而不选取i作为判断标准：因为需要保证j和j+1都不会越界，而i和i-1可能会越界</li></ul><br><p>2、<code>left&lt;=right</code>可否改为<code>left==right</code></p><ul><li>不可以，如果当前数组没有元素的话，下面取值temp的时候就会因此越界</li></ul><br><p>3、<code>while(i&lt;j)</code>可否换为<code>i&lt;=j</code></p><ul><li>不可以。有可能会越界，例如：9，8</li><li>在第一轮遍历后，此时i和j是相等的，都是0，都指向9的位置</li><li>而在第二轮的时候<code>i++</code>，到8的位置，接着取值再++的时候就越界</li></ul><br><p>4、<code>quick_sort(arr, left, j)</code>可不可以改为<code>quick_sort(arr, left, i)</code>（或者<code>quick_sort(arr,j+1,right)</code>改为<code>quick_sort(arr,i + 1, right)</code>）</p><ul><li>不可以。因为有可能会陷入死循环，例：9，8，7，6，5，4，3，2，9</li><li>此时temp选择了9，则第一轮的时候会交换9和9两个数（一个是左边的9，另一个是右边的9）</li><li>而在第二轮的时候，位于左边的i会一直递增到此时9的位置（右边的9），而此时右边的j会先往左走一步，停在此时2的位置</li><li>而因为此时<code>i&gt;j</code>，所以退出循环</li><li>即9，8，7，6，5，4，3，2，9，此时的i是指在9的位置的（是右边的9），j 是指在2的位置</li><li>而如果使用的是以i为参考边界的话，那么就会变成<code>quick_sort(arr,0,8)</code>和<code>quick_sort(arr,9,8)</code>，这里右边的肯定是不行的</li><li>于是又变成了重新quick_sort原来的部分了，这样就会陷入无穷无尽的循环了</li><li>而如果用j作为参考边界的话，就可以有效地分开两边（<code>quick_sort(arr,0,7)</code>和<code>quick_sort(arr,8,9)</code>）</li><li>总结，对于i和j的位置统计，最后只会出现两种情况，第一种是i和j相同，第二种则是j在前，i在后<ul><li>其次，一定要选择 j 和 j+1 作为参考，选择i的话就有可能陷入死循环</li></ul></li></ul><br><p>5、<code>arr[i]&lt;temp</code>可不可以换为<code>arr[i]&lt;=temp</code>（或者<code>arr[j]&gt;temp</code>可不可以换为<code>arr[j]&gt;=temp</code>）</p><ul><li>不可以。对于一些数据，可能会出现越界的错误，例：9，8，7，6，5，4，3，2，1</li><li>假如此时temp选择了9，那么就会导致i一直往右走，而这里是没有对i的范围进行限定的，导致最后越界报错（反之也是一样的）</li></ul><br><h3 id="递归版本（稳定版）"><a href="#递归版本（稳定版）" class="headerlink" title="递归版本（稳定版）"></a>递归版本（稳定版）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">quick_sort_stable</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> left<span class="token punctuation">,</span> b <span class="token operator">=</span> right<span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">temp</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//  用于拷贝的数组</span>    <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> end <span class="token operator">=</span> temp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> e <span class="token operator">=</span> right<span class="token punctuation">,</span> s <span class="token operator">=</span> left<span class="token punctuation">;</span>    <span class="token keyword">int</span> privot <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">>=</span> privot<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//  从右往左移动</span>            nums<span class="token punctuation">[</span>e<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>right<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> privot<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//  从左往右移动</span>            nums<span class="token punctuation">[</span>s<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            temp<span class="token punctuation">[</span>start<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 大的移到temp数组左段</span>            temp<span class="token punctuation">[</span>end<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>right<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 小的移到temp数组的右段</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> temp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        nums<span class="token punctuation">[</span>s<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        nums<span class="token punctuation">[</span>e<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">quick_sort_stable</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> a<span class="token punctuation">,</span> s <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">quick_sort_stable</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> s <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>挖坑</strong>（问到的比较少；有点没看懂）</p><br><h3 id="非递归版本"><a href="#非递归版本" class="headerlink" title="非递归版本"></a>非递归版本</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*arr为需要排序的数组*/</span><span class="token keyword">void</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*栈用于记录需要排序的区间，存储的分别是left和right两个端点的下标*/</span>    stack<span class="token operator">&lt;</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">>></span> s<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*先初始化栈，放入数组的头尾下标*/</span>    s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*如果栈不为空，就代表还有没排序好的数据*/</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*获取栈顶的数据区间*/</span>        array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">></span> a<span class="token punctuation">{</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*下列会对该区间排序，所以就把其弹出*/</span>        s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*左边界小于右边界*/</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/*基本的快排*/</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">do</span> i <span class="token operator">++</span> <span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">do</span> j <span class="token operator">--</span> <span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">/*将区间再分为两个区间，然后再排序*/</span>            s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> j<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="稳定性分析"><a href="#稳定性分析" class="headerlink" title="稳定性分析"></a>稳定性分析</h2><ul><li>非稳定排序（可以参考每次选出的哨兵temp，一开始是在左边，交换后都到了右边）</li></ul><br><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><h3 id="最优的情况"><a href="#最优的情况" class="headerlink" title="最优的情况"></a>最优的情况</h3><ul><li><p>每次都能刚好二分，即确认第一个数需要遍历n个数，确认第二个数需要遍历n&#x2F;2个数，确认第三个数需要遍历n&#x2F;4个数字</p></li><li><p><img src="/medias/Deep-into-Sort/%E5%BF%AB%E6%8E%92%E6%9C%80%E4%BC%98%E6%83%85%E5%86%B5.png"></p></li><li><p>总共有log2n层</p></li><li><p>假设每一层都要遍历n个数，时间复杂度便是nlog2n</p></li></ul><br><h3 id="最坏的情况"><a href="#最坏的情况" class="headerlink" title="最坏的情况"></a>最坏的情况</h3><ul><li><p>每次都选中的是最大或最小的那个数，即确认第一个数需要遍历n个数，确认第二个数需要遍历n-1个数，确认第三个数字需要遍历n-2个数</p></li><li><p>求和后时间复杂度为n^2</p></li></ul><br><p><strong>结论：最好和平均都是O（nlog2n），最坏则是O（n^2）</strong></p><br><h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><ul><li><strong>O（1）</strong></li></ul><br><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>1、在选择哨兵的时候使用<strong>三数取中法</strong>，先取序列第一个元素、中间元素以及最后一个元素，再取这三个元素的中位数作为哨兵，可以避免取到边缘值而导致每次分割不均匀的情况（或者每次都随机选择元素）</p><p>2、因为在递归分割序列时，序列的长度会越来越短，又因为短序列排序中插入排序效率最高，所以可以设定一个阈值，当序列长度分割到阈值时切换为<strong>插入排序</strong></p><p>3、当序列中存在大量相同元素，或者全是相同元素时，使用快排仍然会得到最低效率，这时可以采用聚集相等元素的方法，每次选择哨兵后，将与哨兵相同的元素放到序列中间，下次分割时中间这些值不参与分割</p><p>4、当递归层数过深的时候改用<strong>堆排序</strong>，虽然第一个优化方法避免了取到边缘哨兵，但还是有可能取到较边缘的哨兵，最坏的情况会导致递归层数过深，从而降低快排效率，所以每次递归要判断递归层数，达到一定深度就改用堆排序。（这是<strong>STL源码</strong>里实现的方法。之所以要用堆排序，我猜想可能是因为快排和归并都是基于递归的排序，此时递归深度已经太深，肯定不能再用了，而对于较长的序列使用插入排序效率也不是太高，所以选择了堆排序）</p><br><br><br><h1 id="冒泡排序（BubbleSort）"><a href="#冒泡排序（BubbleSort）" class="headerlink" title="冒泡排序（BubbleSort）"></a>冒泡排序（BubbleSort）</h1><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*arr为需要排序的数组*/</span><span class="token keyword">void</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*check为哨兵，如果没有出现数据交换，证明数据都是有序的，退出循环*/</span>    <span class="token keyword">bool</span> check <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*寻找第一大，第二大，第三大..的数据*/</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*挨个挨个的比较数据*/</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                check <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/*没有发生数据交换，退出循环*/</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>check<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="稳定性分析-1"><a href="#稳定性分析-1" class="headerlink" title="稳定性分析"></a>稳定性分析</h2><ul><li>是稳定排序（但如果是<code>arr[j] &gt;= arr[j + 1]</code>就不是稳定排序了）</li></ul><br><h2 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><ul><li>最好是O（n）（没有哨兵的优化就是O（n ^ 2）），最坏和平均都是O（n ^ 2）</li></ul><br><h2 id="空间复杂度分析-1"><a href="#空间复杂度分析-1" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><ul><li><strong>O（1）</strong></li></ul><br><h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h2><ul><li>每一次二级循环都放置一个哨兵，如果flag不变，则说明有序，就不用继续排序了</li></ul><br><br><br><h1 id="归并排序（MergeSort）"><a href="#归并排序（MergeSort）" class="headerlink" title="归并排序（MergeSort）"></a>归并排序（MergeSort）</h1><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*如果右边边界小于等于左边边界，退出排序*/</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*对左边数据排序*/</span>    <span class="token function">merge_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*对右边数据排序*/</span>    <span class="token function">merge_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*这里假设数据左右数据都排好序了，进行归并操作*/</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">,</span> j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*        temp用来存储中途的数据，这里原代码是作为一个全局变量        i从左边开始，j从中间开始        分别将数据按大小放入temp中    */</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> tmp<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*哪一边的比较小，就放入哪一边的数*/</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> tmp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i <span class="token operator">++</span> <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果这里把=归到else这里，那么就不是稳定排序了    </span>        <span class="token keyword">else</span> tmp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j <span class="token operator">++</span> <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//可能左边或右边的数没有全部放完，于是用while把数据全部放进去</span>       <span class="token comment" spellcheck="true">//ps：左边和右边只可能有一边的数据没有完全放完</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> tmp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i <span class="token operator">++</span> <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> tmp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j <span class="token operator">++</span> <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*把排好序的数据放回arr中*/</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> t<span class="token operator">:</span> tmp<span class="token punctuation">)</span> arr<span class="token punctuation">[</span>left <span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h3 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h3><ul><li>to do：<a href="https://www.cnblogs.com/nullzx/p/5968170.html" target="_blank" rel="noopener">https://www.cnblogs.com/nullzx/p/5968170.html</a></li></ul><br><h2 id="稳定性分析-2"><a href="#稳定性分析-2" class="headerlink" title="稳定性分析"></a>稳定性分析</h2><ul><li>是稳定排序（但可以修改等号来更改其是否稳定，参考代码的注解）<ul><li>如果相等的时候取值左边，那就是稳定排序，否则就是不稳定排序</li></ul></li></ul><br><h2 id="时间复杂度分析-2"><a href="#时间复杂度分析-2" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><ul><li>假设一开始有n个数，每次对半的整理排序</li><li><img src="/medias/Deep-into-Sort/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%88%86%E6%9E%90.png"></li><li>那每一层需要排序的时间就是n，而又已知T(1)&#x3D;0，所以现在只要求解这颗二叉树的层数即可</li><li>而二叉树的层数是log2n+1，去掉第一行就是log2n</li><li>所以最好和最坏的时间复杂度都是O（nlogn）</li></ul><br><h2 id="空间复杂度分析-2"><a href="#空间复杂度分析-2" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><ul><li>O（n）（需要额外的空间放置排序好的数组）</li></ul><br><br><br><h1 id="堆排序（HeapSort）"><a href="#堆排序（HeapSort）" class="headerlink" title="堆排序（HeapSort）"></a>堆排序（HeapSort）</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>堆，是具有以下性质的<strong>完全二叉树</strong>：</p><ul><li><p>每个结点的值都大于或等于其左右孩子结点的值，称为<strong>大根堆</strong></p></li><li><p>每个结点的值都小于或等于其左右孩子结点的值，称为<strong>小根堆</strong></p></li></ul><p>如何在一个完全二叉树组成的数组中，对于其中一个结点，找到它的叶子结点：</p><ul><li>对于一层中的最左边的结点i，他到最右边的结点之间是差了i的，参考2的n+1次方和2的n次方的关系，这里的i就相当于2的n次方，最后一个节点就相当于2的n+1次方</li></ul><p>对于大根堆，选择都是选择当前结点，两个子节点中三者的最大值作为父母结点</p><p>一个完全二叉树的最后一个非叶子节点的下标是n &#x2F; 2 - 1（数组是从0开始计数的）（<a href="https://blog.csdn.net/weixin_41558411/article/details/104950162" target="_blank" rel="noopener">证明过程</a>）</p><p>构建堆的时间复杂度是O(n)（<a href="https://blog.csdn.net/qq_52433890/article/details/121502538" target="_blank" rel="noopener">证明过程</a>）</p><br><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//构建大根堆</span><span class="token keyword">void</span> <span class="token function">create_heap</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>arr<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> max <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//这里需要判断l和r是否小于n，因为是完全二叉树，有可能出现没有子节点的情况</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>max<span class="token punctuation">]</span><span class="token punctuation">)</span> max <span class="token operator">=</span> l<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>max<span class="token punctuation">]</span><span class="token punctuation">)</span> max <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>max <span class="token operator">!=</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>max<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">create_heap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> max<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//堆排序</span><span class="token keyword">void</span> <span class="token function">heap_sort</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//构建大根堆（因为是完全二叉树，所以从n/2-1的位置开始构造）</span>    <span class="token comment" spellcheck="true">//证明：设数组的长度为n，最后一个父母结点是从头开始数的第n/2-1的那个数（可以自己画一个图去求证）</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">create_heap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//每次将最大的元素放到最后，然后重新构建堆</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">create_heap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="稳定性分析-3"><a href="#稳定性分析-3" class="headerlink" title="稳定性分析"></a>稳定性分析</h2><ul><li>非稳定排序<ul><li>其实heapsort是否为稳定排序是一个很难评定的事情，因为每次重建堆都会修改数据的顺序..，所以一般认为是非稳定排序</li></ul></li></ul><br><h2 id="时间复杂度分析-3"><a href="#时间复杂度分析-3" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><ul><li><p>每次构建堆都是logn的时间复杂度，n个数就是nlogn</p></li><li><p><strong>最好最坏平均都是O（nlogn）</strong></p></li></ul><br><h2 id="空间复杂度分析-3"><a href="#空间复杂度分析-3" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><ul><li><strong>O(1)</strong></li></ul><br><br><br><h1 id="插入排序（InsertSort）"><a href="#插入排序（InsertSort）" class="headerlink" title="插入排序（InsertSort）"></a>插入排序（InsertSort）</h1><h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">insert_sort</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*设定0到i-1范围内的数据都是已经排好序了的*/</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*现在就需要将arr[i]放入到已经排好序了的数组中，可以理解为将当前的数据插入到前面的数组中*/</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">)</span><span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="稳定性分析-4"><a href="#稳定性分析-4" class="headerlink" title="稳定性分析"></a>稳定性分析</h2><ul><li>是稳定排序</li></ul><br><h2 id="时间复杂度分析-4"><a href="#时间复杂度分析-4" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><h3 id="最优的情况-1"><a href="#最优的情况-1" class="headerlink" title="最优的情况"></a>最优的情况</h3><ul><li>数组本身就是有序的，因此就不需要调整数据的位置，在第二个for中会进行break</li><li>此时的时间复杂度是O（n）</li></ul><br><h3 id="最坏的情况-1"><a href="#最坏的情况-1" class="headerlink" title="最坏的情况"></a>最坏的情况</h3><ul><li>数组有序，但是是和我们想要的顺序是相反的，因此每次循环都需要把数据全部往后挪</li><li>此时的时间复杂度是O（n^2）</li></ul><br><h2 id="空间复杂度分析-4"><a href="#空间复杂度分析-4" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><ul><li><strong>O（1）</strong>，不需要额外的空间</li></ul><br><br><br><h1 id="选择排序（SelectSort）"><a href="#选择排序（SelectSort）" class="headerlink" title="选择排序（SelectSort）"></a>选择排序（SelectSort）</h1><h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">select_sort</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*每次选取当前第i大的数据，并把它放到后面*/</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> record <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*在0-i的范围内选取当前的最大值*/</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> maxn <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>maxn <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                record <span class="token operator">=</span> j<span class="token punctuation">;</span>                maxn <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/*交换到它应对的位置*/</span>        std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>record<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="稳定性分析-5"><a href="#稳定性分析-5" class="headerlink" title="稳定性分析"></a>稳定性分析</h2><ul><li>非稳定排序</li></ul><br><h2 id="时间复杂度分析-5"><a href="#时间复杂度分析-5" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><ul><li>无论数组是否有序，每次为了寻找当前的最大值，都必须要遍历一遍前面的数组</li><li>因此时间复杂度上，最好和最坏都是O（n^2）</li></ul><br><h2 id="空间复杂度分析-5"><a href="#空间复杂度分析-5" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><ul><li><strong>O（1）</strong>，不需要额外的空间</li></ul><br><br><br><h1 id="希尔排序（ShellSort）"><a href="#希尔排序（ShellSort）" class="headerlink" title="希尔排序（ShellSort）"></a>希尔排序（ShellSort）</h1><h2 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">shell_sort</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> increment <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*本质上还是插入排序*/</span>    <span class="token comment" spellcheck="true">/*但是这里是对以increment为单位，得到的数组，对其进行插入排序*/</span>    <span class="token comment" spellcheck="true">/*从 局部有序到全体有序*/</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        increment <span class="token operator">=</span> increment <span class="token operator">/</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> increment<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>i <span class="token operator">-</span> increment<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> mid <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> increment<span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> mid <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">-</span><span class="token operator">=</span> increment<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    arr<span class="token punctuation">[</span>j <span class="token operator">+</span> increment<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> mid<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>increment <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="稳定性分析-6"><a href="#稳定性分析-6" class="headerlink" title="稳定性分析"></a>稳定性分析</h2><ul><li>本质上还是选择排序，所以也是非稳定性排序</li></ul><br><h2 id="时间复杂度分析-6"><a href="#时间复杂度分析-6" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><ul><li><strong>最好是O（n），平均是O（n^1.3）， 最坏是O（n^2）</strong></li></ul><br><h2 id="空间复杂度分析-6"><a href="#空间复杂度分析-6" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><ul><li>O（1）</li></ul><br><br><br><h1 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="23、合并K个升序链表"><a href="#23、合并K个升序链表" class="headerlink" title="23、合并K个升序链表"></a>23、合并K个升序链表</h3><br><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ul><li>Top K</li><li><a href="https://blog.csdn.net/u013309870/article/details/70196537" target="_blank" rel="noopener">打印n个数组中最大的Top k</a></li><li>出现频率前k名的数据</li></ul><br><h2 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h2><h3 id="215、数组中的第K个最大元素"><a href="#215、数组中的第K个最大元素" class="headerlink" title="215、数组中的第K个最大元素"></a>215、数组中的第K个最大元素</h3><p>镜像：剑指 Offer II 076. 数组中的第 k 大的数字</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//方法一：快速选择</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token function">quick_select</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">// 这里为什么不可以下面不调整left和idx的位置，然后直接返回nums[left]</span>              <span class="token comment" spellcheck="true">// 因为调整idx和left的位置另一个作用便是方便后续left和right调整位置</span>              <span class="token comment" spellcheck="true">// 更准确的说是为了调整好right的位置</span>              <span class="token comment" spellcheck="true">// 因为left直接跳过了idx包括idx的前面的全部部分</span>              <span class="token comment" spellcheck="true">// 而right会继续到idx前面的部分查找</span>              <span class="token comment" spellcheck="true">// 如果此时不调整位置的话，那么会出现两种情况：</span>              <span class="token comment" spellcheck="true">// 第一种情况，right=idx，然后就会直接死循环（因为一直都以left为标准调整）</span>              <span class="token comment" spellcheck="true">// 第二种情况right=idx-1，那么极有可能错过前面的数字，导致误判第k个大小的数）</span>                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> idx <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">quick_select</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token operator">++</span> idx<span class="token punctuation">;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> idx<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//方法二：魔改快排</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> mid <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span><span class="token operator">++</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span><span class="token operator">--</span> j<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//这里没写出来，需要注意的就是i和j最后的位置问题</span>        <span class="token comment" spellcheck="true">//第一种情况，i==j;第二种情况j=i-1</span>        <span class="token comment" spellcheck="true">//至于为什么要用j来表示，可以参考上面快排的注解</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> right <span class="token operator">-</span> j<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">>=</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k <span class="token operator">-</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h3 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a>剑指 Offer 40. 最小的k个数</h3><p>镜像：面试题 17.14. 最小K个数</p><p>PS：找最小的k个数（或最小的第k个数），和找最大的k个数（或最大的第k个数）的区别，就是<strong>找最小的时候，可以直接用当前的坐标值进行判断</strong>（当前做坐标是i，就代表左边有i个数），而不改变k值；而<strong>找最大的k个数时，是不能根据坐标判断</strong>（当前坐标是i，但是不知道右边还有多少个数字），因此要修改k值</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//方法一：魔改快排（递归版）</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">getLeastNumbers</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">quick_sort_k</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">quick_sort_k</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> mid <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">do</span> <span class="token operator">++</span> i<span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">do</span> <span class="token operator">--</span> j<span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">quick_sort_k</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">quick_sort_k</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//方法二：魔改快排（非递归版）</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">smallestK</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> mid <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">do</span> <span class="token operator">++</span> i<span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">do</span> <span class="token operator">--</span> j<span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h3 id="973、最接近原点的K个点"><a href="#973、最接近原点的K个点" class="headerlink" title="973、最接近原点的K个点"></a>973、最接近原点的K个点</h3><p>重写cmp函数即可</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">kClosest</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> points<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">auto</span> cmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> p1<span class="token punctuation">,</span> <span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> p2<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> r1 <span class="token operator">=</span> p1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> p1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> p1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> p1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> r2 <span class="token operator">=</span> p2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> p2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> p2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> p2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> r1 <span class="token operator">&lt;=</span> r2<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> points<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> mid <span class="token operator">=</span> points<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> left<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">cmp</span><span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token operator">++</span> idx<span class="token punctuation">;</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>points<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">,</span> points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>points<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> points<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">(</span>points<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> points<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">></span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> idx <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><br><br><h1 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h1><img src="/medias/Deep-into-Sort/排序算法的复杂度总结.png" style="zoom:150%;"><ul><li><strong>不稳定的排序只有：希尔排序，选择排序，堆排序，快速排序</strong></li></ul><br><p>对于有序的数据，哪种排序算法比较高效？</p><ul><li>冒泡排序和插入排序，在有序数据的情况下都是O（n）</li></ul><br><p>插入排序在什么时候比快速排序要高效？</p><ul><li>当数组大致有序的时候，移动的数据比较少，时间上就会趋于O（n）</li></ul><br><p>计数排序可以做到在数据稠密（重复数字比较多）的情况下，时间趋于O（n）</p><br><p>稳定性的定义：</p><ul><li>假定在待排序的记录序列中，存在多个具有相同的关键字的记录</li><li>若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]&#x3D;r[j]，且r[i]在r[j]之前</li><li>而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的</li></ul><br><p>为什么要区分稳定排序和非稳定排序？</p><ul><li>比如说有一份数据，是按照学号排好序了的，现在要再按照身高排序，同时要求如果遇到相同身高的就要按照学号排序</li><li>那么此时就需要用稳定排序进行排列，直接一步到位</li><li>即<strong>稳定排序可以让第一个关键字排序的结果服务于第二个关键字中数值相等的那些数</strong></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
