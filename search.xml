<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Deep into BinaryTree</title>
      <link href="/2022/10/10/deep-into-binarytree/"/>
      <url>/2022/10/10/deep-into-binarytree/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的基本性质"><a href="#二叉树的基本性质" class="headerlink" title="二叉树的基本性质"></a>二叉树的基本性质</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>二叉搜索树的基本性质，二叉树前中后序遍历的特性，完全二叉树的性质</li><li>从前，中遍历或中，后遍历能够推出二叉树</li><li>关于节点数量的规律：设非空二叉树中度为0、1和2的结点个数分别为n0、n1和n2，则有 <strong>n0 = n2 + 1</strong><ul><li>即叶子结点比二分支结点多一个</li></ul></li></ul><br><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>100、相同的树（两边dfs）</p><p>101、对称二叉树（两边dfs）</p><p>104、二叉树的最大深度（dfs）</p><p><strong>124</strong>、二叉树的最大路径和</p><ul><li>最大路径和的两种情况：<ul><li>1、从当前节点出发，只走左子树或右子树</li><li>2、从左子树的某一处出发，经过当前节点，然后到达右子树的某一处</li></ul></li><li>问题就转化为如何用同一套代码能够将这两种情况都包含，或是说二者的共同点在哪儿</li><li>思路：为什么会出现只走左/右子树，是因为走左/右子树只能得到小于等于0的结果；因此得到一个思路，在寻找最大路径和的时候，左子树给出的结果应该是<code>max(0,dfs(root -&gt; left))</code></li><li>整体逻辑：设置全局变量maxn，设最开始的<code>maxn为root -&gt; val</code>（如果nullptr就返回0）</li><li>分别对各个点进行左右遍历，得到<code>left = max(0, dfs(root -&gt; left))</code>和<code>right = max(0, dfs(root -&gt; right))</code></li><li>然后，得到<code>max1 = left + right + root -&gt; val</code>，<code>maxn = max(max1, maxn)</code>，最后，当前函数需要返回<code>root -&gt; val + max(left, right)</code>（因为当前节点又会被上一层给调用）</li><li>这种逐层递归的好处，是可以枚举每个节点遇到上述情况时候的取值，从而得到全体最大值</li></ul><p>236、二叉树的最近公共祖先</p><ul><li>先判断当前的节点是不是目标节点之一（或者是不是nullptr），如果是就直接返回</li><li>否则就判断左边和右边，如果左边是空的，那就证明必然是右边，反之也是一样</li><li>如果两边都不是空的话，就代表两个节点在当前节点的两侧，直接返回当前节点</li></ul><p>257、二叉树的所有路径（字符串+经典的dfs）</p><p>572、另一棵树的子树（子树的定义）</p><ul><li>子树的定义：对于一个节点，二者都是null，ok；原树有、新树没有，或者原树没有，新树有，error</li></ul><p><strong>543</strong>、二叉树的直径</p><ul><li>二叉树的最长直径的两种情况<ul><li>1、从当前节点出发，只走左子树或右子树</li><li>2、从左子树的某一处出发，经过当前节点，然后到达右子树的某一处</li></ul></li><li>和687，124都是一模一样的套路</li></ul><p>617、合并二叉树（DFS，需要注意空节点）</p><p>653、两数之和 IV（输入BST）（剑指offerII 56 二叉搜索树中两个结点之和）：哈希表+前序遍历即可</p><p>671、二叉树中第二小的节点（读题仔细，dfs解决，老套路了）</p><p><strong>687</strong>、最长同值路径</p><ul><li>二叉树的最长同值路径的两种情况<ul><li>第一种：从该点出发，只走左子树或右子树</li><li>第二种：从左子树的某一处出发，经过该节点，然后到达右子树的某一处</li></ul></li><li>和543，124都是一模一样的套路</li><li>需要注意一点的是，要传入上一个结点的number，通过当前的root-&gt;val和number来判断要返回的是0还是其他的</li></ul><p>814、二叉树剪枝（自底向上的遍历，和之前一道题很像，忘了是那一道，后续看看）</p><ul><li>剑指offer II 047.二叉树剪枝（一模一样的）</li></ul><p>951、翻转等价二叉树（感觉和验证两个二叉树是否相等一样，都是比较左右节点的题目）</p><p>剑指offer 26 树的子结构</p><ul><li>对于每个点都判断是否为目标二叉树</li><li>一定要注意树的子结构和树的子树是不一样的：</li><li>如果是子树，就必须要求两棵树上所有的结点都要能够对上（原树为空，目标树必须为空；原树有结点，目标树也得有结点）（目标树为空，原树必须也为空；目标书有节点，原树必须也有结点）</li><li>如果是子结构，只要目标树有的原树都有，就行了（原树为空，目标树必须为空；原树有结点，目标树可以没有结点）（如果目标树为空，那么原来的树有没有结点都无所谓；如果目标树有结点，原树必须也有结点）</li></ul><br><br><br><h1 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ul><li>树的层序遍历，即广度优先搜索；或者在层序遍历的时候，添加一些其他的操作</li></ul><br><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul><li>建立一个queue，最开始将第一个root点放入队列，进行我们想要的操作（求最大值、平均值、最左边的数）</li><li>注意此时一开始是用一个node记录此时的queue.front()，接着把这个点从队列中pop</li><li>操作完后，就把该点的左右结点给放入队列中；递归循环上述操作</li><li>踩坑：for循环中要用一个size记录初始队列的大小，因为随着后续的元素不断放入，size会改变的<ul><li>或者从后往前遍历也是可以的</li></ul></li></ul><br><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p>102、二叉树的层序遍历（层序遍历）</p><p>103、二叉树的锯齿形层序遍历（层序遍历；根据深度反转数组）</p><p>111、二叉树的最小深度（用层序遍历记录floor；也可以用递归求解）</p><p>199、二叉树的右视图（层序遍历；每次只取最后一个数）</p><p>222、完全二叉树的节点个数（层序遍历；遇到nullptr就break）</p><p>429、N叉树的层序遍历（层序遍历）</p><p>513、找树左下角的值（层序遍历，记录每次出现的第一个值）</p><p>515、在每个树行中找最大值（层序遍历；记录行max）</p><p>637、二叉树的层平均值（层序遍历；求avg）</p><p>662、二叉树的最大宽度（用两个队列来实现层序遍历；或者用一个新的结构体Node，同时记录节点的val和节点的指针，放入左节点就是* 2，放入右节点就是 *2 + 1；最后注意防越界，用unsigned long long即可）</p><p>958、二叉树的完全性检验（层序遍历；根据完全二叉树的性质，一旦遇到nullptr，后面就不应该有节点了，否则就不是完全二叉树；用一个flag来表示是否遇到了nullptr）</p><p>1609、奇偶树（层序遍历；根据奇偶做不同的处理）</p><p>面试题 04.03、 特定深度节点链表（层序遍历生成链表）</p><p>剑指offer 32、从上到下打印二叉树（层序遍历）</p><p>剑指offer II 044.二叉树每层的最大值</p><p>剑指offer II 045.二叉树最底层最左边的值</p><p>剑指offer II 046.二叉树的右侧视图</p><br><br><br><h1 id="前中后序遍历"><a href="#前中后序遍历" class="headerlink" title="前中后序遍历"></a>前中后序遍历</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><ul><li>需要对树进行根左右，左根右，左右根的遍历，并且在每次遍历的时候添加其他操作</li></ul><br><h2 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h2><ul><li>遍历一般有两种方式来实现，第一种是递归，第二种是用栈模拟递归（挖坑：第三种遍历mirror遍历不会）</li></ul><br><h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h2><p>94、二叉树的中序遍历（递归/非递归版）</p><p>98、验证二叉搜索树</p><ul><li>这道题是用到了二叉搜索树的性质+中序遍历。即对于每棵树，根节点是大于左子树的节点的，右子树的节点是大于根节点的</li><li>然后联想到中序遍历是左根右的，所以就一方面维护一个pre节点，另一方面左根右的遍历，走完左子树，pre就变为左子树中的最大值（即左子树的右子树其中一个值），和根节点比较；走完根节点，pre就变为根节点，和右子树的左子树的最小值（即右子树的左子树其中一个值）进行比较）</li><li>这就是中序遍历的高深之处，始终维护着pre为一部分的最大值</li><li>这道题的做法无非就是中序遍历的变种（第一种是每次遍历都维护前面一个节点，第二种是递归得到全部的数组，第三种是stack维护前一个节点）</li></ul><p>105、从前序遍历与中序遍历构造二叉树</p><ul><li>模板题</li><li>关于右边界的问题，是否要取到右边界都是可以选择的，关键是你怎么写（我的做法中右边界是不可取值的）</li></ul><p>106、从中序遍历与后序遍历构造二叉树</p><ul><li>同105一样的思路，类似的题还有剑指 offer07</li></ul><p>144、二叉树的前序遍历（递归/非递归版）</p><p>145、二叉树的后序遍历（递归/非递归版；非递归实现思路，后序遍历是左右根，那么就相当于是根右左反过来，所以只要求得根右左，反转后便是结果）</p><p>589、N叉树的前序遍历（递归/非递归版）</p><p>590、N叉树的后序遍历（递归/非递归版）</p><p>872、叶子相似的树（非常巧妙地中序遍历输出叶子，然后对比）</p><p>剑指 offer36（<strong>挖坑</strong>）</p><p>原创题：二叉树的下一个节点（中序遍历；如果有右子树，就往右子树下面找，否则就往上找）</p><br><br><br><h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><ul><li>二叉搜索树的性质：中序遍历得到的数组是依次递增的，右左根得到的数组是依次递减的，当前节点的数字是大于左边而小于右边的</li></ul><br><h2 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h2><ul><li>中序遍历或者是右左根遍历，都可以用递归或stack来实现</li></ul><br><h2 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h2><p>95、不同的二叉搜索树 II（用递归分别求出左右两个子树，然后用两层循环嵌套生成二叉树）</p><p>98、验证二叉搜索树（利用二叉搜索树的性质，中序遍历的递归和非递归版，或者把中序遍历一遍二叉树，然后逐个逐个看是否大于前一个）</p><p>99、恢复二叉树（也是利用二叉树搜索树和中序遍历的性质，但是其中利用r1和r2的方法真的很绝，建议好好看看）</p><p>108、将有序数组转换为二叉搜索树（经典传递数组和数组边界，然后递归）</p><p>109、有序链表转换二叉搜索树（经典利用二叉搜索树的性质，取中间数作为节点，然后递归left和right）</p><p>230、二叉搜索树中第k小的元素</p><ul><li>中序遍历，每次得到元素的时候修改k，当k为0的时候return</li><li>或者dfs，本质上也是中序遍历</li></ul><p>235、二叉搜索树的最近公共祖先</p><ul><li>通过大小判断接下来遍历那一边的子树</li></ul><p>450、删除二叉树中的节点（非常经典的题目，既可以把左子树接到右子树的最左边的节点上，也可以把右子树接到左子树最右边的节点上）</p><p>530、二叉搜索树的最小绝对差（二叉搜索树的性质，中序遍历）</p><p>538、把二叉搜索树转换为累加树（1038.把二叉搜索树转换为累加树，剑指offer II 054.所有大于等于节点的值之和）</p><ul><li>这道题的思路很巧妙：用的是<strong>反向的中序遍历</strong>，先遍历右边，再处理root，最后遍历左边（其中还用了一个全局变量来维护右子节点的最大值）</li><li>思路和实现上都比较简单，但是很难想到如此的巧妙</li><li>而我的思路：<ul><li>对于一个节点本身来说，右子节点是用来给自身赋值的，所以，如果能往右边走，当前的值就是右边，就继续递归下去</li><li>如果不能，那就继承父类给的base（具体参考代码）</li><li>而对于左节点，如果左节点不能走，那以本节点为根节点的树的最大值就是root-&gt;val</li><li>如果能走，那就返回递归的左节点</li></ul></li></ul><p>669、修建二叉搜索树（利用二叉搜索树的性质，如果当前的值小于low，就把左子树砍掉，返回右子树；如果当前的值大于high，就把右子树砍掉，返回左子树）</p><p>701、二叉搜索树中的插入操作（二叉搜索树的性质）</p><p>783、二叉搜索树节点最小距离（同上）</p><p>897、递增顺序搜索树（利用二叉搜索树性质中序遍历建树）</p><p>938、二叉搜索树的范围和（利用二叉搜索树性质）</p><p>剑指offer 54、 二叉搜索树的第k大节点</p><ul><li>非递归的做法（右左根依次遍历，得到便是依次递减的数列，同时更新k值，递减到0为止）</li><li>递归的做法（递归实现右左根遍历）</li><li>本质上就是倒过来的先序遍历</li></ul><p>剑指offer 33、二叉搜索树的后序遍历</p><ul><li><p>经典传递数组边界：（我的做法）</p><ul><li><p>对于一个二叉搜索树的后序遍历来说，左右根，所以从最后一个结点往前会存在一部分B，使得B中所有的元素都大于根节点</p><p>，剩下的部分A则存在所有的元素都小于根节点，由此可以调整数组的边界，使用递归可以实现判断</p></li></ul></li><li><p>正规的做法是：</p><ul><li><strong>埋坑</strong>（第二种做法确实看不懂….）</li></ul></li></ul><p>剑指offer 36、二叉搜索树与双向链表</p><ul><li>这道题背就完事了</li><li>这道题需要好好的看一遍题解去思考消化</li></ul><p>面试题04.02、最小高度树（利用二叉搜索树性质，每次去数组中间的值作为节点的值）</p><br><br><br><h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p>110、平衡二叉树（<strong>自底向上</strong>的思考，如果当前的树不是，那上面的树也不是了，就往上走即可）</p><ul><li>这里有个小trick，就是如果当前节点确定了不是平衡二叉树，那么就返回-1</li></ul><br><br><br><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>96、不同的二叉搜索树（动态规划，每次都枚举左边可能有多少个，右边可能有多少个，然后相乘得到结果）</p><p>112、路径总和（经典dfs，发现targetsum为0，并且是叶子节点，就返回）</p><p>113、路径总和II（经典dfs，需要注意的就是每次放入元素后，在退出函数的时候要把元素pop_back；理解上就是，你左边走完了，当然要退回一步，然后让右边继续往下走）</p><p>114、二叉树展开为链表（这里可以延伸一下变为中序遍历，变为后序遍历的时候该咋写）</p><p>116、填充每个节点的下一个右侧节点指针</p><ul><li>对于每个点，用solve（dfs函数）不断的递归</li></ul><p>117、填充每个节点的下一个右侧节点指针II</p><ul><li>依次遍历每一层，然后记录每个点的前一个点nodepre，让nodepre的next指向自己，然后再把自己变为nodepre</li></ul><p>129、求根节点到叶节点数字之和（经典dfs）</p><ul><li>镜像：剑指offer II 049.从根节点到叶节点的路径数字之和</li><li>可以选择用一个res记录总和，也可以每次都将相加后返回</li></ul><p>226、翻转二叉树（模拟）</p><p>剑指offer27 二叉树的镜像</p><ul><li>可以使用一个节点来实现翻转</li></ul><p>404、左叶子之和</p><ul><li>方法一：用flag来判断是不是左节点</li><li>方法二：对于每个节点，都判断他的左节点，然后相加</li></ul><p>543、二叉树的直径</p><ul><li>遍历每个节点，每次的最大值都是左值加上右值（最大值用全局变量来维护）</li></ul><p>863、二叉树中所有距离为 K 的结点</p><ul><li>用哈希表实现dfs，真的巧妙啊！！！！！</li></ul><p>993、二叉树的堂兄弟节点</p><ul><li>比较层数和父母即可</li></ul><p>剑指offer 34 二叉树中和为某一值得路径</p><ul><li>dfs+记录状态</li></ul><p>字节面试题：二叉树中任意两节点之间的最短路径（给定两点，求它们之间的最短路径）</p><ul><li>思路：先找到两个点的最近公共祖先，然后再用dfs就该祖先到两点距离，最后相加</li></ul><p>nowcoder经典笔试题</p><ul><li>找到二叉树中的最大搜索二叉子树</li></ul><br><br><br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>深搜 -&gt; dfs递归</li><li>广搜 -&gt; 层序遍历队列</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> BinaryTree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep into Sort</title>
      <link href="/2022/10/09/deep-into-sort/"/>
      <url>/2022/10/09/deep-into-sort/</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序（QuickSort）"><a href="#快速排序（QuickSort）" class="headerlink" title="快速排序（QuickSort）"></a>快速排序（QuickSort）</h1><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归版本（非稳定版）"><a href="#递归版本（非稳定版）" class="headerlink" title="递归版本（非稳定版）"></a>递归版本（非稳定版）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*arr为需要排序的数组，left为左边界，right为右边界*/</span><span class="token keyword">void</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*当前只有一个数（或边界left>right）的时候，就不需要排序了*/</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*选取位于最左边的数作为排序的标准，i从左边开始，j从右边开始*/</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">=</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// int temp = nums[rand() % (right - left) + left];    //    可以rand的选值</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*从左边开始，寻找大于等于temp的数*/</span>        <span class="token keyword">do</span> i <span class="token operator">++</span> <span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*从右边开始，寻找小于等于temp的数*/</span>        <span class="token keyword">do</span> j <span class="token operator">--</span> <span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*交换数字*/</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*对左边的部分进行快排*/</span>    <span class="token function">quick_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*对右边的部分进行快排*/</span>    <span class="token function">quick_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><p>1、一次完整的遍历后，<code>arr[j]</code>和<code>temp</code>的关系</p><ul><li><code>arr[j] &lt;= temp</code></li><li>为什么选取j而不选取i作为判断标准：因为需要保证j和j+1都不会越界，而i和i-1可能会越界</li></ul><br><p>2、<code>left&lt;=right</code>可否改为<code>left==right</code></p><ul><li>不可以，如果当前数组没有元素的话，下面取值temp的时候就会因此越界</li></ul><br><p>3、<code>while(i&lt;j)</code>可否换为<code>i&lt;=j</code></p><ul><li>不可以。有可能会越界，例如：9，8</li><li>在第一轮遍历后，此时i和j是相等的，都是0，都指向9的位置</li><li>而在第二轮的时候<code>i++</code>，到8的位置，接着取值再++的时候就越界</li></ul><br><p>4、<code>quick_sort(arr, left, j)</code>可不可以改为<code>quick_sort(arr, left, i)</code>（或者<code>quick_sort(arr,j+1,right)</code>改为<code>quick_sort(arr,i + 1, right)</code>）</p><ul><li>不可以。因为有可能会陷入死循环，例：9，8，7，6，5，4，3，2，9</li><li>此时temp选择了9，则第一轮的时候会交换9和9两个数（一个是左边的9，另一个是右边的9）</li><li>而在第二轮的时候，位于左边的i会一直递增到此时9的位置（右边的9），而此时右边的j会先往左走一步，停在此时2的位置</li><li>而因为此时<code>i&gt;j</code>，所以退出循环</li><li>即9，8，7，6，5，4，3，2，9，此时的i是指在9的位置的（是右边的9），j 是指在2的位置</li><li>而如果使用的是以i为参考边界的话，那么就会变成<code>quick_sort(arr,0,8)</code>和<code>quick_sort(arr,9,8)</code>，这里右边的肯定是不行的</li><li>于是又变成了重新quick_sort原来的部分了，这样就会陷入无穷无尽的循环了</li><li>而如果用j作为参考边界的话，就可以有效地分开两边（<code>quick_sort(arr,0,7)</code>和<code>quick_sort(arr,8,9)</code>）</li><li>总结，对于i和j的位置统计，最后只会出现两种情况，第一种是i和j相同，第二种则是j在前，i在后<ul><li>其次，一定要选择 j 和 j+1 作为参考，选择i的话就有可能陷入死循环</li></ul></li></ul><br><p>5、<code>arr[i]&lt;temp</code>可不可以换为<code>arr[i]&lt;=temp</code>（或者<code>arr[j]&gt;temp</code>可不可以换为<code>arr[j]&gt;=temp</code>）</p><ul><li>不可以。对于一些数据，可能会出现越界的错误，例：9，8，7，6，5，4，3，2，1</li><li>假如此时temp选择了9，那么就会导致i一直往右走，而这里是没有对i的范围进行限定的，导致最后越界报错（反之也是一样的）</li></ul><br><h3 id="递归版本（稳定版）"><a href="#递归版本（稳定版）" class="headerlink" title="递归版本（稳定版）"></a>递归版本（稳定版）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">quick_sort_stable</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> left<span class="token punctuation">,</span> b <span class="token operator">=</span> right<span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">temp</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//  用于拷贝的数组</span>    <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> end <span class="token operator">=</span> temp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> e <span class="token operator">=</span> right<span class="token punctuation">,</span> s <span class="token operator">=</span> left<span class="token punctuation">;</span>    <span class="token keyword">int</span> privot <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">>=</span> privot<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//  从右往左移动</span>            nums<span class="token punctuation">[</span>e<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>right<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> privot<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//  从左往右移动</span>            nums<span class="token punctuation">[</span>s<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            temp<span class="token punctuation">[</span>start<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 大的移到temp数组左段</span>            temp<span class="token punctuation">[</span>end<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>right<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 小的移到temp数组的右段</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> temp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        nums<span class="token punctuation">[</span>s<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        nums<span class="token punctuation">[</span>e<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">quick_sort_stable</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> a<span class="token punctuation">,</span> s <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">quick_sort_stable</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> s <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>挖坑</strong>（问到的比较少；有点没看懂）</p><br><h3 id="非递归版本"><a href="#非递归版本" class="headerlink" title="非递归版本"></a>非递归版本</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*arr为需要排序的数组*/</span><span class="token keyword">void</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*栈用于记录需要排序的区间，存储的分别是left和right两个端点的下标*/</span>    stack<span class="token operator">&lt;</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">>></span> s<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*先初始化栈，放入数组的头尾下标*/</span>    s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*如果栈不为空，就代表还有没排序好的数据*/</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*获取栈顶的数据区间*/</span>        array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">></span> a<span class="token punctuation">{</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*下列会对该区间排序，所以就把其弹出*/</span>        s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*左边界小于右边界*/</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/*基本的快排*/</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">do</span> i <span class="token operator">++</span> <span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">do</span> j <span class="token operator">--</span> <span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">/*将区间再分为两个区间，然后再排序*/</span>            s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> j<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="稳定性分析"><a href="#稳定性分析" class="headerlink" title="稳定性分析"></a>稳定性分析</h2><ul><li>非稳定排序（可以参考每次选出的哨兵temp，一开始是在左边，交换后都到了右边）</li></ul><br><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><h3 id="最优的情况"><a href="#最优的情况" class="headerlink" title="最优的情况"></a>最优的情况</h3><ul><li><p>每次都能刚好二分，即确认第一个数需要遍历n个数，确认第二个数需要遍历n/2个数，确认第三个数需要遍历n/4个数字</p></li><li><p><img src="/medias/Deep-into-Sort/%E5%BF%AB%E6%8E%92%E6%9C%80%E4%BC%98%E6%83%85%E5%86%B5.png" alt></p></li><li><p>总共有log2n层</p></li><li><p>假设每一层都要遍历n个数，时间复杂度便是nlog2n</p></li></ul><br><h3 id="最坏的情况"><a href="#最坏的情况" class="headerlink" title="最坏的情况"></a>最坏的情况</h3><ul><li><p>每次都选中的是最大或最小的那个数，即确认第一个数需要遍历n个数，确认第二个数需要遍历n-1个数，确认第三个数字需要遍历n-2个数</p></li><li><p>求和后时间复杂度为n^2</p></li></ul><br><p><strong>结论：最好和平均都是O（nlog2n），最坏则是O（n^2）</strong></p><br><h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><ul><li><strong>O（1）</strong></li></ul><br><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>1、在选择哨兵的时候使用<strong>三数取中法</strong>，先取序列第一个元素、中间元素以及最后一个元素，再取这三个元素的中位数作为哨兵，可以避免取到边缘值而导致每次分割不均匀的情况（或者每次都随机选择元素）</p><p>2、因为在递归分割序列时，序列的长度会越来越短，又因为短序列排序中插入排序效率最高，所以可以设定一个阈值，当序列长度分割到阈值时切换为<strong>插入排序</strong></p><p>3、当序列中存在大量相同元素，或者全是相同元素时，使用快排仍然会得到最低效率，这时可以采用聚集相等元素的方法，每次选择哨兵后，将与哨兵相同的元素放到序列中间，下次分割时中间这些值不参与分割</p><p>4、当递归层数过深的时候改用<strong>堆排序</strong>，虽然第一个优化方法避免了取到边缘哨兵，但还是有可能取到较边缘的哨兵，最坏的情况会导致递归层数过深，从而降低快排效率，所以每次递归要判断递归层数，达到一定深度就改用堆排序。（这是<strong>STL源码</strong>里实现的方法。之所以要用堆排序，我猜想可能是因为快排和归并都是基于递归的排序，此时递归深度已经太深，肯定不能再用了，而对于较长的序列使用插入排序效率也不是太高，所以选择了堆排序）</p><br><br><br><h1 id="冒泡排序（BubbleSort）"><a href="#冒泡排序（BubbleSort）" class="headerlink" title="冒泡排序（BubbleSort）"></a>冒泡排序（BubbleSort）</h1><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*arr为需要排序的数组*/</span><span class="token keyword">void</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*check为哨兵，如果没有出现数据交换，证明数据都是有序的，退出循环*/</span>    <span class="token keyword">bool</span> check <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*寻找第一大，第二大，第三大..的数据*/</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*挨个挨个的比较数据*/</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                check <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/*没有发生数据交换，退出循环*/</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>check<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="稳定性分析-1"><a href="#稳定性分析-1" class="headerlink" title="稳定性分析"></a>稳定性分析</h2><ul><li>是稳定排序（但如果是<code>arr[j] &gt;= arr[j + 1]</code>就不是稳定排序了）</li></ul><br><h2 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><ul><li>最好是O（n）（没有哨兵的优化就是O（n ^ 2）），最坏和平均都是O（n ^ 2）</li></ul><br><h2 id="空间复杂度分析-1"><a href="#空间复杂度分析-1" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><ul><li><strong>O（1）</strong></li></ul><br><h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h2><ul><li>每一次二级循环都放置一个哨兵，如果flag不变，则说明有序，就不用继续排序了</li></ul><br><br><br><h1 id="归并排序（MergeSort）"><a href="#归并排序（MergeSort）" class="headerlink" title="归并排序（MergeSort）"></a>归并排序（MergeSort）</h1><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*如果右边边界小于等于左边边界，退出排序*/</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*对左边数据排序*/</span>    <span class="token function">merge_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*对右边数据排序*/</span>    <span class="token function">merge_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*这里假设数据左右数据都排好序了，进行归并操作*/</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> left<span class="token punctuation">,</span> j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*        temp用来存储中途的数据，这里原代码是作为一个全局变量        i从左边开始，j从中间开始        分别将数据按大小放入temp中    */</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> tmp<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*哪一边的比较小，就放入哪一边的数*/</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> tmp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i <span class="token operator">++</span> <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//    如果这里把=归到else这里，那么就不是稳定排序了    </span>        <span class="token keyword">else</span> tmp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j <span class="token operator">++</span> <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//    可能左边或右边的数没有全部放完，于是用while把数据全部放进去</span>       <span class="token comment" spellcheck="true">//    ps：左边和右边只可能有一边的数据没有完全放完</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> tmp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i <span class="token operator">++</span> <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> tmp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j <span class="token operator">++</span> <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*把排好序的数据放回arr中*/</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> left<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> t<span class="token operator">:</span> tmp<span class="token punctuation">)</span> arr<span class="token punctuation">[</span>k <span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h3 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h3><ul><li>to do：<a href="https://www.cnblogs.com/nullzx/p/5968170.html" target="_blank" rel="noopener">https://www.cnblogs.com/nullzx/p/5968170.html</a></li></ul><br><h2 id="稳定性分析-2"><a href="#稳定性分析-2" class="headerlink" title="稳定性分析"></a>稳定性分析</h2><ul><li>是稳定排序（但可以修改等号来更改其是否稳定，参考代码的注解）<ul><li>如果相等的时候取值左边，那就是稳定排序，否则就是不稳定排序</li></ul></li></ul><br><h2 id="时间复杂度分析-2"><a href="#时间复杂度分析-2" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><ul><li>假设一开始有n个数，每次对半的整理排序</li><li><img src="/medias/Deep-into-Sort/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%88%86%E6%9E%90.png" alt></li><li>那每一层需要排序的时间就是n，而又已知T(1)=0，所以现在只要求解这颗二叉树的层数即可</li><li>而二叉树的层数是log2n+1，去掉第一行就是log2n</li><li>所以最好和最坏的时间复杂度都是O（nlogn）</li></ul><br><h2 id="空间复杂度分析-2"><a href="#空间复杂度分析-2" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><ul><li>O（n）（需要额外的空间放置排序好的数组）</li></ul><br><br><br><h1 id="堆排序（HeapSort）"><a href="#堆排序（HeapSort）" class="headerlink" title="堆排序（HeapSort）"></a>堆排序（HeapSort）</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li>堆：是具有以下性质的<strong>完全二叉树</strong>，每个结点的值都大于或等于其左右孩子结点的值，称为<strong>大根堆</strong>；或者每个结点的值都小于或等于其左右孩子结点的值，称为<strong>小根堆</strong></li><li>如何在一个完全二叉树组成的数组中，对于其中一个结点，找到它的叶子结点：<ul><li>对于一层中的最左边的结点i，他到最右边的结点之间是差了i的，参考2的n+1次方和2的n次方的关系，这里的i就相当于2的n次方，最后一个节点就相当于2的n+1次方</li></ul></li><li>对于大根堆，选择都是选择当前结点，两个子节点中三者的最大值作为父母结点</li></ul><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//    构建大根堆</span><span class="token keyword">void</span> <span class="token function">create_heap</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>arr<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> max <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//    这里需要判断l和r是否小于n，因为是完全二叉树，有可能出现没有子节点的情况</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>max<span class="token punctuation">]</span><span class="token punctuation">)</span> max <span class="token operator">=</span> l<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>max<span class="token punctuation">]</span><span class="token punctuation">)</span> max <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>max <span class="token operator">!=</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>max<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">create_heap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> max<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//    堆排序</span><span class="token keyword">void</span> <span class="token function">heap_sort</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//    构建大根堆（因为是完全二叉树，所以从n/2-1的位置开始构造）</span>    <span class="token comment" spellcheck="true">//    证明：设数组的长度为n，最后一个父母结点是从头开始数的第n/2-1的那个数（可以自己画一个图去求证）</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span> i<span class="token punctuation">)</span> <span class="token function">create_heap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//    每次将最大的元素放到最后，然后重新构建堆</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">create_heap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="稳定性分析-3"><a href="#稳定性分析-3" class="headerlink" title="稳定性分析"></a>稳定性分析</h2><ul><li>非稳定排序<ul><li>其实heapsort是否为稳定排序是一个很难评定的事情，因为每次重建堆都会修改数据的顺序..，所以一般认为是非稳定排序</li></ul></li></ul><br><h2 id="时间复杂度分析-3"><a href="#时间复杂度分析-3" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><ul><li><p>每次构建堆都是logn的时间复杂度，n个数就是nlogn</p></li><li><p><strong>最好最坏平均都是O（nlogn）</strong></p></li></ul><br><h2 id="空间复杂度分析-3"><a href="#空间复杂度分析-3" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><ul><li><strong>O(1)</strong></li></ul><br><br><br><h1 id="插入排序（InsertSort）"><a href="#插入排序（InsertSort）" class="headerlink" title="插入排序（InsertSort）"></a>插入排序（InsertSort）</h1><h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">insert_sort</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*设定0到i-1范围内的数据都是已经排好序了的*/</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*现在就需要将arr[i]放入到已经排好序了的数组中，可以理解为将当前的数据插入到前面的数组中*/</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">)</span><span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="稳定性分析-4"><a href="#稳定性分析-4" class="headerlink" title="稳定性分析"></a>稳定性分析</h2><ul><li>是稳定排序</li></ul><br><h2 id="时间复杂度分析-4"><a href="#时间复杂度分析-4" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><h3 id="最优的情况-1"><a href="#最优的情况-1" class="headerlink" title="最优的情况"></a>最优的情况</h3><ul><li>数组本身就是有序的，因此就不需要调整数据的位置，在第二个for中会进行break</li><li>此时的时间复杂度是O（n）</li></ul><br><h3 id="最坏的情况-1"><a href="#最坏的情况-1" class="headerlink" title="最坏的情况"></a>最坏的情况</h3><ul><li>数组有序，但是是和我们想要的顺序是相反的，因此每次循环都需要把数据全部往后挪</li><li>此时的时间复杂度是O（n^2）</li></ul><br><h2 id="空间复杂度分析-4"><a href="#空间复杂度分析-4" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><ul><li><strong>O（1）</strong>，不需要额外的空间</li></ul><br><br><br><h1 id="选择排序（SelectSort）"><a href="#选择排序（SelectSort）" class="headerlink" title="选择排序（SelectSort）"></a>选择排序（SelectSort）</h1><h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">select_sort</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*每次选取当前第i大的数据，并把它放到后面*/</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> record <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*在0-i的范围内选取当前的最大值*/</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> maxn <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>maxn <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                record <span class="token operator">=</span> j<span class="token punctuation">;</span>                maxn <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/*交换到它应对的位置*/</span>        std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>record<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="稳定性分析-5"><a href="#稳定性分析-5" class="headerlink" title="稳定性分析"></a>稳定性分析</h2><ul><li>非稳定排序</li></ul><br><h2 id="时间复杂度分析-5"><a href="#时间复杂度分析-5" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><ul><li>无论数组是否有序，每次为了寻找当前的最大值，都必须要遍历一遍前面的数组</li><li>因此时间复杂度上，最好和最坏都是O（n^2）</li></ul><br><h2 id="空间复杂度分析-5"><a href="#空间复杂度分析-5" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><ul><li><strong>O（1）</strong>，不需要额外的空间</li></ul><br><br><br><h1 id="希尔排序（ShellSort）"><a href="#希尔排序（ShellSort）" class="headerlink" title="希尔排序（ShellSort）"></a>希尔排序（ShellSort）</h1><h2 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">shell_sort</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> increment <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*本质上还是插入排序*/</span>    <span class="token comment" spellcheck="true">/*但是这里是对以increment为单位，得到的数组，对其进行插入排序*/</span>    <span class="token comment" spellcheck="true">/*从 局部有序到全体有序*/</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        increment <span class="token operator">=</span> increment <span class="token operator">/</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> increment<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>i <span class="token operator">-</span> increment<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> mid <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> increment<span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> mid <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">-</span><span class="token operator">=</span> increment<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    arr<span class="token punctuation">[</span>j <span class="token operator">+</span> increment<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> mid<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>increment <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h2 id="稳定性分析-6"><a href="#稳定性分析-6" class="headerlink" title="稳定性分析"></a>稳定性分析</h2><ul><li>本质上还是选择排序，所以也是非稳定性排序</li></ul><br><h2 id="时间复杂度分析-6"><a href="#时间复杂度分析-6" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><ul><li><strong>最好是O（n），平均是O（n^1.3）， 最坏是O（n^2）</strong></li></ul><br><h2 id="空间复杂度分析-6"><a href="#空间复杂度分析-6" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><ul><li>O（1）</li></ul><br><br><br><h1 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="23、合并K个升序链表"><a href="#23、合并K个升序链表" class="headerlink" title="23、合并K个升序链表"></a>23、合并K个升序链表</h3><br><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ul><li>Top K</li><li><a href="https://blog.csdn.net/u013309870/article/details/70196537" target="_blank" rel="noopener">打印n个数组中最大的Top k</a></li><li>出现频率前k名的数据</li></ul><br><h2 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h2><h3 id="215、数组中的第K个最大元素"><a href="#215、数组中的第K个最大元素" class="headerlink" title="215、数组中的第K个最大元素"></a>215、数组中的第K个最大元素</h3><p>镜像：剑指 Offer II 076. 数组中的第 k 大的数字</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//    方法一：快速选择</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token function">quick_select</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">// 这里为什么不可以下面不调整left和idx的位置，然后直接返回nums[left]</span>              <span class="token comment" spellcheck="true">// 因为调整idx和left的位置另一个作用便是方便后续left和right调整位置</span>              <span class="token comment" spellcheck="true">// 更准确的说是为了调整好right的位置</span>              <span class="token comment" spellcheck="true">// 因为left直接跳过了idx包括idx的前面的全部部分</span>              <span class="token comment" spellcheck="true">// 而right会继续到idx前面的部分查找</span>              <span class="token comment" spellcheck="true">// 如果此时不调整位置的话，那么会出现两种情况：</span>              <span class="token comment" spellcheck="true">// 第一种情况，right=idx，然后就会直接死循环（因为一直都以left为标准调整）</span>              <span class="token comment" spellcheck="true">// 第二种情况right=idx-1，那么极有可能错过前面的数字，导致误判第k个大小的数）</span>                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> idx <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">quick_select</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token operator">++</span> idx<span class="token punctuation">;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> idx<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//    方法二：魔改快排</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> mid <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span><span class="token operator">++</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span><span class="token operator">--</span> j<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//    这里没写出来，需要注意的就是i和j最后的位置问题</span>        <span class="token comment" spellcheck="true">//    第一种情况，i==j;第二种情况j=i-1</span>        <span class="token comment" spellcheck="true">//    至于为什么要用j来表示，可以参考上面快排的注解</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> right <span class="token operator">-</span> j<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">>=</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k <span class="token operator">-</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h3 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a>剑指 Offer 40. 最小的k个数</h3><p>镜像：面试题 17.14. 最小K个数</p><p>PS：找最小的k个数（或最小的第k个数），和找最大的k个数（或最大的第k个数）的区别，就是<strong>找最小的时候，可以直接用当前的坐标值进行判断</strong>（当前做坐标是i，就代表左边有i个数），而不改变k值；而<strong>找最大的k个数时，是不能根据坐标判断</strong>（当前坐标是i，但是不知道右边还有多少个数字），因此要修改k值</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//    方法一：魔改快排（递归版）</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">getLeastNumbers</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">quick_sort_k</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">quick_sort_k</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> mid <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">do</span> <span class="token operator">++</span> i<span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">do</span> <span class="token operator">--</span> j<span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">quick_sort_k</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">quick_sort_k</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//    方法二：魔改快排（非递归版）</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">smallestK</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> mid <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">do</span> <span class="token operator">++</span> i<span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">do</span> <span class="token operator">--</span> j<span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h3 id="973、最接近原点的K个点"><a href="#973、最接近原点的K个点" class="headerlink" title="973、最接近原点的K个点"></a>973、最接近原点的K个点</h3><p>重写cmp函数即可</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">kClosest</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> points<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">auto</span> cmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> p1<span class="token punctuation">,</span> <span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> p2<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> r1 <span class="token operator">=</span> p1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> p1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> p1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> p1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> r2 <span class="token operator">=</span> p2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> p2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> p2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> p2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> r1 <span class="token operator">&lt;=</span> r2<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> points<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> mid <span class="token operator">=</span> points<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> left<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">cmp</span><span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token operator">++</span> idx<span class="token punctuation">;</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>points<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">,</span> points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>points<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> points<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">(</span>points<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> points<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">></span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> idx <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><br><br><h1 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h1><img src="/medias/Deep-into-Sort/排序算法的复杂度总结.png" style="zoom:150%;"><ul><li><strong>不稳定的排序只有：希尔排序，选择排序，堆排序，快速排序</strong></li></ul><br><p>对于有序的数据，哪种排序算法比较高效？</p><ul><li>冒泡排序和插入排序，在有序数据的情况下都是O（n）</li></ul><br><p>插入排序在什么时候比快速排序要高效？</p><ul><li>当数组大致有序的时候，移动的数据比较少，时间上就会趋于O（n）</li></ul><br><p>计数排序可以做到在数据稠密（重复数字比较多）的情况下，时间趋于O（n）</p><br><p>稳定性的定义：</p><ul><li>假定在待排序的记录序列中，存在多个具有相同的关键字的记录</li><li>若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前</li><li>而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
